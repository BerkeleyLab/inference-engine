! Copyright (c), The Regents of the University of California
! Terms of use are as specified in LICENSE.txt
module trainable_engine_m
  !! Define an abstraction that supports training a neural network
  use julienne_string_m, only : string_t
  use inference_engine_m_, only : inference_engine_t
  use differentiable_activation_strategy_m, only : differentiable_activation_strategy_t
  use kind_parameters_m, only : default_real
  use metadata_m, only : metadata_t
  use tensor_m, only :  tensor_t
  use tensor_map_m, only :  tensor_map_t
  use mini_batch_m, only : mini_batch_t
  use training_configuration_m, only : training_configuration_t
  use input_output_pair_m, only : input_output_pair_t
  implicit none

  private
  public :: trainable_engine_t

  type trainable_engine_t(k)
    !! Encapsulate the information needed to perform training
    integer, kind :: k = default_real
    type(tensor_map_t(k)), private :: input_map_, output_map_ !! mappings to/from data ranges used during training
    class(differentiable_activation_strategy_t), allocatable :: differentiable_activation_strategy_ 
    type(metadata_t) metadata_       !! metadata_ encapsulates strings for which default-kind suffices
      !! stateless and thus not paremeterized; generic resolution supports different kinds
    real(k), allocatable :: w(:,:,:) !! weights
    real(k), allocatable :: b(:,:)   !! biases
    integer, allocatable :: n(:)     !! nodes per layer
    real(k), allocatable, dimension(:,:) :: a
    real(k), allocatable, dimension(:,:,:) :: dcdw, vdw, sdw, vdwc, sdwc
    real(k), allocatable, dimension(:,:) :: z, delta, dcdb, vdb, sdb, vdbc, sdbc
  contains
    generic :: train =>   default_real_train
    procedure, private :: default_real_train
    generic :: predict => default_real_predict
    generic :: infer =>   default_real_predict
    procedure, private :: default_real_predict
    generic   :: assert_consistent => default_real_assert_consistent
    procedure, private ::             default_real_assert_consistent
    generic :: num_layers => default_real_num_layers
    procedure, private ::    default_real_num_layers
    generic :: num_inputs => default_real_num_inputs
    procedure, private ::    default_real_num_inputs
    generic :: num_outputs => default_real_num_outputs
    procedure, private ::     default_real_num_outputs
    generic :: to_inference_engine => default_real_to_inference_engine
    procedure, private ::             default_real_to_inference_engine
    generic :: map_to_input_training_range => default_real_map_to_input_training_range
    procedure, private ::                     default_real_map_to_input_training_range
    generic :: map_from_input_training_range => default_real_map_from_input_training_range
    procedure, private ::                       default_real_map_from_input_training_range
    generic :: map_to_output_training_range => default_real_map_to_output_training_range
    procedure, private ::                      default_real_map_to_output_training_range
    generic :: map_from_output_training_range => default_real_map_from_output_training_range
    procedure, private ::                        default_real_map_from_output_training_range
    generic :: map_to_training_ranges => default_real_map_to_training_ranges
    procedure, private ::                default_real_map_to_training_ranges
  end type

  integer, parameter :: input_layer = 0

  interface trainable_engine_t
#ifdef __INTEL_COMPILER
     impure module function construct_trainable_engine_from_padded_arrays( &
       nodes, weights, biases, differentiable_activation_strategy, metadata, input_map, output_map &
     ) &
#else
     impure module function construct_from_padded_arrays( &
       nodes, weights, biases, differentiable_activation_strategy, metadata, input_map, output_map &
     ) &
#endif
      result(trainable_engine)
      implicit none
      integer, intent(in) :: nodes(input_layer:)
      real, intent(in)  :: weights(:,:,:), biases(:,:)
      class(differentiable_activation_strategy_t), intent(in) :: differentiable_activation_strategy
      type(string_t), intent(in) :: metadata(:)
      type(tensor_map_t), intent(in), optional :: input_map, output_map
      type(trainable_engine_t) trainable_engine
    end function

    impure module function construct_from_inference_engine(inference_engine) result(trainable_engine)
      implicit none
      type(inference_engine_t), intent(in) :: inference_engine
      type(trainable_engine_t) trainable_engine
    end function

    module function perturbed_identity_network(training_configuration, perturbation_magnitude, metadata, input_map, output_map)&
      result(trainable_engine)
      implicit none
      type(training_configuration_t), intent(in) :: training_configuration
      type(string_t), intent(in) :: metadata(:)
      real, intent(in) :: perturbation_magnitude
      type(tensor_map_t) input_map, output_map
      type(trainable_engine_t) trainable_engine
    end function

  end interface

  interface

    pure module subroutine default_real_assert_consistent(self)
      implicit none
      class(trainable_engine_t), intent(in) :: self
    end subroutine

    pure module subroutine default_real_train(self, mini_batches_arr, cost, adam, learning_rate)
      implicit none
      class(trainable_engine_t), intent(inout) :: self
      type(mini_batch_t), intent(in) :: mini_batches_arr(:)
      real, intent(out), allocatable, optional :: cost(:)
      logical, intent(in) :: adam
      real, intent(in) :: learning_rate
    end subroutine

    elemental module function default_real_predict(self, inputs) result(outputs)
      implicit none
      class(trainable_engine_t), intent(in) :: self
      type(tensor_t), intent(in) :: inputs
      type(tensor_t) outputs
    end function
    
    elemental module function default_real_num_inputs(self) result(n_in)
      implicit none
      class(trainable_engine_t), intent(in) :: self
      integer n_in
    end function

    elemental module function default_real_num_outputs(self) result(n_out)
      implicit none
      class(trainable_engine_t), intent(in) :: self
      integer n_out
    end function

    elemental module function default_real_num_layers(self) result(n_layers)
      implicit none
      class(trainable_engine_t), intent(in) :: self
      integer n_layers
    end function

    module function default_real_to_inference_engine(self) result(inference_engine)
      implicit none
      class(trainable_engine_t), intent(in) :: self
      type(inference_engine_t) :: inference_engine
    end function

    elemental module function default_real_map_to_input_training_range(self, tensor) result(normalized_tensor)
      implicit none
      class(trainable_engine_t), intent(in) :: self
      type(tensor_t), intent(in) :: tensor
      type(tensor_t) normalized_tensor
    end function

    elemental module function default_real_map_from_input_training_range(self, tensor) result(unnormalized_tensor)
      implicit none
      class(trainable_engine_t), intent(in) :: self
      type(tensor_t), intent(in) :: tensor
      type(tensor_t) unnormalized_tensor
    end function

    elemental module function default_real_map_to_output_training_range(self, tensor) result(normalized_tensor)
      implicit none
      class(trainable_engine_t), intent(in) :: self
      type(tensor_t), intent(in) :: tensor
      type(tensor_t) normalized_tensor
    end function

    elemental module function default_real_map_from_output_training_range(self, tensor) result(unnormalized_tensor)
      implicit none
      class(trainable_engine_t), intent(in) :: self
      type(tensor_t), intent(in) :: tensor
      type(tensor_t) unnormalized_tensor
    end function

    elemental module function default_real_map_to_training_ranges(self, input_output_pair) result(normalized_input_output_pair)
      implicit none
      class(trainable_engine_t), intent(in) :: self
      type(input_output_pair_t), intent(in) :: input_output_pair
      type(input_output_pair_t) normalized_input_output_pair
    end function

  end interface

end module trainable_engine_m
