var tipuesearch = {"pages":[{"title":" Fiats ","text":"Fiats ___________.__        __          \n\\_   _____/|__|____ _/  |_ ______\n |    __)  |  \\__  \\\\   __\\/  ___/\n |     \\   |  |/ __ \\|  |  \\___ \\ \n \\___  /   |__(____  /__| /____  >\n     \\/            \\/          \\/ Fiats: Functional inference and training for surrogates Alternatively, Fortran inference and training for science . Overview | Getting Started | Documentation Overview Fiats supports research on the training and deployment of neural-network surrogate models for computational science.\nFiats also provides a platform for exploring and advancing the native parallel programming features of Fortran 2023 in the context of deep learning.\nThe design of Fiats centers around functional programming patterns that facilitate concurrency, including loop-level parallelism via the do concurrent construct and Single-Program, Multiple Data (SMPD) parallelism via \"multi-image\" (e.g., multithreaded or multiprocess) execution.\nTowards these ends, Most Fiats procedures are pure and thus satisfy a language requirement for invocation inside do concurrent , The network training procedure use do concurrent to expose automatic parallelization opportunities to compilers, and Exploiting multi-image execution to speedup training is under investigation. To broaden support for the native parallel features, the Fiats contributors also write compiler tests, bug reports, and patches; develop a parallel runtime library ( Caffeine ); participate in the language standardization process; and provide example inference and training code for exercising and evaluating compilers' automatic parallelization capabilities on processors and accelerators, including Graphics Processing Units (GPUs). Available optimizers:\n* Stochastic gradient descent and\n* Adam (recommended). Supported network types:\n* Feed-forward networks and\n* Residual networks (for inference only). Supported activation functions:\n* Sigmoid,\n* RELU,\n* GELU,\n* Swish, and\n* Step (for inference only). Please submit a pull request or an issue to add or request other optimizers, network types, or activation functions. Getting Started Examples and demonstration applications The example subdirectory contains demonstrations of several relatively simple use cases.\nWe recommend reviewing the examples to see how to handle basic tasks such as configuring a network training run or reading a neural network and using it to perform inference. The demo subdirectory contains demonstration applications that depend on Fiats but build separately due to requiring additional prerequisites such as NetCDF and HDF5 .\nThe demonstration applications\n - Train a cloud microphysics model surrogate for the Intermediate Complexity Atmospheric Research ( ICAR ) package,\n - Perform inference using a pretrained model for aerosol dynamics in the Energy Exascale Earth System ( E3SM ) package, and\n - Calculate ICAR cloud microphysics tensor component statistics that provide useful insights for training-data reduction. Building and Testing Because this repository supports programming language research, the code exercises new language features in novel ways.\nWe recommend using any compiler's latest release or even building open-source compilers from source.\nThe handy-dandy repository contains scripts capturing steps for building the LLVM compiler suite.\nThe remainder of this section contains commands for building Fiats with a recent Fortran compiler and the Fortran Package Manager ([ fpm ]). Supported Compilers LLVM ( flang-new ) With LLVM flang 20 installed in your PATH , build and test Fiats with the installed flang-new symlink in order for fpm to correctly identify the compiler: fpm test --compiler flang-new --flag \"-O3\" With LLVM flang 19, enable the compiler's experimental support for assumed-rank entities: fpm test --compiler flang-new --flag \"-mmlir -allow-assumed-rank -O3\" Experimental: Automatic parallelization of do concurrent on CPUs With the amd-trunk-dev branch of the ROCm fork of LLVM, automatically parallelize inference calculations inside do concurrent constructs: fpm run \\\n  --example concurrent-inferences \\\n  --compiler flang-new \\\n  --flag \"-mmlir -allow-assumed-rank -O3 -fopenmp -fdo-concurrent-parallel=host\" \\\n  -- --network model.json where model.json must be a neural network in the JSON format used by Fiats and the companion nexport package. Automatic parallelization for training neural networks is under development. Partially Supported Compilers Fiats release 0.14.0 and earlier support the use of the NAG, GNU, and Intel Fortran compilers.\nWe are corresponding with these compilers' developers about addressing the compiler issues preventing building newer Fiats releases. NAG ( nagfor ) fpm test --compiler nagfor --flag -fpp --profile release GNU ( gfortran ) Compiler bugs related to parameterized derived types currently prevent gfortran from building Fiats versions 0.15.0 or later.\nTest and build earlier versions of Fiats build with the following command: fpm test --compiler gfortran --profile release Intel ( ifx ) Compiler bugs related to generic name resolution currently prevent ifx from building Fiats versions 0.15.0 or later.\nTest and build earlier versions of Fiats build with the following command: fpm test --compiler ifx --profile release --flag -O3 Experimental: Automatic offloading of do concurrent to GPUs This capability is under development with the goal to facilitate automatic GPU offloading via the following command: fpm test -- compiler ifx -- profile release -- flag \"-fopenmp-target-do-concurrent -qopenmp -fopenmp-targets=spir64 -O3\" Under Development We are corresponding with the developers of the compiler(s) below about addressing the compiler issues preventing building Fiats. HPE Cray Compiler Environment (CCE) ( crayftn.sh ) Building with the CCE ftn compiler wrapper requires an additional trivial wrapper.\nFor example, create a file crayftn.sh with the following contents and place this file's location in your PATH : #!/bin/bash ftn \" $@ \" Then execute fpm test --compiler crayftn.sh Configuring a training run Fiats imports hyperparameters and network configurations to and from JSON files.\nTo see the expected file format, run the [print-training-configuration] example as follows: % fpm run --example print-training-configuration --compiler gfortran which should produce output like the following: Project is up to date\n {\n     \"hyperparameters\": {\n         \"mini-batches\" : 10,\n         \"learning rate\" : 1.50000000,\n         \"optimizer\" : \"adam\"\n     }\n ,\n     \"network configuration\": {\n         \"skip connections\" : false,\n         \"nodes per layer\" : [2,72,2],\n         \"activation function\" : \"sigmoid\"\n     }\n } The Fiats JSON file format is fragile: splitting or combining lines breaks the file reader.\nFiles with added or removed white space or reordered whole objects (\"hyperparameters\" or \"network configuration\") should work.\nA future release will leverage the rojff JSON interface to allow for more flexible file formatting. Training a neural network Running the following command will train a neural network to learn the saturated mixing ratio function that is one component of the ICAR SB04 cloud microphysics model (see the saturated_mixing_ratio_m module for an implementation of the involved function): fpm run --example learn-saturated-mixing-ratio --compiler gfortran --profile release -- --output-file sat-mix-rat.json The following is representative output after 3000 epochs: Initializing a new network\n         Epoch | Cost Function| System_Clock | Nodes per Layer\n         1000    0.79896E-04     4.8890      2,4,72,2,1\n         2000    0.61259E-04     9.8345      2,4,72,2,1\n         3000    0.45270E-04     14.864      2,4,72,2,1 The example program halts execution after reaching a cost-function threshold (which requires millions of epochs) or a maximum number of iterations or if the program detects a file named stop in the source-tree root directory.\nBefore halting, the program will print a table of expected and predicted saturated mixing ratio values across a range of input pressures and temperatures, wherein two the inputs have each been mapped to the unit interval [0,1].\nThe program also writes the neural network initial condition to initial-network.json and the final (trained) network to the file specified in the above command: sat-mix-rat.json . Performing inference Users with a PyTorch model may use nexport to export the model to JSON files that Fiats can read.\nExamples of performing inference using a neural-network JSON file are in example/concurrent-inferences . Documentation HTML Please see our GitHub Pages site for Hypertext Markup Languge (HTML) documentation generated by [ ford ] or generate documentation locally by installing ford and executing ford ford.md . UML Please see the doc/uml subdirectory for Unified Modeling Language (UML) diagrams such as a comprehensive Fiats class diagram with human-readable Mermaid source that renders graphically when opened by browsing to the document on GitHub. Developer Info Berkeley Lab","tags":"home","loc":"index.html"},{"title":"trainable_network_t – Fiats ","text":"type, public, extends( neural_network_t ) :: trainable_network_t Inherits type~~trainable_network_t~~InheritsGraph type~trainable_network_t trainable_network_t type~neural_network_t neural_network_t type~trainable_network_t->type~neural_network_t type~workspace_t workspace_t type~trainable_network_t->type~workspace_t workspace_ type~activation_t activation_t type~neural_network_t->type~activation_t activation_ type~metadata_t metadata_t type~neural_network_t->type~metadata_t metadata_ type~tensor_map_t tensor_map_t type~neural_network_t->type~tensor_map_t input_map_, output_map_ string_t string_t type~metadata_t->string_t modelName_, modelAuthor_, compilationDate_, activationFunction_, usingSkipConnections_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real integer, public, kind :: k = default_real type( workspace_t ), private :: workspace_ Constructor public        interface trainable_network_t private pure module function default_real_network(neural_network) result(trainable_network) Implementation → Arguments Type Intent Optional Attributes Name type( neural_network_t ), intent(in) :: neural_network Return Value type( trainable_network_t ) private module function perturbed_identity_network(training_configuration, perturbation_magnitude, metadata, input_map, output_map) result(trainable_network) Implementation → Arguments Type Intent Optional Attributes Name type( training_configuration_t ), intent(in) :: training_configuration real, intent(in) :: perturbation_magnitude type(string_t), intent(in) :: metadata (:) type( tensor_map_t ) :: input_map type( tensor_map_t ) :: output_map Return Value type( trainable_network_t ) Type-Bound Procedures generic, public :: activation_function_name => default_real_activation_name , double_precision_activation_name private  interface default_real_activation_name () Arguments None private  interface double_precision_activation_name () Arguments None generic, public :: assert_conformable_with => default_real_assert_conformable_with , double_precision_assert_conformable_with private  interface default_real_assert_conformable_with () Arguments None private  interface double_precision_assert_conformable_with () Arguments None generic, public :: assert_consistency => default_real_consistency , double_precision_consistency private  interface default_real_consistency () Arguments None private  interface double_precision_consistency () Arguments None generic, public :: infer => default_real_infer , double_precision_infer private  interface default_real_infer () Arguments None private  interface double_precision_infer () Arguments None generic, public :: learn => default_real_learn private  interface default_real_learn () Arguments None generic, public :: map_from_output_range => default_real_map_from_output_range , double_precision_map_from_output_range private  interface default_real_map_from_output_range () Arguments None private  interface double_precision_map_from_output_range () Arguments None generic, public :: map_to_input_range => default_real_map_to_input_range , double_precision_map_to_input_range private  interface default_real_map_to_input_range () Arguments None private  interface double_precision_map_to_input_range () Arguments None generic, public :: map_to_training_ranges => default_real_map_to_training_ranges private  interface default_real_map_to_training_ranges () Arguments None generic, public :: nodes_per_layer => default_real_nodes_per_layer , double_precision_nodes_per_layer private  interface default_real_nodes_per_layer () Arguments None private  interface double_precision_nodes_per_layer () Arguments None generic, public :: num_hidden_layers => default_real_num_hidden_layers , double_precision_num_hidden_layers private  interface default_real_num_hidden_layers () Arguments None private  interface double_precision_num_hidden_layers () Arguments None generic, public :: num_inputs => default_real_num_inputs , double_precision_num_inputs private  interface default_real_num_inputs () Arguments None private  interface double_precision_num_inputs () Arguments None generic, public :: num_outputs => default_real_num_outputs , double_precision_num_outputs private  interface default_real_num_outputs () Arguments None private  interface double_precision_num_outputs () Arguments None generic, public :: operator(==) => default_real_approximately_equal , double_precision_approximately_equal private  interface default_real_approximately_equal () Arguments None private  interface double_precision_approximately_equal () Arguments None generic, public :: skip => default_real_skip , double_precision_skip private  interface default_real_skip () Arguments None private  interface double_precision_skip () Arguments None generic, public :: to_json => default_real_to_json , double_precision_to_json private  interface default_real_to_json () Arguments None private  interface double_precision_to_json () Arguments None generic, public :: train => default_real_train private  interface default_real_train () Arguments None procedure, private, non_overridable :: default_real_map_to_training_ranges interface private elemental module function default_real_map_to_training_ranges(self, input_output_pair) result(normalized_input_output_pair) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_network_t ), intent(in) :: self type( input_output_pair_t ), intent(in) :: input_output_pair Return Value type( input_output_pair_t ) procedure, private, non_overridable :: default_real_train interface private pure module subroutine default_real_train(self, mini_batches_arr, cost, adam, learning_rate) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_network_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches_arr (:) real, intent(out), optional, allocatable :: cost (:) logical, intent(in) :: adam real, intent(in) :: learning_rate","tags":"","loc":"type/trainable_network_t.html"},{"title":"training_configuration_t – Fiats ","text":"type, public, extends( double_precision_file_t ) :: training_configuration_t Inherits type~~training_configuration_t~~InheritsGraph type~training_configuration_t training_configuration_t type~double_precision_file_t double_precision_file_t type~training_configuration_t->type~double_precision_file_t type~hyperparameters_t hyperparameters_t type~training_configuration_t->type~hyperparameters_t hyperparameters_ type~network_configuration_t network_configuration_t type~training_configuration_t->type~network_configuration_t network_configuration_ file_t file_t type~double_precision_file_t->file_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real type( hyperparameters_t (k)), private :: hyperparameters_ type( network_configuration_t ), private :: network_configuration_ Constructor public        interface training_configuration_t private module function default_real_from_components(hyperparameters, network_configuration) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type( hyperparameters_t ), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t ) private module function default_real_from_file(file_object) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_object Return Value type( training_configuration_t ) private module function double_precision_from_components(hyperparameters, network_configuration) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type( hyperparameters_t (double_precision)), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t (double_precision)) private module function double_precision_from_file(file_object) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_file_t ), intent(in) :: file_object Return Value type( training_configuration_t (double_precision)) Type-Bound Procedures generic, public :: differentiable_activation => default_real_differentiable_activation , double_precision_differentiable_activation private  interface default_real_differentiable_activation () Arguments None private  interface double_precision_differentiable_activation () Arguments None procedure, public :: double_precision_lines interface public pure module function double_precision_lines(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( double_precision_file_t ), intent(in) :: self Return Value type( double_precision_string_t ), allocatable, (:) generic, public :: learning_rate => default_real_learning_rate , double_precision_learning_rate private  interface default_real_learning_rate () Arguments None private  interface double_precision_learning_rate () Arguments None generic, public :: mini_batches => default_real_mini_batches , double_precision_mini_batches private  interface default_real_mini_batches () Arguments None private  interface double_precision_mini_batches () Arguments None generic, public :: nodes_per_layer => default_real_nodes_per_layer , double_precision_nodes_per_layer private  interface default_real_nodes_per_layer () Arguments None private  interface double_precision_nodes_per_layer () Arguments None generic, public :: operator(==) => default_real_equals , double_precision_equals private  interface default_real_equals () Arguments None private  interface double_precision_equals () Arguments None generic, public :: optimizer_name => default_real_optimizer_name , double_precision_optimizer_name private  interface default_real_optimizer_name () Arguments None private  interface double_precision_optimizer_name () Arguments None generic, public :: skip_connections => default_real_skip_connections , double_precision_skip_connections private  interface default_real_skip_connections () Arguments None private  interface double_precision_skip_connections () Arguments None generic, public :: to_json => default_real_to_json , double_precision_to_json private  interface default_real_to_json () Arguments None private  interface double_precision_to_json () Arguments None procedure, private :: default_real_differentiable_activation interface private module function default_real_differentiable_activation(self) result(activation) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type( activation_t ) procedure, private :: default_real_equals interface private elemental module function default_real_equals(lhs, rhs) result(lhs_eq_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: lhs class( training_configuration_t ), intent(in) :: rhs Return Value logical procedure, private :: default_real_learning_rate interface private elemental module function default_real_learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value real procedure, private :: default_real_mini_batches interface private elemental module function default_real_mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer procedure, private :: default_real_nodes_per_layer interface private pure module function default_real_nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) procedure, private :: default_real_optimizer_name interface private elemental module function default_real_optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t) procedure, private :: default_real_skip_connections interface private elemental module function default_real_skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value logical procedure, private :: default_real_to_json interface private pure module function default_real_to_json(self) result(json_lines) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) procedure, private :: double_precision_differentiable_activation interface private module function double_precision_differentiable_activation(self) result(activation) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value type( activation_t ) procedure, private :: double_precision_equals interface private elemental module function double_precision_equals(lhs, rhs) result(lhs_eq_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: lhs class( training_configuration_t (double_precision)), intent(in) :: rhs Return Value logical procedure, private :: double_precision_learning_rate interface private elemental module function double_precision_learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value double precision procedure, private :: double_precision_mini_batches interface private elemental module function double_precision_mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value integer procedure, private :: double_precision_nodes_per_layer interface private pure module function double_precision_nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value integer, allocatable, (:) procedure, private :: double_precision_optimizer_name interface private elemental module function double_precision_optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value type(string_t) procedure, private :: double_precision_skip_connections interface private elemental module function double_precision_skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value logical procedure, private :: double_precision_to_json interface private pure module function double_precision_to_json(self) result(json_lines) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"type/training_configuration_t.html"},{"title":"network_configuration_t – Fiats ","text":"type, public :: network_configuration_t Inherited by type~~network_configuration_t~~InheritedByGraph type~network_configuration_t network_configuration_t type~training_configuration_t training_configuration_t type~training_configuration_t->type~network_configuration_t network_configuration_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: activation_name_ integer, private, allocatable :: nodes_per_layer_ (:) logical, private :: skip_connections_ = .false. Constructor public        interface network_configuration_t private pure module function from_components(skip_connections, nodes_per_layer, activation_name) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name logical, intent(in) :: skip_connections integer, intent(in) :: nodes_per_layer (:) character(len=*), intent(in) :: activation_name Return Value type( network_configuration_t ) private pure module function from_double_precision_string_json(lines) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: lines (:) Return Value type( network_configuration_t ) private pure module function from_json(lines) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( network_configuration_t ) Type-Bound Procedures procedure, public :: activation_name interface private elemental module function activation_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t) procedure, public :: equals interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: lhs class( network_configuration_t ), intent(in) :: rhs Return Value logical procedure, public :: nodes_per_layer interface private pure module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) generic, public :: operator(==) => equals private  interface equals () Arguments None procedure, public :: skip_connections interface private elemental module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value logical procedure, public :: to_json interface private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"type/network_configuration_t.html"},{"title":"activation_t – Fiats ","text":"type, public :: activation_t Inherited by type~~activation_t~~InheritedByGraph type~activation_t activation_t type~neural_network_t neural_network_t type~neural_network_t->type~activation_t activation_ type~trainable_network_t trainable_network_t type~trainable_network_t->type~neural_network_t type~unmapped_network_t unmapped_network_t type~unmapped_network_t->type~neural_network_t neural_network_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=c_int), private :: selection_ = sigmoid Constructor public        interface activation_t private elemental module function construct_from_component(selection) result(activation) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: selection Return Value type( activation_t ) private elemental module function construct_from_name(name) result(activation) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value type( activation_t ) Type-Bound Procedures generic, public :: differentiate => default_real_differentiate , double_precision_differentiate private  interface default_real_differentiate () Arguments None private  interface double_precision_differentiate () Arguments None generic, public :: evaluate => default_real_evaluate , double_precision_evaluate private  interface default_real_evaluate () Arguments None private  interface double_precision_evaluate () Arguments None procedure, public, non_overridable :: function_name interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self Return Value type(string_t) generic, public :: operator(==) => equals private  interface equals () Arguments None procedure, private, non_overridable :: default_real_differentiate interface private elemental module function default_real_differentiate(self, x) result(dy_dx) Implementation → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self real, intent(in) :: x Return Value real procedure, private, non_overridable :: default_real_evaluate interface private elemental module function default_real_evaluate(self, x) result(y) Implementation → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self real, intent(in) :: x Return Value real procedure, private, non_overridable :: double_precision_differentiate interface private elemental module function double_precision_differentiate(self, x) result(dy_dx) Implementation → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self double precision, intent(in) :: x Return Value double precision procedure, private, non_overridable :: double_precision_evaluate interface private elemental module function double_precision_evaluate(self, x) result(y) Implementation → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self double precision, intent(in) :: x Return Value double precision procedure, private :: equals interface private elemental module function equals(self, rhs) result(self_eq_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self type( activation_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"type/activation_t.html"},{"title":"double_precision_string_t – Fiats ","text":"type, public, extends(string_t) :: double_precision_string_t Inherits type~~double_precision_string_t~~InheritsGraph type~double_precision_string_t double_precision_string_t string_t string_t type~double_precision_string_t->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Constructor public        interface double_precision_string_t public elemental module function construct_from_string(string) result(double_precision_string) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: string Return Value type( double_precision_string_t )","tags":"","loc":"type/double_precision_string_t.html"},{"title":"input_output_pair_t – Fiats ","text":"type, public :: input_output_pair_t Inherits type~~input_output_pair_t~~InheritsGraph type~input_output_pair_t input_output_pair_t type~tensor_t tensor_t type~input_output_pair_t->type~tensor_t inputs_, expected_outputs_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~input_output_pair_t~~InheritedByGraph type~input_output_pair_t input_output_pair_t type~mini_batch_t mini_batch_t type~mini_batch_t->type~input_output_pair_t input_output_pairs_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real type( tensor_t (k)), private :: expected_outputs_ type( tensor_t (k)), private :: inputs_ Constructor public        interface input_output_pair_t private elemental module function default_real_construct(inputs, expected_outputs) result(input_output_pair) Implementation → Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t ) private elemental module function double_precision_construct(inputs, expected_outputs) result(input_output_pair) Implementation → Arguments Type Intent Optional Attributes Name type( tensor_t (double_precision)), intent(in) :: inputs type( tensor_t (double_precision)), intent(in) :: expected_outputs Return Value type( input_output_pair_t (double_precision)) Type-Bound Procedures generic, public :: expected_outputs => default_real_expected_outputs , double_precision_expected_outputs private  interface default_real_expected_outputs () Arguments None private  interface double_precision_expected_outputs () Arguments None generic, public :: inputs => default_real_inputs , double_precision_inputs private  interface default_real_inputs () Arguments None private  interface double_precision_inputs () Arguments None procedure, private, non_overridable :: default_real_expected_outputs interface private elemental module function default_real_expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) procedure, private, non_overridable :: default_real_inputs interface private elemental module function default_real_inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) procedure, private, non_overridable :: double_precision_expected_outputs interface private elemental module function double_precision_expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t (double_precision)), intent(in) :: self Return Value type( tensor_t (double_precision)) procedure, private, non_overridable :: double_precision_inputs interface private elemental module function double_precision_inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t (double_precision)), intent(in) :: self Return Value type( tensor_t (double_precision))","tags":"","loc":"type/input_output_pair_t.html"},{"title":"double_precision_file_t – Fiats ","text":"type, public, extends(file_t) :: double_precision_file_t Inherits type~~double_precision_file_t~~InheritsGraph type~double_precision_file_t double_precision_file_t file_t file_t type~double_precision_file_t->file_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~double_precision_file_t~~InheritedByGraph type~double_precision_file_t double_precision_file_t type~training_configuration_t training_configuration_t type~training_configuration_t->type~double_precision_file_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Constructor public        interface double_precision_file_t public impure elemental module function construct_from_character(file_name) result(double_precision_file) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value type( double_precision_file_t ) public impure elemental module function construct_from_string(file_name) result(double_precision_file) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: file_name Return Value type( double_precision_file_t ) Type-Bound Procedures procedure, public :: double_precision_lines interface public pure module function double_precision_lines(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( double_precision_file_t ), intent(in) :: self Return Value type( double_precision_string_t ), allocatable, (:)","tags":"","loc":"type/double_precision_file_t.html"},{"title":"ubounds_t – Fiats ","text":"type, public :: ubounds_t Components Type Visibility Attributes Name Initial integer, public, allocatable :: ubounds_ (:) Type-Bound Procedures procedure, public :: equals public elemental function equals (lhs, rhs) result(lhs_equals_rhs) Arguments Type Intent Optional Attributes Name class( ubounds_t ), intent(in) :: lhs class( ubounds_t ), intent(in) :: rhs Return Value logical generic, public :: operator(==) => equals public elemental function equals (lhs, rhs) result(lhs_equals_rhs) Arguments Type Intent Optional Attributes Name class( ubounds_t ), intent(in) :: lhs class( ubounds_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"type/ubounds_t.html"},{"title":"hyperparameters_t – Fiats ","text":"type, public :: hyperparameters_t Inherited by type~~hyperparameters_t~~InheritedByGraph type~hyperparameters_t hyperparameters_t type~training_configuration_t training_configuration_t type~training_configuration_t->type~hyperparameters_t hyperparameters_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real character(len=:), public, allocatable :: optimizer_ real(kind=k), private :: learning_rate_ = real(1.5, k) integer, private :: mini_batches_ = 10 Constructor public        interface hyperparameters_t private pure module function default_real_from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches real, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t ) private pure module function default_real_from_json(lines) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( hyperparameters_t ) private pure module function double_precision_from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches double precision, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t (double_precision)) private pure module function double_precision_from_json(lines) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: lines (:) Return Value type( hyperparameters_t (double_precision)) Type-Bound Procedures generic, public :: learning_rate => default_real_learning_rate , double_precision_learning_rate private  interface default_real_learning_rate () Arguments None private  interface double_precision_learning_rate () Arguments None generic, public :: mini_batches => default_real_mini_batches , double_precision_mini_batches private  interface default_real_mini_batches () Arguments None private  interface double_precision_mini_batches () Arguments None generic, public :: operator(==) => default_real_equals , double_precision_equals private  interface default_real_equals () Arguments None private  interface double_precision_equals () Arguments None generic, public :: optimizer_name => default_real_optimizer_name , double_precision_optimizer_name private  interface default_real_optimizer_name () Arguments None private  interface double_precision_optimizer_name () Arguments None generic, public :: to_json => default_real_to_json , double_precision_to_json private  interface default_real_to_json () Arguments None private  interface double_precision_to_json () Arguments None procedure, private :: default_real_equals interface private elemental module function default_real_equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: lhs class( hyperparameters_t ), intent(in) :: rhs Return Value logical procedure, private :: default_real_learning_rate interface private elemental module function default_real_learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value real procedure, private :: default_real_mini_batches interface private elemental module function default_real_mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value integer procedure, private :: default_real_optimizer_name interface private elemental module function default_real_optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t) procedure, private :: default_real_to_json interface private pure module function default_real_to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) procedure, private :: double_precision_equals interface private elemental module function double_precision_equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: lhs class( hyperparameters_t (double_precision)), intent(in) :: rhs Return Value logical procedure, private :: double_precision_learning_rate interface private elemental module function double_precision_learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: self Return Value double precision procedure, private :: double_precision_mini_batches interface private elemental module function double_precision_mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: self Return Value integer procedure, private :: double_precision_optimizer_name interface private elemental module function double_precision_optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: self Return Value type(string_t) procedure, private :: double_precision_to_json interface private pure module function double_precision_to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"type/hyperparameters_t.html"},{"title":"tensor_t – Fiats ","text":"type, public :: tensor_t Inherited by type~~tensor_t~~InheritedByGraph type~tensor_t tensor_t type~input_output_pair_t input_output_pair_t type~input_output_pair_t->type~tensor_t inputs_, expected_outputs_ type~mini_batch_t mini_batch_t type~mini_batch_t->type~input_output_pair_t input_output_pairs_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real real(kind=k), private, allocatable :: values_ (:) Constructor public        interface tensor_t private pure module function construct_default_real(values) result(tensor) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: values (:) Return Value type( tensor_t ) private pure module function construct_double_precision(values) result(tensor) Implementation → Arguments Type Intent Optional Attributes Name double precision, intent(in) :: values (:) Return Value type( tensor_t (double_precision)) Type-Bound Procedures generic, public :: num_components => default_real_num_components , double_precision_num_components private  interface default_real_num_components () Arguments None private  interface double_precision_num_components () Arguments None generic, public :: values => default_real_values , double_precision_values private  interface default_real_values () Arguments None private  interface double_precision_values () Arguments None procedure, private :: default_real_num_components interface private pure module function default_real_num_components(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer procedure, private, non_overridable :: default_real_values interface private pure module function default_real_values(self) result(tensor_values) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real, allocatable, (:) procedure, private :: double_precision_num_components interface private pure module function double_precision_num_components(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t (double_precision)), intent(in) :: self Return Value integer procedure, private, non_overridable :: double_precision_values interface private pure module function double_precision_values(self) result(tensor_values) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t (double_precision)), intent(in) :: self Return Value double precision, allocatable, (:)","tags":"","loc":"type/tensor_t.html"},{"title":"mini_batch_t – Fiats ","text":"type, public :: mini_batch_t Inherits type~~mini_batch_t~~InheritsGraph type~mini_batch_t mini_batch_t type~input_output_pair_t input_output_pair_t type~mini_batch_t->type~input_output_pair_t input_output_pairs_ type~tensor_t tensor_t type~input_output_pair_t->type~tensor_t inputs_, expected_outputs_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real type( input_output_pair_t (k)), private, allocatable :: input_output_pairs_ (:) Constructor public        interface mini_batch_t private pure module function default_real_construct(input_output_pairs) result(mini_batch) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t ) private pure module function double_precision_construct(input_output_pairs) result(mini_batch) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t (double_precision)), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t (double_precision)) Type-Bound Procedures procedure, public, non_overridable :: default_real_input_output_pairs interface private pure module function default_real_input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ), allocatable, (:) procedure, public, non_overridable :: double_precision_input_output_pairs interface private pure module function double_precision_input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t (double_precision)), intent(in) :: self Return Value type( input_output_pair_t (double_precision)), allocatable, (:) generic, public :: input_output_pairs => default_real_input_output_pairs , double_precision_input_output_pairs private  interface default_real_input_output_pairs () Arguments None private  interface double_precision_input_output_pairs () Arguments None","tags":"","loc":"type/mini_batch_t.html"},{"title":"layer_t – Fiats ","text":"type, public :: layer_t linked list of layers, each comprised of a linked list of neurons Inherits type~~layer_t~~InheritsGraph type~layer_t layer_t type~layer_t->type~layer_t next type~neuron_t neuron_t type~layer_t->type~neuron_t neuron type~neuron_t->type~neuron_t next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real type( neuron_t (k)), private :: neuron linked list of this layer's neurons type( layer_t (k)), private, allocatable :: next next layer Constructor public        interface layer_t private recursive module function default_real_construct_layer(layer_lines, start) result(layer) Implementation → construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ), target private recursive module function double_precision_construct_layer(layer_lines, start) result(layer) Implementation → construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t (double_precision)), target Type-Bound Procedures generic, public :: count_inputs => default_real_count_inputs , double_precision_count_inputs private  interface default_real_count_inputs () Arguments None private  interface double_precision_count_inputs () Arguments None generic, public :: count_layers => default_real_count_layers , double_precision_count_layers private  interface default_real_count_layers () Arguments None private  interface double_precision_count_layers () Arguments None generic, public :: count_neurons => default_real_count_neurons , double_precision_count_neurons private  interface default_real_count_neurons () Arguments None private  interface double_precision_count_neurons () Arguments None generic, public :: neural_network => default_real_neural_network , double_precision_neural_network private  interface default_real_neural_network () Arguments None private  interface double_precision_neural_network () Arguments None generic, public :: neurons_per_layer => default_real_neurons_per_layer , double_precision_neurons_per_layer private  interface default_real_neurons_per_layer () Arguments None private  interface double_precision_neurons_per_layer () Arguments None generic, public :: next_allocated => default_real_next_allocated , double_precision_next_allocated private  interface default_real_next_allocated () Arguments None private  interface double_precision_next_allocated () Arguments None generic, public :: next_pointer => default_real_next_pointer , double_precision_next_pointer private  interface default_real_next_pointer () Arguments None private  interface double_precision_next_pointer () Arguments None procedure, private :: default_real_count_inputs interface private module function default_real_count_inputs(layer) result(num_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer procedure, private :: default_real_count_layers interface private module function default_real_count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer procedure, private :: default_real_count_neurons interface private module function default_real_count_neurons(layer) result(neurons_per_layer_result) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer, allocatable, (:) procedure, private :: default_real_neural_network interface private module function default_real_neural_network(hidden_layers, metadata, output_layer, input_map, output_map) result(neural_network_) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer type( tensor_map_t ), intent(in) :: input_map type( tensor_map_t ), intent(in) :: output_map Return Value type( neural_network_t ) procedure, private :: default_real_neurons_per_layer interface private module function default_real_neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer procedure, private :: default_real_next_allocated interface private module function default_real_next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical procedure, private :: default_real_next_pointer interface private module function default_real_next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ), pointer procedure, private :: double_precision_count_inputs interface private module function double_precision_count_inputs(layer) result(num_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in) :: layer Return Value integer procedure, private :: double_precision_count_layers interface private module function double_precision_count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: layer Return Value integer procedure, private :: double_precision_count_neurons interface private module function double_precision_count_neurons(layer) result(neurons_per_layer_result) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: layer Return Value integer, allocatable, (:) procedure, private :: double_precision_neural_network interface private module function double_precision_neural_network(hidden_layers, metadata, output_layer, input_map, output_map) result(neural_network_) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: hidden_layers type( metadata_t ), intent(in) :: metadata type( layer_t (double_precision)), intent(in), target :: output_layer type( tensor_map_t (double_precision)), intent(in) :: input_map type( tensor_map_t (double_precision)), intent(in) :: output_map Return Value type( neural_network_t (double_precision)) procedure, private :: double_precision_neurons_per_layer interface private module function double_precision_neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: self Return Value integer procedure, private :: double_precision_next_allocated interface private module function double_precision_next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in) :: self Return Value logical procedure, private :: double_precision_next_pointer interface private module function double_precision_next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: self Return Value type( layer_t (double_precision)), pointer","tags":"","loc":"type/layer_t.html"},{"title":"neuron_t – Fiats ","text":"type, public :: neuron_t linked list of neurons Inherited by type~~neuron_t~~InheritedByGraph type~neuron_t neuron_t type~neuron_t->type~neuron_t next type~layer_t layer_t type~layer_t->type~neuron_t neuron type~layer_t->type~layer_t next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real real(kind=k), private :: bias_ type( neuron_t (k)), private, allocatable :: next real(kind=k), private, allocatable :: weights_ (:) Constructor public        interface neuron_t private pure module function default_real_from_components(weights, bias) result(neuron) Implementation → construct single neuron_t object from an array of weights and a bias Arguments Type Intent Optional Attributes Name real, intent(in) :: weights (:) real, intent(in) :: bias Return Value type( neuron_t ) private pure module function double_precision_from_components(weights, bias) result(neuron) Implementation → construct single neuron_t object from an array of weights and a bias Arguments Type Intent Optional Attributes Name double precision, intent(in) :: weights (:) double precision, intent(in) :: bias Return Value type( neuron_t (double_precision)) private pure recursive module function double_precision_from_json(neuron_lines, start) result(neuron) Implementation → construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t (double_precision)) private pure recursive module function from_json(neuron_lines, start) result(neuron) Implementation → construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) Type-Bound Procedures generic, public :: bias => default_real_bias , double_precision_bias private  interface default_real_bias () Arguments None private  interface double_precision_bias () Arguments None generic, public :: next_allocated => default_real_next_allocated , double_precision_next_allocated private  interface default_real_next_allocated () Arguments None private  interface double_precision_next_allocated () Arguments None generic, public :: next_pointer => default_real_next_pointer , double_precision_next_pointer private  interface default_real_next_pointer () Arguments None private  interface double_precision_next_pointer () Arguments None generic, public :: num_inputs => default_real_num_inputs , double_precision_num_inputs private  interface default_real_num_inputs () Arguments None private  interface double_precision_num_inputs () Arguments None generic, public :: to_json => default_real_to_json , double_precision_to_json private  interface default_real_to_json () Arguments None private  interface double_precision_to_json () Arguments None generic, public :: weights => default_real_weights , double_precision_weights private  interface default_real_weights () Arguments None private  interface double_precision_weights () Arguments None procedure, private :: default_real_bias interface private module function default_real_bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real procedure, private :: default_real_next_allocated interface private module function default_real_next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical procedure, private :: default_real_next_pointer interface private module function default_real_next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ), pointer procedure, private :: default_real_num_inputs interface private pure module function default_real_num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer procedure, private :: default_real_to_json interface private pure module function default_real_to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) procedure, private :: default_real_weights interface private module function default_real_weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real, allocatable, (:) procedure, private :: double_precision_bias interface private module function double_precision_bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value double precision procedure, private :: double_precision_next_allocated interface private module function double_precision_next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value logical procedure, private :: double_precision_next_pointer interface private module function double_precision_next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in), target :: self Return Value type( neuron_t (double_precision)), pointer procedure, private :: double_precision_num_inputs interface private pure module function double_precision_num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value integer procedure, private :: double_precision_to_json interface private pure module function double_precision_to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value type(string_t), allocatable, (:) procedure, private :: double_precision_weights interface private module function double_precision_weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value double precision, allocatable, (:)","tags":"","loc":"type/neuron_t.html"},{"title":"neural_network_t – Fiats ","text":"type, public :: neural_network_t Encapsulate the information needed to perform inference Inherits type~~neural_network_t~~InheritsGraph type~neural_network_t neural_network_t type~activation_t activation_t type~neural_network_t->type~activation_t activation_ type~metadata_t metadata_t type~neural_network_t->type~metadata_t metadata_ type~tensor_map_t tensor_map_t type~neural_network_t->type~tensor_map_t input_map_, output_map_ string_t string_t type~metadata_t->string_t modelName_, modelAuthor_, compilationDate_, activationFunction_, usingSkipConnections_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~neural_network_t~~InheritedByGraph type~neural_network_t neural_network_t type~trainable_network_t trainable_network_t type~trainable_network_t->type~neural_network_t type~unmapped_network_t unmapped_network_t type~unmapped_network_t->type~neural_network_t neural_network_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real type( activation_t ), private :: activation_ real(kind=k), private, allocatable :: biases_ (:,:) type( tensor_map_t (k)), private :: input_map_ type( metadata_t ), private :: metadata_ integer, private, allocatable :: nodes_ (:) type( tensor_map_t (k)), private :: output_map_ real(kind=k), private, allocatable :: weights_ (:,:,:) Constructor public        interface neural_network_t private module function default_real_construct_from_components(metadata, weights, biases, nodes, input_map, output_map) result(neural_network) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real, intent(in) :: weights (:,:,:) real, intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) type( tensor_map_t ), intent(in), optional :: input_map type( tensor_map_t ), intent(in), optional :: output_map Return Value type( neural_network_t ) private impure elemental module function default_real_from_json(file_) result(neural_network) Implementation → Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( neural_network_t ) private module function double_precision_construct_from_components(metadata, weights, biases, nodes, input_map, output_map) result(neural_network) Implementation → Arguments Type Intent Optional Attributes Name type( metadata_t ), intent(in) :: metadata double precision, intent(in) :: weights (:,:,:) double precision, intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) type( tensor_map_t (double_precision)), intent(in), optional :: input_map type( tensor_map_t (double_precision)), intent(in), optional :: output_map Return Value type( neural_network_t (double_precision)) private impure elemental module function double_precision_from_json(file) result(neural_network) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_file_t ), intent(in) :: file Return Value type( neural_network_t (double_precision)) Type-Bound Procedures generic, public :: activation_function_name => default_real_activation_name , double_precision_activation_name private  interface default_real_activation_name () Arguments None private  interface double_precision_activation_name () Arguments None generic, public :: assert_conformable_with => default_real_assert_conformable_with , double_precision_assert_conformable_with private  interface default_real_assert_conformable_with () Arguments None private  interface double_precision_assert_conformable_with () Arguments None generic, public :: assert_consistency => default_real_consistency , double_precision_consistency private  interface default_real_consistency () Arguments None private  interface double_precision_consistency () Arguments None generic, public :: infer => default_real_infer , double_precision_infer private  interface default_real_infer () Arguments None private  interface double_precision_infer () Arguments None generic, public :: learn => default_real_learn private  interface default_real_learn () Arguments None generic, public :: map_from_output_range => default_real_map_from_output_range , double_precision_map_from_output_range private  interface default_real_map_from_output_range () Arguments None private  interface double_precision_map_from_output_range () Arguments None generic, public :: map_to_input_range => default_real_map_to_input_range , double_precision_map_to_input_range private  interface default_real_map_to_input_range () Arguments None private  interface double_precision_map_to_input_range () Arguments None generic, public :: nodes_per_layer => default_real_nodes_per_layer , double_precision_nodes_per_layer private  interface default_real_nodes_per_layer () Arguments None private  interface double_precision_nodes_per_layer () Arguments None generic, public :: num_hidden_layers => default_real_num_hidden_layers , double_precision_num_hidden_layers private  interface default_real_num_hidden_layers () Arguments None private  interface double_precision_num_hidden_layers () Arguments None generic, public :: num_inputs => default_real_num_inputs , double_precision_num_inputs private  interface default_real_num_inputs () Arguments None private  interface double_precision_num_inputs () Arguments None generic, public :: num_outputs => default_real_num_outputs , double_precision_num_outputs private  interface default_real_num_outputs () Arguments None private  interface double_precision_num_outputs () Arguments None generic, public :: operator(==) => default_real_approximately_equal , double_precision_approximately_equal private  interface default_real_approximately_equal () Arguments None private  interface double_precision_approximately_equal () Arguments None generic, public :: skip => default_real_skip , double_precision_skip private  interface default_real_skip () Arguments None private  interface double_precision_skip () Arguments None generic, public :: to_json => default_real_to_json , double_precision_to_json private  interface default_real_to_json () Arguments None private  interface double_precision_to_json () Arguments None procedure, private, non_overridable :: default_real_activation_name interface private elemental module function default_real_activation_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value type(string_t) procedure, private, non_overridable :: default_real_approximately_equal interface private elemental module function default_real_approximately_equal(lhs, rhs) result(lhs_eq_rhs) Implementation → The result is true if lhs and rhs are the same to within a tolerance Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: lhs class( neural_network_t ), intent(in) :: rhs Return Value logical procedure, private, non_overridable :: default_real_assert_conformable_with interface private elemental module subroutine default_real_assert_conformable_with(self, neural_network) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self type( neural_network_t ), intent(in) :: neural_network procedure, private, non_overridable :: default_real_consistency interface private pure module subroutine default_real_consistency(self) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self procedure, private, non_overridable :: default_real_infer interface private elemental module function default_real_infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) procedure, private, non_overridable :: default_real_learn interface private pure module subroutine default_real_learn(self, mini_batches_arr, cost, adam, learning_rate, workspace) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches_arr (:) real, intent(out), optional, allocatable :: cost (:) logical, intent(in) :: adam real, intent(in) :: learning_rate type( workspace_t ), intent(inout) :: workspace procedure, private, non_overridable :: default_real_map_from_output_range interface private elemental module function default_real_map_from_output_range(self, normalized_tensor) result(tensor) Implementation → The result contains the output tensor values unmapped via the inverse of the mapping used in training Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self type( tensor_t ), intent(in) :: normalized_tensor Return Value type( tensor_t ) procedure, private, non_overridable :: default_real_map_to_input_range interface private elemental module function default_real_map_to_input_range(self, tensor) result(normalized_tensor) Implementation → The result contains the input tensor values normalized to fall on the range used during training Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) procedure, private, non_overridable :: default_real_nodes_per_layer interface private pure module function default_real_nodes_per_layer(self) result(node_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value integer, allocatable, (:) procedure, private, non_overridable :: default_real_num_hidden_layers interface private elemental module function default_real_num_hidden_layers(self) result(hidden_layer_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value integer procedure, private, non_overridable :: default_real_num_inputs interface private elemental module function default_real_num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value integer procedure, private, non_overridable :: default_real_num_outputs interface private elemental module function default_real_num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value integer procedure, private, non_overridable :: default_real_skip interface private pure module function default_real_skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value logical procedure, private, non_overridable :: default_real_to_json interface private impure elemental module function default_real_to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value type(file_t) procedure, private, non_overridable :: double_precision_activation_name interface private elemental module function double_precision_activation_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value type(string_t) procedure, private, non_overridable :: double_precision_approximately_equal interface private elemental module function double_precision_approximately_equal(lhs, rhs) result(lhs_eq_rhs) Implementation → The result is true if lhs and rhs are the same to within a tolerance Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: lhs class( neural_network_t (double_precision)), intent(in) :: rhs Return Value logical procedure, private, non_overridable :: double_precision_assert_conformable_with interface private elemental module subroutine double_precision_assert_conformable_with(self, neural_network) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self type( neural_network_t (double_precision)), intent(in) :: neural_network procedure, private, non_overridable :: double_precision_consistency interface private pure module subroutine double_precision_consistency(self) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self procedure, private, non_overridable :: double_precision_infer interface private elemental module function double_precision_infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: inputs Return Value type( tensor_t (double_precision)) procedure, private, non_overridable :: double_precision_map_from_output_range interface private elemental module function double_precision_map_from_output_range(self, normalized_tensor) result(tensor) Implementation → The result contains the output tensor values unmapped via the inverse of the mapping used in training Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: normalized_tensor Return Value type( tensor_t (double_precision)) procedure, private, non_overridable :: double_precision_map_to_input_range interface private elemental module function double_precision_map_to_input_range(self, tensor) result(normalized_tensor) Implementation → The result contains the input tensor values normalized to fall on the range used during training Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: tensor Return Value type( tensor_t (double_precision)) procedure, private, non_overridable :: double_precision_nodes_per_layer interface private pure module function double_precision_nodes_per_layer(self) result(node_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value integer, allocatable, (:) procedure, private, non_overridable :: double_precision_num_hidden_layers interface private elemental module function double_precision_num_hidden_layers(self) result(hidden_layer_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value integer procedure, private, non_overridable :: double_precision_num_inputs interface private elemental module function double_precision_num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value integer procedure, private, non_overridable :: double_precision_num_outputs interface private elemental module function double_precision_num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value integer procedure, private, non_overridable :: double_precision_skip interface private pure module function double_precision_skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value logical procedure, private, non_overridable :: double_precision_to_json interface private impure elemental module function double_precision_to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value type(file_t)","tags":"","loc":"type/neural_network_t.html"},{"title":"unmapped_network_t – Fiats ","text":"type, public :: unmapped_network_t Inherits type~~unmapped_network_t~~InheritsGraph type~unmapped_network_t unmapped_network_t type~neural_network_t neural_network_t type~unmapped_network_t->type~neural_network_t neural_network_ type~activation_t activation_t type~neural_network_t->type~activation_t activation_ type~metadata_t metadata_t type~neural_network_t->type~metadata_t metadata_ type~tensor_map_t tensor_map_t type~neural_network_t->type~tensor_map_t input_map_, output_map_ string_t string_t type~metadata_t->string_t modelName_, modelAuthor_, compilationDate_, activationFunction_, usingSkipConnections_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real type( neural_network_t (k)), private :: neural_network_ Constructor public        interface unmapped_network_t private impure elemental module function double_precision_unmapped_from_json(file) result(unmapped_network) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_file_t ), intent(in) :: file Return Value type( unmapped_network_t (double_precision)) Type-Bound Procedures generic, public :: infer => default_real_infer_unmapped , double_precision_infer_unmapped private  interface default_real_infer_unmapped () Arguments None private  interface double_precision_infer_unmapped () Arguments None procedure, private, non_overridable :: default_real_infer_unmapped interface private elemental module function default_real_infer_unmapped(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( unmapped_network_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) procedure, private, non_overridable :: double_precision_infer_unmapped interface private elemental module function double_precision_infer_unmapped(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( unmapped_network_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: inputs Return Value type( tensor_t (double_precision))","tags":"","loc":"type/unmapped_network_t.html"},{"title":"workspace_t – Fiats ","text":"type, public :: workspace_t Inherited by type~~workspace_t~~InheritedByGraph type~workspace_t workspace_t type~trainable_network_t trainable_network_t type~trainable_network_t->type~workspace_t workspace_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=k), public, allocatable, dimension(:,:) :: a real(kind=k), public, allocatable, dimension(:,:) :: dcdb real(kind=k), public, allocatable, dimension(:,:,:) :: dcdw real(kind=k), public, allocatable, dimension(:,:) :: delta integer, public, kind :: k = default_real real(kind=k), public, allocatable, dimension(:,:) :: sdb real(kind=k), public, allocatable, dimension(:,:) :: sdbc real(kind=k), public, allocatable, dimension(:,:,:) :: sdw real(kind=k), public, allocatable, dimension(:,:,:) :: sdwc real(kind=k), public, allocatable, dimension(:,:) :: vdb real(kind=k), public, allocatable, dimension(:,:) :: vdbc real(kind=k), public, allocatable, dimension(:,:,:) :: vdw real(kind=k), public, allocatable, dimension(:,:,:) :: vdwc real(kind=k), public, allocatable, dimension(:,:) :: z Constructor public        interface workspace_t private pure module function default_real_workspace(neural_network) result(workspace) Implementation → Arguments Type Intent Optional Attributes Name type( neural_network_t ), intent(in) :: neural_network Return Value type( workspace_t ) Type-Bound Procedures generic, public :: allocate_if_necessary => default_real_allocate private  interface default_real_allocate () Arguments None generic, public :: fully_allocated => default_real_allocated private  interface default_real_allocated () Arguments None procedure, private, non_overridable :: default_real_allocate interface private module subroutine default_real_allocate(self, neural_network) Implementation → Arguments Type Intent Optional Attributes Name class( workspace_t ), intent(inout) :: self type( neural_network_t ), intent(in) :: neural_network procedure, private, non_overridable :: default_real_allocated interface private pure module function default_real_allocated(self) result(all_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( workspace_t ), intent(in) :: self Return Value logical","tags":"","loc":"type/workspace_t.html"},{"title":"tensor_map_t – Fiats ","text":"type, public :: tensor_map_t Inherited by type~~tensor_map_t~~InheritedByGraph type~tensor_map_t tensor_map_t type~neural_network_t neural_network_t type~neural_network_t->type~tensor_map_t input_map_, output_map_ type~trainable_network_t trainable_network_t type~trainable_network_t->type~neural_network_t type~unmapped_network_t unmapped_network_t type~unmapped_network_t->type~neural_network_t neural_network_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real real(kind=k), private, dimension(:), allocatable :: intercept_ character(len=:), private, allocatable :: layer_ real(kind=k), private, dimension(:), allocatable :: slope_ Constructor public        interface tensor_map_t private pure module function construct_default_real(layer, minima, maxima) result(tensor_map) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: layer real, intent(in), dimension(:) :: minima real, intent(in), dimension(:) :: maxima Return Value type( tensor_map_t ) private pure module function construct_double_precision(layer, minima, maxima) result(tensor_map) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: layer double precision, intent(in), dimension(:) :: minima double precision, intent(in), dimension(:) :: maxima Return Value type( tensor_map_t (double_precision)) private module function double_precision_from_json(lines) result(tensor_map) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: lines (:) Return Value type( tensor_map_t (double_precision)) private module function from_json(lines) result(tensor_map) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( tensor_map_t ) Type-Bound Procedures generic, public :: map_from_training_range => default_real_map_from_training_range , double_precision_map_from_training_range private  interface default_real_map_from_training_range () Arguments None private  interface double_precision_map_from_training_range () Arguments None generic, public :: map_to_training_range => default_real_map_to_training_range , double_precision_map_to_training_range private  interface default_real_map_to_training_range () Arguments None private  interface double_precision_map_to_training_range () Arguments None generic, public :: operator(==) => default_real_equals , double_precision_equals private  interface default_real_equals () Arguments None private  interface double_precision_equals () Arguments None generic, public :: to_json => default_real_to_json , double_precision_to_json private  interface default_real_to_json () Arguments None private  interface double_precision_to_json () Arguments None procedure, private :: default_real_equals interface private elemental module function default_real_equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t ), intent(in) :: lhs class( tensor_map_t ), intent(in) :: rhs Return Value logical procedure, private, non_overridable :: default_real_map_from_training_range interface private elemental module function default_real_map_from_training_range(self, tensor) result(unnormalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) procedure, private, non_overridable :: default_real_map_to_training_range interface private elemental module function default_real_map_to_training_range(self, tensor) result(normalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) procedure, private :: default_real_to_json interface private pure module function default_real_to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) procedure, private :: double_precision_equals interface private elemental module function double_precision_equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t (double_precision)), intent(in) :: lhs class( tensor_map_t (double_precision)), intent(in) :: rhs Return Value logical procedure, private, non_overridable :: double_precision_map_from_training_range interface private elemental module function double_precision_map_from_training_range(self, tensor) result(unnormalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: tensor Return Value type( tensor_t (double_precision)) procedure, private, non_overridable :: double_precision_map_to_training_range interface private elemental module function double_precision_map_to_training_range(self, tensor) result(normalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: tensor Return Value type( tensor_t (double_precision)) procedure, private :: double_precision_to_json interface private pure module function double_precision_to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t (double_precision)), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"type/tensor_map_t.html"},{"title":"metadata_t – Fiats ","text":"type, public :: metadata_t Inherits type~~metadata_t~~InheritsGraph type~metadata_t metadata_t string_t string_t type~metadata_t->string_t modelName_, modelAuthor_, compilationDate_, activationFunction_, usingSkipConnections_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~metadata_t~~InheritedByGraph type~metadata_t metadata_t type~neural_network_t neural_network_t type~neural_network_t->type~metadata_t metadata_ type~trainable_network_t trainable_network_t type~trainable_network_t->type~neural_network_t type~unmapped_network_t unmapped_network_t type~unmapped_network_t->type~neural_network_t neural_network_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(string_t), private :: activationFunction_ type(string_t), private :: compilationDate_ type(string_t), private :: modelAuthor_ type(string_t), private :: modelName_ type(string_t), private :: usingSkipConnections_ Constructor public        interface metadata_t private pure module function double_precision_from_json(lines) result(metadata) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: lines (:) Return Value type( metadata_t ) private pure module function from_components(modelName, modelAuthor, compilationDate, activationFunction, usingSkipConnections) result(metadata) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: modelName type(string_t), intent(in) :: modelAuthor type(string_t), intent(in) :: compilationDate type(string_t), intent(in) :: activationFunction type(string_t), intent(in) :: usingSkipConnections Return Value type( metadata_t ) private pure module function from_json(lines) result(metadata) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( metadata_t ) Type-Bound Procedures procedure, public :: activation_name interface private pure module function activation_name(self) result(function_name) Implementation → Arguments Type Intent Optional Attributes Name class( metadata_t ), intent(in) :: self Return Value type(string_t) generic, public :: operator(==) => equals private  interface equals () Arguments None procedure, public :: strings interface private pure module function strings(self) result(components) Implementation → Arguments Type Intent Optional Attributes Name class( metadata_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) procedure, public :: to_json interface private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( metadata_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) procedure, private :: equals interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( metadata_t ), intent(in) :: lhs class( metadata_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"type/metadata_t.html"},{"title":"identity_network – Fiats","text":"function identity_network() result(neural_network) Arguments None Return Value type( neural_network_t ) Calls proc~~identity_network~~CallsGraph proc~identity_network identity_network string_t string_t proc~identity_network->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~identity_network~~CalledByGraph proc~identity_network identity_network proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->proc~identity_network program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/identity_network.html"},{"title":"write_read_query_infer – Fiats","text":"subroutine write_read_query_infer(output_file_name) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: output_file_name Calls proc~~write_read_query_infer~~CallsGraph proc~write_read_query_infer write_read_query_infer file_t file_t proc~write_read_query_infer->file_t none~activation_function_name neural_network_t%activation_function_name proc~write_read_query_infer->none~activation_function_name none~infer neural_network_t%infer proc~write_read_query_infer->none~infer none~nodes_per_layer~5 neural_network_t%nodes_per_layer proc~write_read_query_infer->none~nodes_per_layer~5 none~num_inputs~6 neural_network_t%num_inputs proc~write_read_query_infer->none~num_inputs~6 none~num_outputs neural_network_t%num_outputs proc~write_read_query_infer->none~num_outputs none~to_json~5 neural_network_t%to_json proc~write_read_query_infer->none~to_json~5 none~values tensor_t%values proc~write_read_query_infer->none~values proc~identity_network identity_network proc~write_read_query_infer->proc~identity_network string string proc~write_read_query_infer->string write_lines write_lines proc~write_read_query_infer->write_lines interface~default_real_activation_name neural_network_t%default_real_activation_name none~activation_function_name->interface~default_real_activation_name interface~double_precision_activation_name neural_network_t%double_precision_activation_name none~activation_function_name->interface~double_precision_activation_name interface~default_real_infer neural_network_t%default_real_infer none~infer->interface~default_real_infer interface~double_precision_infer neural_network_t%double_precision_infer none~infer->interface~double_precision_infer interface~default_real_nodes_per_layer~2 neural_network_t%default_real_nodes_per_layer none~nodes_per_layer~5->interface~default_real_nodes_per_layer~2 interface~double_precision_nodes_per_layer~2 neural_network_t%double_precision_nodes_per_layer none~nodes_per_layer~5->interface~double_precision_nodes_per_layer~2 interface~default_real_num_inputs~2 neural_network_t%default_real_num_inputs none~num_inputs~6->interface~default_real_num_inputs~2 interface~double_precision_num_inputs~2 neural_network_t%double_precision_num_inputs none~num_inputs~6->interface~double_precision_num_inputs~2 interface~default_real_num_outputs neural_network_t%default_real_num_outputs none~num_outputs->interface~default_real_num_outputs interface~double_precision_num_outputs neural_network_t%double_precision_num_outputs none~num_outputs->interface~double_precision_num_outputs interface~default_real_to_json~4 neural_network_t%default_real_to_json none~to_json~5->interface~default_real_to_json~4 interface~double_precision_to_json~4 neural_network_t%double_precision_to_json none~to_json~5->interface~double_precision_to_json~4 interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values string_t string_t proc~identity_network->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_read_query_infer~~CalledByGraph proc~write_read_query_infer write_read_query_infer program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_read_query_infer ( output_file_name ) type ( string_t ), intent ( in ) :: output_file_name type ( string_t ) activation_name integer i , j integer , parameter :: num_neurons = 3 , num_hidden_layers = 2 type ( neural_network_t ) network , neural_network type ( file_t ) json_output_file , json_input_file type ( tensor_t ) inputs , outputs print * , \"Constructing an neural_network_t neural-network object from scratch.\" network = identity_network () print * , \"Converting an neural_network_t object to a file_t object.\" json_output_file = network % to_json () print * , \"Writing an neural_network_t object to the file '\" // output_file_name % string () // \"' in JSON format.\" call json_output_file % write_lines ( output_file_name ) print * , \"Reading an neural_network_t object from the same JSON file '\" // output_file_name % string () // \"'.\" json_input_file = file_t ( output_file_name ) print * , \"Constructing a new neural_network_t object from the parameters read.\" neural_network = neural_network_t ( json_input_file ) print * , \"Querying the new neural_network_t object for several properties:\" print * , \"Number of outputs:\" , neural_network % num_outputs () print * , \"Number of inputs:\" , neural_network % num_inputs () print * , \"Nodes per layer:\" , neural_network % nodes_per_layer () activation_name = neural_network % activation_function_name () print * , \"Activation function: \" , activation_name % string () print * , \"Performing inference:\" inputs = tensor_t ([ 2. , 3. ]) print * , \"Inputs: \" , inputs % values () outputs = neural_network % infer ( inputs ) print * , \"Actual outputs: \" , outputs % values () print * , \"Correct outputs:  \" , inputs % values () end subroutine write_read_query_infer","tags":"","loc":"proc/write_read_query_infer.html"},{"title":"trainable_network_t – Fiats","text":"public interface trainable_network_t Functions private pure module function default_real_network(neural_network) result(trainable_network) Implementation → Arguments Type Intent Optional Attributes Name type( neural_network_t ), intent(in) :: neural_network Return Value type( trainable_network_t ) private module function perturbed_identity_network(training_configuration, perturbation_magnitude, metadata, input_map, output_map) result(trainable_network) Implementation → Arguments Type Intent Optional Attributes Name type( training_configuration_t ), intent(in) :: training_configuration real, intent(in) :: perturbation_magnitude type(string_t), intent(in) :: metadata (:) type( tensor_map_t ) :: input_map type( tensor_map_t ) :: output_map Return Value type( trainable_network_t )","tags":"","loc":"interface/trainable_network_t.html"},{"title":"default_real_map_to_training_ranges – Fiats","text":"interface private elemental module function default_real_map_to_training_ranges(self, input_output_pair) result(normalized_input_output_pair) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_network_t ), intent(in) :: self type( input_output_pair_t ), intent(in) :: input_output_pair Return Value type( input_output_pair_t )","tags":"","loc":"interface/default_real_map_to_training_ranges.html"},{"title":"default_real_train – Fiats","text":"interface private pure module subroutine default_real_train(self, mini_batches_arr, cost, adam, learning_rate) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_network_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches_arr (:) real, intent(out), optional, allocatable :: cost (:) logical, intent(in) :: adam real, intent(in) :: learning_rate","tags":"","loc":"interface/default_real_train.html"},{"title":"training_configuration_t – Fiats","text":"public interface training_configuration_t Functions private module function default_real_from_components(hyperparameters, network_configuration) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type( hyperparameters_t ), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t ) private module function default_real_from_file(file_object) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_object Return Value type( training_configuration_t ) private module function double_precision_from_components(hyperparameters, network_configuration) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type( hyperparameters_t (double_precision)), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t (double_precision)) private module function double_precision_from_file(file_object) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_file_t ), intent(in) :: file_object Return Value type( training_configuration_t (double_precision))","tags":"","loc":"interface/training_configuration_t.html"},{"title":"default_real_differentiable_activation – Fiats","text":"interface private module function default_real_differentiable_activation(self) result(activation) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type( activation_t )","tags":"","loc":"interface/default_real_differentiable_activation.html"},{"title":"default_real_equals – Fiats","text":"interface private elemental module function default_real_equals(lhs, rhs) result(lhs_eq_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: lhs class( training_configuration_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/default_real_equals.html"},{"title":"default_real_learning_rate – Fiats","text":"interface private elemental module function default_real_learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value real","tags":"","loc":"interface/default_real_learning_rate.html"},{"title":"default_real_mini_batches – Fiats","text":"interface private elemental module function default_real_mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/default_real_mini_batches.html"},{"title":"default_real_nodes_per_layer – Fiats","text":"interface Called by interface~~default_real_nodes_per_layer~~CalledByGraph interface~default_real_nodes_per_layer training_configuration_t%default_real_nodes_per_layer none~nodes_per_layer~2 training_configuration_t%nodes_per_layer none~nodes_per_layer~2->interface~default_real_nodes_per_layer proc~perturbed_identity_network~5 perturbed_identity_network proc~perturbed_identity_network~5->none~nodes_per_layer~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function default_real_nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer,allocatable,(:)","tags":"","loc":"interface/default_real_nodes_per_layer.html"},{"title":"default_real_optimizer_name – Fiats","text":"interface private elemental module function default_real_optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/default_real_optimizer_name.html"},{"title":"default_real_skip_connections – Fiats","text":"interface private elemental module function default_real_skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/default_real_skip_connections.html"},{"title":"default_real_to_json – Fiats","text":"interface Called by interface~~default_real_to_json~~CalledByGraph interface~default_real_to_json training_configuration_t%default_real_to_json none~to_json training_configuration_t%to_json none~to_json->interface~default_real_to_json program~print_training_configuration print_training_configuration program~print_training_configuration->none~to_json Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function default_real_to_json(self) result(json_lines) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/default_real_to_json.html"},{"title":"double_precision_differentiable_activation – Fiats","text":"interface private module function double_precision_differentiable_activation(self) result(activation) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value type( activation_t )","tags":"","loc":"interface/double_precision_differentiable_activation.html"},{"title":"double_precision_equals – Fiats","text":"interface private elemental module function double_precision_equals(lhs, rhs) result(lhs_eq_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: lhs class( training_configuration_t (double_precision)), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/double_precision_equals.html"},{"title":"double_precision_learning_rate – Fiats","text":"interface private elemental module function double_precision_learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value double precision","tags":"","loc":"interface/double_precision_learning_rate.html"},{"title":"double_precision_mini_batches – Fiats","text":"interface private elemental module function double_precision_mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value integer","tags":"","loc":"interface/double_precision_mini_batches.html"},{"title":"double_precision_nodes_per_layer – Fiats","text":"interface Called by interface~~double_precision_nodes_per_layer~~CalledByGraph interface~double_precision_nodes_per_layer training_configuration_t%double_precision_nodes_per_layer none~nodes_per_layer~2 training_configuration_t%nodes_per_layer none~nodes_per_layer~2->interface~double_precision_nodes_per_layer proc~perturbed_identity_network~5 perturbed_identity_network proc~perturbed_identity_network~5->none~nodes_per_layer~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function double_precision_nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value integer,allocatable,(:)","tags":"","loc":"interface/double_precision_nodes_per_layer.html"},{"title":"double_precision_optimizer_name – Fiats","text":"interface private elemental module function double_precision_optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/double_precision_optimizer_name.html"},{"title":"double_precision_skip_connections – Fiats","text":"interface private elemental module function double_precision_skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value logical","tags":"","loc":"interface/double_precision_skip_connections.html"},{"title":"double_precision_to_json – Fiats","text":"interface Called by interface~~double_precision_to_json~~CalledByGraph interface~double_precision_to_json training_configuration_t%double_precision_to_json none~to_json training_configuration_t%to_json none~to_json->interface~double_precision_to_json program~print_training_configuration print_training_configuration program~print_training_configuration->none~to_json Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function double_precision_to_json(self) result(json_lines) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/double_precision_to_json.html"},{"title":"network_configuration_t – Fiats","text":"public interface network_configuration_t Functions private pure module function from_components(skip_connections, nodes_per_layer, activation_name) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name logical, intent(in) :: skip_connections integer, intent(in) :: nodes_per_layer (:) character(len=*), intent(in) :: activation_name Return Value type( network_configuration_t ) private pure module function from_double_precision_string_json(lines) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: lines (:) Return Value type( network_configuration_t ) private pure module function from_json(lines) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( network_configuration_t )","tags":"","loc":"interface/network_configuration_t.html"},{"title":"activation_name – Fiats","text":"interface Called by interface~~activation_name~~CalledByGraph interface~activation_name network_configuration_t%activation_name proc~default_real_differentiable_activation default_real_differentiable_activation proc~default_real_differentiable_activation->interface~activation_name proc~double_precision_differentiable_activation double_precision_differentiable_activation proc~double_precision_differentiable_activation->interface~activation_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function activation_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/activation_name.html"},{"title":"equals – Fiats","text":"interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: lhs class( network_configuration_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/equals.html"},{"title":"nodes_per_layer – Fiats","text":"interface Called by interface~~nodes_per_layer~~CalledByGraph interface~nodes_per_layer network_configuration_t%nodes_per_layer proc~default_real_nodes_per_layer~2 default_real_nodes_per_layer proc~default_real_nodes_per_layer~2->interface~nodes_per_layer proc~double_precision_nodes_per_layer~2 double_precision_nodes_per_layer proc~double_precision_nodes_per_layer~2->interface~nodes_per_layer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value integer,allocatable,(:)","tags":"","loc":"interface/nodes_per_layer.html"},{"title":"skip_connections – Fiats","text":"interface Called by interface~~skip_connections~~CalledByGraph interface~skip_connections network_configuration_t%skip_connections proc~default_real_skip_connections default_real_skip_connections proc~default_real_skip_connections->interface~skip_connections proc~double_precision_skip_connections double_precision_skip_connections proc~double_precision_skip_connections->interface~skip_connections Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/skip_connections.html"},{"title":"to_json – Fiats","text":"interface private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/to_json.html"},{"title":"y – Fiats","text":"public elemental function y(x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t ) Calls proc~~y~~CallsGraph proc~y y assert assert proc~y->assert none~values tensor_t%values proc~y->none~values interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~y~~CalledByGraph proc~y y program~learn_multiplication learn_multiplication program~learn_multiplication->proc~y Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/y.html"},{"title":"e – Fiats","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) Called by proc~~e~~CalledByGraph proc~e e proc~perturbed_identity_network perturbed_identity_network proc~perturbed_identity_network->proc~e program~learn_multiplication learn_multiplication program~learn_multiplication->proc~perturbed_identity_network Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/e.html"},{"title":"perturbed_identity_network – Fiats","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_network) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_network_t ) Calls proc~~perturbed_identity_network~~CallsGraph proc~perturbed_identity_network perturbed_identity_network proc~e e proc~perturbed_identity_network->proc~e string_t string_t proc~perturbed_identity_network->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~perturbed_identity_network~~CalledByGraph proc~perturbed_identity_network perturbed_identity_network program~learn_multiplication learn_multiplication program~learn_multiplication->proc~perturbed_identity_network Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network.html"},{"title":"output – Fiats","text":"subroutine output(neural_network, file_name) Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: neural_network type(string_t), intent(in) :: file_name Calls proc~~output~~CallsGraph proc~output output none~to_json~5 neural_network_t%to_json proc~output->none~to_json~5 write_lines write_lines proc~output->write_lines interface~default_real_to_json~4 neural_network_t%default_real_to_json none~to_json~5->interface~default_real_to_json~4 interface~double_precision_to_json~4 neural_network_t%double_precision_to_json none~to_json~5->interface~double_precision_to_json~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~output~~CalledByGraph proc~output output program~learn_multiplication learn_multiplication program~learn_multiplication->proc~output Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/output.html"},{"title":"activation_t – Fiats","text":"public interface activation_t Functions private elemental module function construct_from_component(selection) result(activation) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: selection Return Value type( activation_t ) private elemental module function construct_from_name(name) result(activation) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value type( activation_t )","tags":"","loc":"interface/activation_t.html"},{"title":"default_real_differentiate – Fiats","text":"interface Called by interface~~default_real_differentiate~~CalledByGraph interface~default_real_differentiate activation_t%default_real_differentiate none~differentiate activation_t%differentiate none~differentiate->interface~default_real_differentiate proc~default_real_learn default_real_learn proc~default_real_learn->none~differentiate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function default_real_differentiate(self, x) result(dy_dx) Implementation → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self real, intent(in) :: x Return Value real","tags":"","loc":"interface/default_real_differentiate.html"},{"title":"default_real_evaluate – Fiats","text":"interface Called by interface~~default_real_evaluate~~CalledByGraph interface~default_real_evaluate activation_t%default_real_evaluate none~evaluate activation_t%evaluate none~evaluate->interface~default_real_evaluate proc~default_real_infer default_real_infer proc~default_real_infer->none~evaluate proc~default_real_infer_unmapped default_real_infer_unmapped proc~default_real_infer_unmapped->none~evaluate proc~default_real_learn default_real_learn proc~default_real_learn->none~evaluate proc~double_precision_infer double_precision_infer proc~double_precision_infer->none~evaluate proc~double_precision_infer_unmapped double_precision_infer_unmapped proc~double_precision_infer_unmapped->none~evaluate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function default_real_evaluate(self, x) result(y) Implementation → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self real, intent(in) :: x Return Value real","tags":"","loc":"interface/default_real_evaluate.html"},{"title":"double_precision_differentiate – Fiats","text":"interface Called by interface~~double_precision_differentiate~~CalledByGraph interface~double_precision_differentiate activation_t%double_precision_differentiate none~differentiate activation_t%differentiate none~differentiate->interface~double_precision_differentiate proc~default_real_learn default_real_learn proc~default_real_learn->none~differentiate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function double_precision_differentiate(self, x) result(dy_dx) Implementation → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self double precision, intent(in) :: x Return Value double precision","tags":"","loc":"interface/double_precision_differentiate.html"},{"title":"double_precision_evaluate – Fiats","text":"interface Called by interface~~double_precision_evaluate~~CalledByGraph interface~double_precision_evaluate activation_t%double_precision_evaluate none~evaluate activation_t%evaluate none~evaluate->interface~double_precision_evaluate proc~default_real_infer default_real_infer proc~default_real_infer->none~evaluate proc~default_real_infer_unmapped default_real_infer_unmapped proc~default_real_infer_unmapped->none~evaluate proc~default_real_learn default_real_learn proc~default_real_learn->none~evaluate proc~double_precision_infer double_precision_infer proc~double_precision_infer->none~evaluate proc~double_precision_infer_unmapped double_precision_infer_unmapped proc~double_precision_infer_unmapped->none~evaluate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function double_precision_evaluate(self, x) result(y) Implementation → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self double precision, intent(in) :: x Return Value double precision","tags":"","loc":"interface/double_precision_evaluate.html"},{"title":"equals – Fiats","text":"interface private elemental module function equals(self, rhs) result(self_eq_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self type( activation_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/equals~2.html"},{"title":"function_name – Fiats","text":"interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/function_name.html"},{"title":"double_precision_string_t – Fiats","text":"public interface double_precision_string_t Functions public elemental module function construct_from_string(string) result(double_precision_string) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: string Return Value type( double_precision_string_t )","tags":"","loc":"interface/double_precision_string_t.html"},{"title":"y – Fiats","text":"public elemental function y(x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t ) Calls proc~~y~2~~CallsGraph proc~y~2 y assert assert proc~y~2->assert none~values tensor_t%values proc~y~2->none~values interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~y~2~~CalledByGraph proc~y~2 y program~learn_addition learn_addition program~learn_addition->proc~y~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/y~2.html"},{"title":"e – Fiats","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) Called by proc~~e~2~~CalledByGraph proc~e~2 e proc~perturbed_identity_network~2 perturbed_identity_network proc~perturbed_identity_network~2->proc~e~2 program~learn_addition learn_addition program~learn_addition->proc~perturbed_identity_network~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/e~2.html"},{"title":"perturbed_identity_network – Fiats","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_network) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_network_t ) Calls proc~~perturbed_identity_network~2~~CallsGraph proc~perturbed_identity_network~2 perturbed_identity_network proc~e~2 e proc~perturbed_identity_network~2->proc~e~2 string_t string_t proc~perturbed_identity_network~2->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~perturbed_identity_network~2~~CalledByGraph proc~perturbed_identity_network~2 perturbed_identity_network program~learn_addition learn_addition program~learn_addition->proc~perturbed_identity_network~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network~2.html"},{"title":"output – Fiats","text":"subroutine output(neural_network, file_name) Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: neural_network type(string_t), intent(in) :: file_name Calls proc~~output~2~~CallsGraph proc~output~2 output none~to_json~5 neural_network_t%to_json proc~output~2->none~to_json~5 write_lines write_lines proc~output~2->write_lines interface~default_real_to_json~4 neural_network_t%default_real_to_json none~to_json~5->interface~default_real_to_json~4 interface~double_precision_to_json~4 neural_network_t%double_precision_to_json none~to_json~5->interface~double_precision_to_json~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~output~2~~CalledByGraph proc~output~2 output program~learn_addition learn_addition program~learn_addition->proc~output~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/output~2.html"},{"title":"input_output_pair_t – Fiats","text":"public interface input_output_pair_t Functions private elemental module function default_real_construct(inputs, expected_outputs) result(input_output_pair) Implementation → Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t ) private elemental module function double_precision_construct(inputs, expected_outputs) result(input_output_pair) Implementation → Arguments Type Intent Optional Attributes Name type( tensor_t (double_precision)), intent(in) :: inputs type( tensor_t (double_precision)), intent(in) :: expected_outputs Return Value type( input_output_pair_t (double_precision))","tags":"","loc":"interface/input_output_pair_t.html"},{"title":"shuffle – Fiats","text":"public interface shuffle Called by interface~~shuffle~~CalledByGraph interface~shuffle shuffle program~learn_addition learn_addition program~learn_addition->interface~shuffle program~learn_exponentiation learn_exponentiation program~learn_exponentiation->interface~shuffle program~learn_multiplication learn_multiplication program~learn_multiplication->interface~shuffle program~learn_power_series learn_power_series program~learn_power_series->interface~shuffle program~train_and_write train_and_write program~train_and_write->interface~shuffle program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->interface~shuffle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines private module subroutine default_real_shuffle(pairs) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(inout) :: pairs (:) private module subroutine double_precision_shuffle(pairs) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t (double_precision)), intent(inout) :: pairs (:)","tags":"","loc":"interface/shuffle.html"},{"title":"write_to_stdout – Fiats","text":"public interface write_to_stdout Subroutines private module subroutine default_real_write_to_stdout(input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) private module subroutine double_precision_write_to_stdout(input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t (double_precision)), intent(in) :: input_output_pairs (:)","tags":"","loc":"interface/write_to_stdout.html"},{"title":"default_real_expected_outputs – Fiats","text":"interface Called by interface~~default_real_expected_outputs~~CalledByGraph interface~default_real_expected_outputs input_output_pair_t%default_real_expected_outputs none~expected_outputs~2 input_output_pair_t%expected_outputs none~expected_outputs~2->interface~default_real_expected_outputs proc~default_real_map_to_training_ranges default_real_map_to_training_ranges proc~default_real_map_to_training_ranges->none~expected_outputs~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function default_real_expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"interface/default_real_expected_outputs.html"},{"title":"default_real_inputs – Fiats","text":"interface Called by interface~~default_real_inputs~~CalledByGraph interface~default_real_inputs input_output_pair_t%default_real_inputs none~inputs~3 input_output_pair_t%inputs none~inputs~3->interface~default_real_inputs proc~default_real_map_to_training_ranges default_real_map_to_training_ranges proc~default_real_map_to_training_ranges->none~inputs~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function default_real_inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"interface/default_real_inputs.html"},{"title":"double_precision_expected_outputs – Fiats","text":"interface Called by interface~~double_precision_expected_outputs~~CalledByGraph interface~double_precision_expected_outputs input_output_pair_t%double_precision_expected_outputs none~expected_outputs~2 input_output_pair_t%expected_outputs none~expected_outputs~2->interface~double_precision_expected_outputs proc~default_real_map_to_training_ranges default_real_map_to_training_ranges proc~default_real_map_to_training_ranges->none~expected_outputs~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function double_precision_expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t (double_precision)), intent(in) :: self Return Value type( tensor_t double_precision)","tags":"","loc":"interface/double_precision_expected_outputs.html"},{"title":"double_precision_inputs – Fiats","text":"interface Called by interface~~double_precision_inputs~~CalledByGraph interface~double_precision_inputs input_output_pair_t%double_precision_inputs none~inputs~3 input_output_pair_t%inputs none~inputs~3->interface~double_precision_inputs proc~default_real_map_to_training_ranges default_real_map_to_training_ranges proc~default_real_map_to_training_ranges->none~inputs~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function double_precision_inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t (double_precision)), intent(in) :: self Return Value type( tensor_t double_precision)","tags":"","loc":"interface/double_precision_inputs.html"},{"title":"double_precision_file_t – Fiats","text":"public interface double_precision_file_t Functions public impure elemental module function construct_from_character(file_name) result(double_precision_file) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value type( double_precision_file_t ) public impure elemental module function construct_from_string(file_name) result(double_precision_file) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: file_name Return Value type( double_precision_file_t )","tags":"","loc":"interface/double_precision_file_t.html"},{"title":"double_precision_lines – Fiats","text":"interface Called by interface~~double_precision_lines~~CalledByGraph interface~double_precision_lines double_precision_file_t%double_precision_lines proc~double_precision_from_file double_precision_from_file proc~double_precision_from_file->interface~double_precision_lines proc~double_precision_from_json double_precision_from_json proc~double_precision_from_json->interface~double_precision_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public pure module function double_precision_lines(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( double_precision_file_t ), intent(in) :: self Return Value type( double_precision_string_t ),allocatable,(:)","tags":"","loc":"interface/double_precision_lines.html"},{"title":"y – Fiats","text":"public elemental function y(x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t ) Calls proc~~y~3~~CallsGraph proc~y~3 y assert assert proc~y~3->assert none~values tensor_t%values proc~y~3->none~values interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~y~3~~CalledByGraph proc~y~3 y program~learn_power_series learn_power_series program~learn_power_series->proc~y~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/y~3.html"},{"title":"e – Fiats","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) Called by proc~~e~3~~CalledByGraph proc~e~3 e proc~perturbed_identity_network~3 perturbed_identity_network proc~perturbed_identity_network~3->proc~e~3 program~learn_power_series learn_power_series program~learn_power_series->proc~perturbed_identity_network~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/e~3.html"},{"title":"perturbed_identity_network – Fiats","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_network) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_network_t ) Calls proc~~perturbed_identity_network~3~~CallsGraph proc~perturbed_identity_network~3 perturbed_identity_network proc~e~3 e proc~perturbed_identity_network~3->proc~e~3 string_t string_t proc~perturbed_identity_network~3->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~perturbed_identity_network~3~~CalledByGraph proc~perturbed_identity_network~3 perturbed_identity_network program~learn_power_series learn_power_series program~learn_power_series->proc~perturbed_identity_network~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network~3.html"},{"title":"output – Fiats","text":"subroutine output(neural_network, file_name) Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: neural_network type(string_t), intent(in) :: file_name Calls proc~~output~3~~CallsGraph proc~output~3 output none~to_json~5 neural_network_t%to_json proc~output~3->none~to_json~5 write_lines write_lines proc~output~3->write_lines interface~default_real_to_json~4 neural_network_t%default_real_to_json none~to_json~5->interface~default_real_to_json~4 interface~double_precision_to_json~4 neural_network_t%double_precision_to_json none~to_json~5->interface~double_precision_to_json~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~output~3~~CalledByGraph proc~output~3 output program~learn_power_series learn_power_series program~learn_power_series->proc~output~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/output~3.html"},{"title":"equals – Fiats","text":"public elemental function equals(lhs, rhs) result(lhs_equals_rhs) Type Bound ubounds_t Arguments Type Intent Optional Attributes Name class( ubounds_t ), intent(in) :: lhs class( ubounds_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"proc/equals.html"},{"title":"hyperparameters_t – Fiats","text":"public interface hyperparameters_t Functions private pure module function default_real_from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches real, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t ) private pure module function default_real_from_json(lines) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( hyperparameters_t ) private pure module function double_precision_from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches double precision, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t (double_precision)) private pure module function double_precision_from_json(lines) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: lines (:) Return Value type( hyperparameters_t (double_precision))","tags":"","loc":"interface/hyperparameters_t.html"},{"title":"default_real_equals – Fiats","text":"interface private elemental module function default_real_equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: lhs class( hyperparameters_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/default_real_equals~2.html"},{"title":"default_real_learning_rate – Fiats","text":"interface Called by interface~~default_real_learning_rate~2~~CalledByGraph interface~default_real_learning_rate~2 hyperparameters_t%default_real_learning_rate none~learning_rate~3 hyperparameters_t%learning_rate none~learning_rate~3->interface~default_real_learning_rate~2 proc~default_real_learning_rate~2 default_real_learning_rate proc~default_real_learning_rate~2->none~learning_rate~3 proc~double_precision_learning_rate~2 double_precision_learning_rate proc~double_precision_learning_rate~2->none~learning_rate~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function default_real_learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value real","tags":"","loc":"interface/default_real_learning_rate~2.html"},{"title":"default_real_mini_batches – Fiats","text":"interface Called by interface~~default_real_mini_batches~2~~CalledByGraph interface~default_real_mini_batches~2 hyperparameters_t%default_real_mini_batches none~mini_batches~2 hyperparameters_t%mini_batches none~mini_batches~2->interface~default_real_mini_batches~2 proc~default_real_mini_batches~2 default_real_mini_batches proc~default_real_mini_batches~2->none~mini_batches~2 proc~double_precision_mini_batches~2 double_precision_mini_batches proc~double_precision_mini_batches~2->none~mini_batches~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function default_real_mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/default_real_mini_batches~2.html"},{"title":"default_real_optimizer_name – Fiats","text":"interface Called by interface~~default_real_optimizer_name~2~~CalledByGraph interface~default_real_optimizer_name~2 hyperparameters_t%default_real_optimizer_name none~optimizer_name~2 hyperparameters_t%optimizer_name none~optimizer_name~2->interface~default_real_optimizer_name~2 proc~default_real_optimizer_name~2 default_real_optimizer_name proc~default_real_optimizer_name~2->none~optimizer_name~2 proc~double_precision_optimizer_name~2 double_precision_optimizer_name proc~double_precision_optimizer_name~2->none~optimizer_name~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function default_real_optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/default_real_optimizer_name~2.html"},{"title":"default_real_to_json – Fiats","text":"interface Called by interface~~default_real_to_json~2~~CalledByGraph interface~default_real_to_json~2 hyperparameters_t%default_real_to_json none~to_json~3 hyperparameters_t%to_json none~to_json~3->interface~default_real_to_json~2 proc~default_real_from_components~2 default_real_from_components proc~default_real_from_components~2->none~to_json~3 proc~double_precision_from_components~2 double_precision_from_components proc~double_precision_from_components~2->none~to_json~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function default_real_to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/default_real_to_json~2.html"},{"title":"double_precision_equals – Fiats","text":"interface private elemental module function double_precision_equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: lhs class( hyperparameters_t (double_precision)), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/double_precision_equals~2.html"},{"title":"double_precision_learning_rate – Fiats","text":"interface Called by interface~~double_precision_learning_rate~2~~CalledByGraph interface~double_precision_learning_rate~2 hyperparameters_t%double_precision_learning_rate none~learning_rate~3 hyperparameters_t%learning_rate none~learning_rate~3->interface~double_precision_learning_rate~2 proc~default_real_learning_rate~2 default_real_learning_rate proc~default_real_learning_rate~2->none~learning_rate~3 proc~double_precision_learning_rate~2 double_precision_learning_rate proc~double_precision_learning_rate~2->none~learning_rate~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function double_precision_learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: self Return Value double precision","tags":"","loc":"interface/double_precision_learning_rate~2.html"},{"title":"double_precision_mini_batches – Fiats","text":"interface Called by interface~~double_precision_mini_batches~2~~CalledByGraph interface~double_precision_mini_batches~2 hyperparameters_t%double_precision_mini_batches none~mini_batches~2 hyperparameters_t%mini_batches none~mini_batches~2->interface~double_precision_mini_batches~2 proc~default_real_mini_batches~2 default_real_mini_batches proc~default_real_mini_batches~2->none~mini_batches~2 proc~double_precision_mini_batches~2 double_precision_mini_batches proc~double_precision_mini_batches~2->none~mini_batches~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function double_precision_mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: self Return Value integer","tags":"","loc":"interface/double_precision_mini_batches~2.html"},{"title":"double_precision_optimizer_name – Fiats","text":"interface Called by interface~~double_precision_optimizer_name~2~~CalledByGraph interface~double_precision_optimizer_name~2 hyperparameters_t%double_precision_optimizer_name none~optimizer_name~2 hyperparameters_t%optimizer_name none~optimizer_name~2->interface~double_precision_optimizer_name~2 proc~default_real_optimizer_name~2 default_real_optimizer_name proc~default_real_optimizer_name~2->none~optimizer_name~2 proc~double_precision_optimizer_name~2 double_precision_optimizer_name proc~double_precision_optimizer_name~2->none~optimizer_name~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function double_precision_optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/double_precision_optimizer_name~2.html"},{"title":"double_precision_to_json – Fiats","text":"interface Called by interface~~double_precision_to_json~2~~CalledByGraph interface~double_precision_to_json~2 hyperparameters_t%double_precision_to_json none~to_json~3 hyperparameters_t%to_json none~to_json~3->interface~double_precision_to_json~2 proc~default_real_from_components~2 default_real_from_components proc~default_real_from_components~2->none~to_json~3 proc~double_precision_from_components~2 double_precision_from_components proc~double_precision_from_components~2->none~to_json~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function double_precision_to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/double_precision_to_json~2.html"},{"title":"e – Fiats","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) Called by proc~~e~4~~CalledByGraph proc~e~4 e proc~perturbed_identity_network~4 perturbed_identity_network proc~perturbed_identity_network~4->proc~e~4 program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~perturbed_identity_network~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/e~4.html"},{"title":"perturbed_identity_network – Fiats","text":"function perturbed_identity_network(perturbation_magnitude, n) result(trainable_network) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude integer, intent(in) :: n (:) Return Value type( trainable_network_t ) Calls proc~~perturbed_identity_network~4~~CallsGraph proc~perturbed_identity_network~4 perturbed_identity_network proc~e~4 e proc~perturbed_identity_network~4->proc~e~4 string_t string_t proc~perturbed_identity_network~4->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~perturbed_identity_network~4~~CalledByGraph proc~perturbed_identity_network~4 perturbed_identity_network program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~perturbed_identity_network~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network~4.html"},{"title":"open_plot_file_for_appending – Fiats","text":"subroutine open_plot_file_for_appending(plot_file_name, plot_unit, previous_epoch, previous_clock) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: plot_file_name integer, intent(out) :: plot_unit integer, intent(out) :: previous_epoch real, intent(out) :: previous_clock Calls proc~~open_plot_file_for_appending~~CallsGraph proc~open_plot_file_for_appending open_plot_file_for_appending file_t file_t proc~open_plot_file_for_appending->file_t lines lines proc~open_plot_file_for_appending->lines string string proc~open_plot_file_for_appending->string string_t string_t proc~open_plot_file_for_appending->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~open_plot_file_for_appending~~CalledByGraph proc~open_plot_file_for_appending open_plot_file_for_appending program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~open_plot_file_for_appending Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/open_plot_file_for_appending.html"},{"title":"output – Fiats","text":"subroutine output(neural_network, file_name) Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: neural_network type(string_t), intent(in) :: file_name Calls proc~~output~4~~CallsGraph proc~output~4 output none~to_json~5 neural_network_t%to_json proc~output~4->none~to_json~5 write_lines write_lines proc~output~4->write_lines interface~default_real_to_json~4 neural_network_t%default_real_to_json none~to_json~5->interface~default_real_to_json~4 interface~double_precision_to_json~4 neural_network_t%double_precision_to_json none~to_json~5->interface~double_precision_to_json~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~output~4~~CalledByGraph proc~output~4 output program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~output~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/output~4.html"},{"title":"print_diagnostics – Fiats","text":"subroutine print_diagnostics(plot_file_unit, epoch, cost, clock, nodes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: plot_file_unit integer, intent(in) :: epoch real, intent(in) :: cost real, intent(in) :: clock integer, intent(in) :: nodes (:) Called by proc~~print_diagnostics~~CalledByGraph proc~print_diagnostics print_diagnostics program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~print_diagnostics Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/print_diagnostics.html"},{"title":"y – Fiats","text":"public elemental function y(x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t ) Calls proc~~y~4~~CallsGraph proc~y~4 y assert assert proc~y~4->assert none~values tensor_t%values proc~y~4->none~values proc~saturated_mixing_ratio saturated_mixing_ratio proc~y~4->proc~saturated_mixing_ratio interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~y~4~~CalledByGraph proc~y~4 y program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~y~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/y~4.html"},{"title":"saturated_mixing_ratio – Fiats","text":"private pure function saturated_mixing_ratio(T_normalized, p_normalized) result(sat_mr) Calculate the saturated mixing ratio for normalized tempetatures (k) and pressures (Pa) Arguments Type Intent Optional Attributes Name real, intent(in) :: T_normalized real, intent(in) :: p_normalized Return Value real Called by proc~~saturated_mixing_ratio~~CalledByGraph proc~saturated_mixing_ratio saturated_mixing_ratio proc~y~4 y proc~y~4->proc~saturated_mixing_ratio program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~y~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/saturated_mixing_ratio.html"},{"title":"tensor_t – Fiats","text":"public interface tensor_t Functions private pure module function construct_default_real(values) result(tensor) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: values (:) Return Value type( tensor_t ) private pure module function construct_double_precision(values) result(tensor) Implementation → Arguments Type Intent Optional Attributes Name double precision, intent(in) :: values (:) Return Value type( tensor_t (double_precision))","tags":"","loc":"interface/tensor_t.html"},{"title":"default_real_num_components – Fiats","text":"interface private pure module function default_real_num_components(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/default_real_num_components.html"},{"title":"default_real_values – Fiats","text":"interface Called by interface~~default_real_values~~CalledByGraph interface~default_real_values tensor_t%default_real_values none~values tensor_t%values none~values->interface~default_real_values proc~default_real_infer_unmapped default_real_infer_unmapped proc~default_real_infer_unmapped->none~values proc~default_real_learn default_real_learn proc~default_real_learn->none~values proc~default_real_map_from_training_range default_real_map_from_training_range proc~default_real_map_from_training_range->none~values proc~default_real_map_to_training_range default_real_map_to_training_range proc~default_real_map_to_training_range->none~values proc~default_real_write_to_stdout default_real_write_to_stdout proc~default_real_write_to_stdout->none~values proc~double_precision_infer_unmapped double_precision_infer_unmapped proc~double_precision_infer_unmapped->none~values proc~double_precision_map_from_training_range double_precision_map_from_training_range proc~double_precision_map_from_training_range->none~values proc~double_precision_map_to_training_range double_precision_map_to_training_range proc~double_precision_map_to_training_range->none~values proc~double_precision_write_to_stdout double_precision_write_to_stdout proc~double_precision_write_to_stdout->none~values proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->none~values proc~y y proc~y->none~values proc~y~2 y proc~y~2->none~values proc~y~3 y proc~y~3->none~values proc~y~4 y proc~y~4->none~values proc~y~5 y proc~y~5->none~values program~read_query_infer read_query_infer program~read_query_infer->none~values program~learn_addition learn_addition program~learn_addition->proc~y~2 program~learn_exponentiation learn_exponentiation program~learn_exponentiation->proc~y~5 program~learn_multiplication learn_multiplication program~learn_multiplication->proc~y program~learn_power_series learn_power_series program~learn_power_series->proc~y~3 program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~y~4 program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function default_real_values(self) result(tensor_values) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real,allocatable,(:)","tags":"","loc":"interface/default_real_values.html"},{"title":"double_precision_num_components – Fiats","text":"interface private pure module function double_precision_num_components(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t (double_precision)), intent(in) :: self Return Value integer","tags":"","loc":"interface/double_precision_num_components.html"},{"title":"double_precision_values – Fiats","text":"interface Called by interface~~double_precision_values~~CalledByGraph interface~double_precision_values tensor_t%double_precision_values none~values tensor_t%values none~values->interface~double_precision_values proc~default_real_infer_unmapped default_real_infer_unmapped proc~default_real_infer_unmapped->none~values proc~default_real_learn default_real_learn proc~default_real_learn->none~values proc~default_real_map_from_training_range default_real_map_from_training_range proc~default_real_map_from_training_range->none~values proc~default_real_map_to_training_range default_real_map_to_training_range proc~default_real_map_to_training_range->none~values proc~default_real_write_to_stdout default_real_write_to_stdout proc~default_real_write_to_stdout->none~values proc~double_precision_infer_unmapped double_precision_infer_unmapped proc~double_precision_infer_unmapped->none~values proc~double_precision_map_from_training_range double_precision_map_from_training_range proc~double_precision_map_from_training_range->none~values proc~double_precision_map_to_training_range double_precision_map_to_training_range proc~double_precision_map_to_training_range->none~values proc~double_precision_write_to_stdout double_precision_write_to_stdout proc~double_precision_write_to_stdout->none~values proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->none~values proc~y y proc~y->none~values proc~y~2 y proc~y~2->none~values proc~y~3 y proc~y~3->none~values proc~y~4 y proc~y~4->none~values proc~y~5 y proc~y~5->none~values program~read_query_infer read_query_infer program~read_query_infer->none~values program~learn_addition learn_addition program~learn_addition->proc~y~2 program~learn_exponentiation learn_exponentiation program~learn_exponentiation->proc~y~5 program~learn_multiplication learn_multiplication program~learn_multiplication->proc~y program~learn_power_series learn_power_series program~learn_power_series->proc~y~3 program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~y~4 program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function double_precision_values(self) result(tensor_values) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t (double_precision)), intent(in) :: self Return Value double precision,allocatable,(:)","tags":"","loc":"interface/double_precision_values.html"},{"title":"mini_batch_t – Fiats","text":"public interface mini_batch_t Functions private pure module function default_real_construct(input_output_pairs) result(mini_batch) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t ) private pure module function double_precision_construct(input_output_pairs) result(mini_batch) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t (double_precision)), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t (double_precision))","tags":"","loc":"interface/mini_batch_t.html"},{"title":"default_real_input_output_pairs – Fiats","text":"interface Called by interface~~default_real_input_output_pairs~~CalledByGraph interface~default_real_input_output_pairs mini_batch_t%default_real_input_output_pairs none~input_output_pairs~3 mini_batch_t%input_output_pairs none~input_output_pairs~3->interface~default_real_input_output_pairs proc~default_real_learn default_real_learn proc~default_real_learn->none~input_output_pairs~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function default_real_input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ),allocatable,(:)","tags":"","loc":"interface/default_real_input_output_pairs.html"},{"title":"double_precision_input_output_pairs – Fiats","text":"interface Called by interface~~double_precision_input_output_pairs~~CalledByGraph interface~double_precision_input_output_pairs mini_batch_t%double_precision_input_output_pairs none~input_output_pairs~3 mini_batch_t%input_output_pairs none~input_output_pairs~3->interface~double_precision_input_output_pairs proc~default_real_learn default_real_learn proc~default_real_learn->none~input_output_pairs~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function double_precision_input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t (double_precision)), intent(in) :: self Return Value type( input_output_pair_t double_precision),allocatable,(:)","tags":"","loc":"interface/double_precision_input_output_pairs.html"},{"title":"y – Fiats","text":"public elemental function y(x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t ) Calls proc~~y~5~~CallsGraph proc~y~5 y assert assert proc~y~5->assert none~values tensor_t%values proc~y~5->none~values interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~y~5~~CalledByGraph proc~y~5 y program~learn_exponentiation learn_exponentiation program~learn_exponentiation->proc~y~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/y~5.html"},{"title":"e – Fiats","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) Called by proc~~e~5~~CalledByGraph proc~e~5 e proc~perturbed_identity_network~6 perturbed_identity_network proc~perturbed_identity_network~6->proc~e~5 program~learn_exponentiation learn_exponentiation program~learn_exponentiation->proc~perturbed_identity_network~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/e~5.html"},{"title":"perturbed_identity_network – Fiats","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_network) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_network_t ) Calls proc~~perturbed_identity_network~6~~CallsGraph proc~perturbed_identity_network~6 perturbed_identity_network proc~e~5 e proc~perturbed_identity_network~6->proc~e~5 string_t string_t proc~perturbed_identity_network~6->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~perturbed_identity_network~6~~CalledByGraph proc~perturbed_identity_network~6 perturbed_identity_network program~learn_exponentiation learn_exponentiation program~learn_exponentiation->proc~perturbed_identity_network~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network~6.html"},{"title":"output – Fiats","text":"subroutine output(neural_network, file_name) Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: neural_network type(string_t), intent(in) :: file_name Calls proc~~output~5~~CallsGraph proc~output~5 output none~to_json~5 neural_network_t%to_json proc~output~5->none~to_json~5 write_lines write_lines proc~output~5->write_lines interface~default_real_to_json~4 neural_network_t%default_real_to_json none~to_json~5->interface~default_real_to_json~4 interface~double_precision_to_json~4 neural_network_t%double_precision_to_json none~to_json~5->interface~double_precision_to_json~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~output~5~~CalledByGraph proc~output~5 output program~learn_exponentiation learn_exponentiation program~learn_exponentiation->proc~output~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/output~5.html"},{"title":"layer_t – Fiats","text":"public interface layer_t Functions private recursive module function default_real_construct_layer(layer_lines, start) result(layer) Implementation → construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ), target private recursive module function double_precision_construct_layer(layer_lines, start) result(layer) Implementation → construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t (double_precision)), target","tags":"","loc":"interface/layer_t.html"},{"title":"default_real_count_inputs – Fiats","text":"interface Called by interface~~default_real_count_inputs~~CalledByGraph interface~default_real_count_inputs layer_t%default_real_count_inputs none~count_inputs layer_t%count_inputs none~count_inputs->interface~default_real_count_inputs proc~default_real_neural_network default_real_neural_network proc~default_real_neural_network->none~count_inputs proc~double_precision_neural_network double_precision_neural_network proc~double_precision_neural_network->none~count_inputs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function default_real_count_inputs(layer) result(num_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer","tags":"","loc":"interface/default_real_count_inputs.html"},{"title":"default_real_count_layers – Fiats","text":"interface Called by interface~~default_real_count_layers~~CalledByGraph interface~default_real_count_layers layer_t%default_real_count_layers none~count_layers layer_t%count_layers none~count_layers->interface~default_real_count_layers proc~default_real_from_json default_real_from_json proc~default_real_from_json->none~count_layers proc~default_real_neural_network default_real_neural_network proc~default_real_neural_network->none~count_layers proc~double_precision_from_json double_precision_from_json proc~double_precision_from_json->none~count_layers proc~double_precision_neural_network double_precision_neural_network proc~double_precision_neural_network->none~count_layers Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function default_real_count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer","tags":"","loc":"interface/default_real_count_layers.html"},{"title":"default_real_count_neurons – Fiats","text":"interface Called by interface~~default_real_count_neurons~~CalledByGraph interface~default_real_count_neurons layer_t%default_real_count_neurons none~count_neurons layer_t%count_neurons none~count_neurons->interface~default_real_count_neurons proc~default_real_from_json default_real_from_json proc~default_real_from_json->none~count_neurons proc~default_real_neural_network default_real_neural_network proc~default_real_neural_network->none~count_neurons proc~double_precision_from_json double_precision_from_json proc~double_precision_from_json->none~count_neurons proc~double_precision_neural_network double_precision_neural_network proc~double_precision_neural_network->none~count_neurons Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function default_real_count_neurons(layer) result(neurons_per_layer_result) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable,(:)","tags":"","loc":"interface/default_real_count_neurons.html"},{"title":"default_real_neural_network – Fiats","text":"interface Called by interface~~default_real_neural_network~~CalledByGraph interface~default_real_neural_network layer_t%default_real_neural_network none~neural_network~9 layer_t%neural_network none~neural_network~9->interface~default_real_neural_network proc~default_real_from_json default_real_from_json proc~default_real_from_json->none~neural_network~9 proc~double_precision_from_json double_precision_from_json proc~double_precision_from_json->none~neural_network~9 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function default_real_neural_network(hidden_layers, metadata, output_layer, input_map, output_map) result(neural_network_) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer type( tensor_map_t ), intent(in) :: input_map type( tensor_map_t ), intent(in) :: output_map Return Value type( neural_network_t )","tags":"","loc":"interface/default_real_neural_network.html"},{"title":"default_real_neurons_per_layer – Fiats","text":"interface private module function default_real_neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer","tags":"","loc":"interface/default_real_neurons_per_layer.html"},{"title":"default_real_next_allocated – Fiats","text":"interface private module function default_real_next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/default_real_next_allocated.html"},{"title":"default_real_next_pointer – Fiats","text":"interface private module function default_real_next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer","tags":"","loc":"interface/default_real_next_pointer.html"},{"title":"double_precision_count_inputs – Fiats","text":"interface Called by interface~~double_precision_count_inputs~~CalledByGraph interface~double_precision_count_inputs layer_t%double_precision_count_inputs none~count_inputs layer_t%count_inputs none~count_inputs->interface~double_precision_count_inputs proc~default_real_neural_network default_real_neural_network proc~default_real_neural_network->none~count_inputs proc~double_precision_neural_network double_precision_neural_network proc~double_precision_neural_network->none~count_inputs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function double_precision_count_inputs(layer) result(num_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in) :: layer Return Value integer","tags":"","loc":"interface/double_precision_count_inputs.html"},{"title":"double_precision_count_layers – Fiats","text":"interface Called by interface~~double_precision_count_layers~~CalledByGraph interface~double_precision_count_layers layer_t%double_precision_count_layers none~count_layers layer_t%count_layers none~count_layers->interface~double_precision_count_layers proc~default_real_from_json default_real_from_json proc~default_real_from_json->none~count_layers proc~default_real_neural_network default_real_neural_network proc~default_real_neural_network->none~count_layers proc~double_precision_from_json double_precision_from_json proc~double_precision_from_json->none~count_layers proc~double_precision_neural_network double_precision_neural_network proc~double_precision_neural_network->none~count_layers Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function double_precision_count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: layer Return Value integer","tags":"","loc":"interface/double_precision_count_layers.html"},{"title":"double_precision_count_neurons – Fiats","text":"interface Called by interface~~double_precision_count_neurons~~CalledByGraph interface~double_precision_count_neurons layer_t%double_precision_count_neurons none~count_neurons layer_t%count_neurons none~count_neurons->interface~double_precision_count_neurons proc~default_real_from_json default_real_from_json proc~default_real_from_json->none~count_neurons proc~default_real_neural_network default_real_neural_network proc~default_real_neural_network->none~count_neurons proc~double_precision_from_json double_precision_from_json proc~double_precision_from_json->none~count_neurons proc~double_precision_neural_network double_precision_neural_network proc~double_precision_neural_network->none~count_neurons Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function double_precision_count_neurons(layer) result(neurons_per_layer_result) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: layer Return Value integer,allocatable,(:)","tags":"","loc":"interface/double_precision_count_neurons.html"},{"title":"double_precision_neural_network – Fiats","text":"interface Called by interface~~double_precision_neural_network~~CalledByGraph interface~double_precision_neural_network layer_t%double_precision_neural_network none~neural_network~9 layer_t%neural_network none~neural_network~9->interface~double_precision_neural_network proc~default_real_from_json default_real_from_json proc~default_real_from_json->none~neural_network~9 proc~double_precision_from_json double_precision_from_json proc~double_precision_from_json->none~neural_network~9 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function double_precision_neural_network(hidden_layers, metadata, output_layer, input_map, output_map) result(neural_network_) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: hidden_layers type( metadata_t ), intent(in) :: metadata type( layer_t (double_precision)), intent(in), target :: output_layer type( tensor_map_t (double_precision)), intent(in) :: input_map type( tensor_map_t (double_precision)), intent(in) :: output_map Return Value type( neural_network_t double_precision)","tags":"","loc":"interface/double_precision_neural_network.html"},{"title":"double_precision_neurons_per_layer – Fiats","text":"interface private module function double_precision_neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: self Return Value integer","tags":"","loc":"interface/double_precision_neurons_per_layer.html"},{"title":"double_precision_next_allocated – Fiats","text":"interface private module function double_precision_next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in) :: self Return Value logical","tags":"","loc":"interface/double_precision_next_allocated.html"},{"title":"double_precision_next_pointer – Fiats","text":"interface private module function double_precision_next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: self Return Value type( layer_t double_precision),pointer","tags":"","loc":"interface/double_precision_next_pointer.html"},{"title":"neuron_t – Fiats","text":"public interface neuron_t Functions private pure module function default_real_from_components(weights, bias) result(neuron) Implementation → construct single neuron_t object from an array of weights and a bias Arguments Type Intent Optional Attributes Name real, intent(in) :: weights (:) real, intent(in) :: bias Return Value type( neuron_t ) private pure module function double_precision_from_components(weights, bias) result(neuron) Implementation → construct single neuron_t object from an array of weights and a bias Arguments Type Intent Optional Attributes Name double precision, intent(in) :: weights (:) double precision, intent(in) :: bias Return Value type( neuron_t (double_precision)) private pure recursive module function double_precision_from_json(neuron_lines, start) result(neuron) Implementation → construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t (double_precision)) private pure recursive module function from_json(neuron_lines, start) result(neuron) Implementation → construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t )","tags":"","loc":"interface/neuron_t.html"},{"title":"default_real_bias – Fiats","text":"interface private module function default_real_bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real","tags":"","loc":"interface/default_real_bias.html"},{"title":"default_real_next_allocated – Fiats","text":"interface Called by interface~~default_real_next_allocated~2~~CalledByGraph interface~default_real_next_allocated~2 neuron_t%default_real_next_allocated none~next_allocated~2 neuron_t%next_allocated none~next_allocated~2->interface~default_real_next_allocated~2 proc~default_real_construct_layer default_real_construct_layer proc~default_real_construct_layer->none~next_allocated~2 proc~default_real_count_neurons default_real_count_neurons proc~default_real_count_neurons->none~next_allocated~2 proc~default_real_neurons_per_layer default_real_neurons_per_layer proc~default_real_neurons_per_layer->none~next_allocated~2 proc~double_precision_construct_layer double_precision_construct_layer proc~double_precision_construct_layer->none~next_allocated~2 proc~double_precision_count_neurons double_precision_count_neurons proc~double_precision_count_neurons->none~next_allocated~2 proc~double_precision_neurons_per_layer double_precision_neurons_per_layer proc~double_precision_neurons_per_layer->none~next_allocated~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function default_real_next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/default_real_next_allocated~2.html"},{"title":"default_real_next_pointer – Fiats","text":"interface Called by interface~~default_real_next_pointer~2~~CalledByGraph interface~default_real_next_pointer~2 neuron_t%default_real_next_pointer none~next_pointer~2 neuron_t%next_pointer none~next_pointer~2->interface~default_real_next_pointer~2 proc~default_real_construct_layer default_real_construct_layer proc~default_real_construct_layer->none~next_pointer~2 proc~default_real_count_neurons default_real_count_neurons proc~default_real_count_neurons->none~next_pointer~2 proc~default_real_neurons_per_layer default_real_neurons_per_layer proc~default_real_neurons_per_layer->none~next_pointer~2 proc~double_precision_construct_layer double_precision_construct_layer proc~double_precision_construct_layer->none~next_pointer~2 proc~double_precision_count_neurons double_precision_count_neurons proc~double_precision_count_neurons->none~next_pointer~2 proc~double_precision_neurons_per_layer double_precision_neurons_per_layer proc~double_precision_neurons_per_layer->none~next_pointer~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function default_real_next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer","tags":"","loc":"interface/default_real_next_pointer~2.html"},{"title":"default_real_num_inputs – Fiats","text":"interface Called by interface~~default_real_num_inputs~~CalledByGraph interface~default_real_num_inputs neuron_t%default_real_num_inputs none~num_inputs~5 neuron_t%num_inputs none~num_inputs~5->interface~default_real_num_inputs proc~default_real_count_inputs default_real_count_inputs proc~default_real_count_inputs->none~num_inputs~5 proc~double_precision_count_inputs double_precision_count_inputs proc~double_precision_count_inputs->none~num_inputs~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function default_real_num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/default_real_num_inputs.html"},{"title":"default_real_to_json – Fiats","text":"interface private pure module function default_real_to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/default_real_to_json~3.html"},{"title":"default_real_weights – Fiats","text":"interface Called by interface~~default_real_weights~~CalledByGraph interface~default_real_weights neuron_t%default_real_weights none~weights neuron_t%weights none~weights->interface~default_real_weights proc~default_real_construct_layer default_real_construct_layer proc~default_real_construct_layer->none~weights proc~double_precision_construct_layer double_precision_construct_layer proc~double_precision_construct_layer->none~weights Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function default_real_weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real,allocatable,(:)","tags":"","loc":"interface/default_real_weights.html"},{"title":"double_precision_bias – Fiats","text":"interface private module function double_precision_bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value double precision","tags":"","loc":"interface/double_precision_bias.html"},{"title":"double_precision_next_allocated – Fiats","text":"interface Called by interface~~double_precision_next_allocated~2~~CalledByGraph interface~double_precision_next_allocated~2 neuron_t%double_precision_next_allocated none~next_allocated~2 neuron_t%next_allocated none~next_allocated~2->interface~double_precision_next_allocated~2 proc~default_real_construct_layer default_real_construct_layer proc~default_real_construct_layer->none~next_allocated~2 proc~default_real_count_neurons default_real_count_neurons proc~default_real_count_neurons->none~next_allocated~2 proc~default_real_neurons_per_layer default_real_neurons_per_layer proc~default_real_neurons_per_layer->none~next_allocated~2 proc~double_precision_construct_layer double_precision_construct_layer proc~double_precision_construct_layer->none~next_allocated~2 proc~double_precision_count_neurons double_precision_count_neurons proc~double_precision_count_neurons->none~next_allocated~2 proc~double_precision_neurons_per_layer double_precision_neurons_per_layer proc~double_precision_neurons_per_layer->none~next_allocated~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function double_precision_next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value logical","tags":"","loc":"interface/double_precision_next_allocated~2.html"},{"title":"double_precision_next_pointer – Fiats","text":"interface Called by interface~~double_precision_next_pointer~2~~CalledByGraph interface~double_precision_next_pointer~2 neuron_t%double_precision_next_pointer none~next_pointer~2 neuron_t%next_pointer none~next_pointer~2->interface~double_precision_next_pointer~2 proc~default_real_construct_layer default_real_construct_layer proc~default_real_construct_layer->none~next_pointer~2 proc~default_real_count_neurons default_real_count_neurons proc~default_real_count_neurons->none~next_pointer~2 proc~default_real_neurons_per_layer default_real_neurons_per_layer proc~default_real_neurons_per_layer->none~next_pointer~2 proc~double_precision_construct_layer double_precision_construct_layer proc~double_precision_construct_layer->none~next_pointer~2 proc~double_precision_count_neurons double_precision_count_neurons proc~double_precision_count_neurons->none~next_pointer~2 proc~double_precision_neurons_per_layer double_precision_neurons_per_layer proc~double_precision_neurons_per_layer->none~next_pointer~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function double_precision_next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in), target :: self Return Value type( neuron_t double_precision),pointer","tags":"","loc":"interface/double_precision_next_pointer~2.html"},{"title":"double_precision_num_inputs – Fiats","text":"interface Called by interface~~double_precision_num_inputs~~CalledByGraph interface~double_precision_num_inputs neuron_t%double_precision_num_inputs none~num_inputs~5 neuron_t%num_inputs none~num_inputs~5->interface~double_precision_num_inputs proc~default_real_count_inputs default_real_count_inputs proc~default_real_count_inputs->none~num_inputs~5 proc~double_precision_count_inputs double_precision_count_inputs proc~double_precision_count_inputs->none~num_inputs~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function double_precision_num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value integer","tags":"","loc":"interface/double_precision_num_inputs.html"},{"title":"double_precision_to_json – Fiats","text":"interface private pure module function double_precision_to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/double_precision_to_json~3.html"},{"title":"double_precision_weights – Fiats","text":"interface Called by interface~~double_precision_weights~~CalledByGraph interface~double_precision_weights neuron_t%double_precision_weights none~weights neuron_t%weights none~weights->interface~double_precision_weights proc~default_real_construct_layer default_real_construct_layer proc~default_real_construct_layer->none~weights proc~double_precision_construct_layer double_precision_construct_layer proc~double_precision_construct_layer->none~weights Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function double_precision_weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value double precision,allocatable,(:)","tags":"","loc":"interface/double_precision_weights.html"},{"title":"neural_network_t – Fiats","text":"public interface neural_network_t Functions private module function default_real_construct_from_components(metadata, weights, biases, nodes, input_map, output_map) result(neural_network) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real, intent(in) :: weights (:,:,:) real, intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) type( tensor_map_t ), intent(in), optional :: input_map type( tensor_map_t ), intent(in), optional :: output_map Return Value type( neural_network_t ) private impure elemental module function default_real_from_json(file_) result(neural_network) Implementation → Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( neural_network_t ) private module function double_precision_construct_from_components(metadata, weights, biases, nodes, input_map, output_map) result(neural_network) Implementation → Arguments Type Intent Optional Attributes Name type( metadata_t ), intent(in) :: metadata double precision, intent(in) :: weights (:,:,:) double precision, intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) type( tensor_map_t (double_precision)), intent(in), optional :: input_map type( tensor_map_t (double_precision)), intent(in), optional :: output_map Return Value type( neural_network_t (double_precision)) private impure elemental module function double_precision_from_json(file) result(neural_network) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_file_t ), intent(in) :: file Return Value type( neural_network_t (double_precision))","tags":"","loc":"interface/neural_network_t.html"},{"title":"unmapped_network_t – Fiats","text":"public interface unmapped_network_t Functions private impure elemental module function double_precision_unmapped_from_json(file) result(unmapped_network) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_file_t ), intent(in) :: file Return Value type( unmapped_network_t (double_precision))","tags":"","loc":"interface/unmapped_network_t.html"},{"title":"workspace_t – Fiats","text":"public interface workspace_t Functions private pure module function default_real_workspace(neural_network) result(workspace) Implementation → Arguments Type Intent Optional Attributes Name type( neural_network_t ), intent(in) :: neural_network Return Value type( workspace_t )","tags":"","loc":"interface/workspace_t.html"},{"title":"default_real_activation_name – Fiats","text":"interface Called by interface~~default_real_activation_name~~CalledByGraph interface~default_real_activation_name neural_network_t%default_real_activation_name none~activation_function_name neural_network_t%activation_function_name none~activation_function_name->interface~default_real_activation_name proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->none~activation_function_name program~read_query_infer read_query_infer program~read_query_infer->none~activation_function_name program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function default_real_activation_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/default_real_activation_name.html"},{"title":"default_real_allocate – Fiats","text":"interface private module subroutine default_real_allocate(self, neural_network) Implementation → Arguments Type Intent Optional Attributes Name class( workspace_t ), intent(inout) :: self type( neural_network_t ), intent(in) :: neural_network","tags":"","loc":"interface/default_real_allocate.html"},{"title":"default_real_allocated – Fiats","text":"interface Called by interface~~default_real_allocated~~CalledByGraph interface~default_real_allocated workspace_t%default_real_allocated none~fully_allocated workspace_t%fully_allocated none~fully_allocated->interface~default_real_allocated proc~default_real_learn default_real_learn proc~default_real_learn->none~fully_allocated proc~default_real_workspace default_real_workspace proc~default_real_workspace->none~fully_allocated Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function default_real_allocated(self) result(all_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( workspace_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/default_real_allocated.html"},{"title":"default_real_approximately_equal – Fiats","text":"interface private elemental module function default_real_approximately_equal(lhs, rhs) result(lhs_eq_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: lhs class( neural_network_t ), intent(in) :: rhs Return Value logical Description The result is true if lhs and rhs are the same to within a tolerance","tags":"","loc":"interface/default_real_approximately_equal.html"},{"title":"default_real_assert_conformable_with – Fiats","text":"interface Called by interface~~default_real_assert_conformable_with~~CalledByGraph interface~default_real_assert_conformable_with neural_network_t%default_real_assert_conformable_with none~assert_conformable_with neural_network_t%assert_conformable_with none~assert_conformable_with->interface~default_real_assert_conformable_with proc~default_real_approximately_equal default_real_approximately_equal proc~default_real_approximately_equal->none~assert_conformable_with proc~double_precision_approximately_equal double_precision_approximately_equal proc~double_precision_approximately_equal->none~assert_conformable_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module subroutine default_real_assert_conformable_with(self, neural_network) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self type( neural_network_t ), intent(in) :: neural_network","tags":"","loc":"interface/default_real_assert_conformable_with.html"},{"title":"default_real_consistency – Fiats","text":"interface Called by interface~~default_real_consistency~~CalledByGraph interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency neural_network_t%assert_consistency none~assert_consistency->interface~default_real_consistency proc~default_real_approximately_equal default_real_approximately_equal proc~default_real_approximately_equal->none~assert_consistency proc~default_real_assert_conformable_with default_real_assert_conformable_with proc~default_real_assert_conformable_with->none~assert_consistency proc~default_real_construct_from_components default_real_construct_from_components proc~default_real_construct_from_components->none~assert_consistency proc~default_real_from_json default_real_from_json proc~default_real_from_json->none~assert_consistency proc~default_real_infer default_real_infer proc~default_real_infer->none~assert_consistency proc~default_real_infer_unmapped default_real_infer_unmapped proc~default_real_infer_unmapped->none~assert_consistency proc~default_real_learn default_real_learn proc~default_real_learn->none~assert_consistency proc~default_real_nodes_per_layer default_real_nodes_per_layer proc~default_real_nodes_per_layer->none~assert_consistency proc~default_real_num_hidden_layers default_real_num_hidden_layers proc~default_real_num_hidden_layers->none~assert_consistency proc~default_real_num_inputs default_real_num_inputs proc~default_real_num_inputs->none~assert_consistency proc~default_real_num_outputs default_real_num_outputs proc~default_real_num_outputs->none~assert_consistency proc~default_real_to_json default_real_to_json proc~default_real_to_json->none~assert_consistency proc~double_precision_approximately_equal double_precision_approximately_equal proc~double_precision_approximately_equal->none~assert_consistency proc~double_precision_assert_conformable_with double_precision_assert_conformable_with proc~double_precision_assert_conformable_with->none~assert_consistency proc~double_precision_construct_from_components double_precision_construct_from_components proc~double_precision_construct_from_components->none~assert_consistency proc~double_precision_from_json double_precision_from_json proc~double_precision_from_json->none~assert_consistency proc~double_precision_infer double_precision_infer proc~double_precision_infer->none~assert_consistency proc~double_precision_infer_unmapped double_precision_infer_unmapped proc~double_precision_infer_unmapped->none~assert_consistency proc~double_precision_nodes_per_layer double_precision_nodes_per_layer proc~double_precision_nodes_per_layer->none~assert_consistency proc~double_precision_num_hidden_layers double_precision_num_hidden_layers proc~double_precision_num_hidden_layers->none~assert_consistency proc~double_precision_num_inputs double_precision_num_inputs proc~double_precision_num_inputs->none~assert_consistency proc~double_precision_num_outputs double_precision_num_outputs proc~double_precision_num_outputs->none~assert_consistency proc~double_precision_to_json double_precision_to_json proc~double_precision_to_json->none~assert_consistency Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module subroutine default_real_consistency(self) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self","tags":"","loc":"interface/default_real_consistency.html"},{"title":"default_real_infer – Fiats","text":"interface Called by interface~~default_real_infer~~CalledByGraph interface~default_real_infer neural_network_t%default_real_infer none~infer neural_network_t%infer none~infer->interface~default_real_infer proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->none~infer program~read_query_infer read_query_infer program~read_query_infer->none~infer program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function default_real_infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t )","tags":"","loc":"interface/default_real_infer.html"},{"title":"default_real_infer_unmapped – Fiats","text":"interface private elemental module function default_real_infer_unmapped(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( unmapped_network_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t )","tags":"","loc":"interface/default_real_infer_unmapped.html"},{"title":"default_real_learn – Fiats","text":"interface Called by interface~~default_real_learn~~CalledByGraph interface~default_real_learn neural_network_t%default_real_learn none~learn~2 trainable_network_t%learn none~learn~2->interface~default_real_learn proc~default_real_train default_real_train proc~default_real_train->none~learn~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module subroutine default_real_learn(self, mini_batches_arr, cost, adam, learning_rate, workspace) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches_arr (:) real, intent(out), optional, allocatable :: cost (:) logical, intent(in) :: adam real, intent(in) :: learning_rate type( workspace_t ), intent(inout) :: workspace","tags":"","loc":"interface/default_real_learn.html"},{"title":"default_real_map_from_output_range – Fiats","text":"interface private elemental module function default_real_map_from_output_range(self, normalized_tensor) result(tensor) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self type( tensor_t ), intent(in) :: normalized_tensor Return Value type( tensor_t ) Description The result contains the output tensor values unmapped via the inverse of the mapping used in training","tags":"","loc":"interface/default_real_map_from_output_range.html"},{"title":"default_real_map_to_input_range – Fiats","text":"interface private elemental module function default_real_map_to_input_range(self, tensor) result(normalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) Description The result contains the input tensor values normalized to fall on the range used during training","tags":"","loc":"interface/default_real_map_to_input_range.html"},{"title":"default_real_nodes_per_layer – Fiats","text":"interface Called by interface~~default_real_nodes_per_layer~2~~CalledByGraph interface~default_real_nodes_per_layer~2 neural_network_t%default_real_nodes_per_layer none~nodes_per_layer~5 neural_network_t%nodes_per_layer none~nodes_per_layer~5->interface~default_real_nodes_per_layer~2 proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->none~nodes_per_layer~5 program~read_query_infer read_query_infer program~read_query_infer->none~nodes_per_layer~5 program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function default_real_nodes_per_layer(self) result(node_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value integer,allocatable,(:)","tags":"","loc":"interface/default_real_nodes_per_layer~2.html"},{"title":"default_real_num_hidden_layers – Fiats","text":"interface Called by interface~~default_real_num_hidden_layers~~CalledByGraph interface~default_real_num_hidden_layers neural_network_t%default_real_num_hidden_layers none~num_hidden_layers~2 neural_network_t%num_hidden_layers none~num_hidden_layers~2->interface~default_real_num_hidden_layers proc~default_real_learn default_real_learn proc~default_real_learn->none~num_hidden_layers~2 proc~default_real_to_json default_real_to_json proc~default_real_to_json->none~num_hidden_layers~2 proc~double_precision_to_json double_precision_to_json proc~double_precision_to_json->none~num_hidden_layers~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function default_real_num_hidden_layers(self) result(hidden_layer_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/default_real_num_hidden_layers.html"},{"title":"default_real_num_inputs – Fiats","text":"interface Called by interface~~default_real_num_inputs~2~~CalledByGraph interface~default_real_num_inputs~2 neural_network_t%default_real_num_inputs none~num_inputs~6 neural_network_t%num_inputs none~num_inputs~6->interface~default_real_num_inputs~2 proc~default_real_learn default_real_learn proc~default_real_learn->none~num_inputs~6 proc~default_real_to_json default_real_to_json proc~default_real_to_json->none~num_inputs~6 proc~double_precision_to_json double_precision_to_json proc~double_precision_to_json->none~num_inputs~6 proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->none~num_inputs~6 program~read_query_infer read_query_infer program~read_query_infer->none~num_inputs~6 program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function default_real_num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/default_real_num_inputs~2.html"},{"title":"default_real_num_outputs – Fiats","text":"interface Called by interface~~default_real_num_outputs~~CalledByGraph interface~default_real_num_outputs neural_network_t%default_real_num_outputs none~num_outputs neural_network_t%num_outputs none~num_outputs->interface~default_real_num_outputs proc~default_real_to_json default_real_to_json proc~default_real_to_json->none~num_outputs proc~double_precision_to_json double_precision_to_json proc~double_precision_to_json->none~num_outputs proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->none~num_outputs program~read_query_infer read_query_infer program~read_query_infer->none~num_outputs program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function default_real_num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/default_real_num_outputs.html"},{"title":"default_real_skip – Fiats","text":"interface private pure module function default_real_skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/default_real_skip.html"},{"title":"default_real_to_json – Fiats","text":"interface Called by interface~~default_real_to_json~4~~CalledByGraph interface~default_real_to_json~4 neural_network_t%default_real_to_json none~to_json~5 neural_network_t%to_json none~to_json~5->interface~default_real_to_json~4 proc~output output proc~output->none~to_json~5 proc~output~2 output proc~output~2->none~to_json~5 proc~output~3 output proc~output~3->none~to_json~5 proc~output~4 output proc~output~4->none~to_json~5 proc~output~5 output proc~output~5->none~to_json~5 proc~output~6 output proc~output~6->none~to_json~5 proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->none~to_json~5 program~learn_addition learn_addition program~learn_addition->proc~output~2 program~learn_exponentiation learn_exponentiation program~learn_exponentiation->proc~output~5 program~learn_multiplication learn_multiplication program~learn_multiplication->proc~output program~learn_power_series learn_power_series program~learn_power_series->proc~output~3 program~train_and_write train_and_write program~train_and_write->proc~output~6 program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~output~4 program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private impure elemental module function default_real_to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value type(file_t)","tags":"","loc":"interface/default_real_to_json~4.html"},{"title":"double_precision_activation_name – Fiats","text":"interface Called by interface~~double_precision_activation_name~~CalledByGraph interface~double_precision_activation_name neural_network_t%double_precision_activation_name none~activation_function_name neural_network_t%activation_function_name none~activation_function_name->interface~double_precision_activation_name proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->none~activation_function_name program~read_query_infer read_query_infer program~read_query_infer->none~activation_function_name program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function double_precision_activation_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/double_precision_activation_name.html"},{"title":"double_precision_approximately_equal – Fiats","text":"interface private elemental module function double_precision_approximately_equal(lhs, rhs) result(lhs_eq_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: lhs class( neural_network_t (double_precision)), intent(in) :: rhs Return Value logical Description The result is true if lhs and rhs are the same to within a tolerance","tags":"","loc":"interface/double_precision_approximately_equal.html"},{"title":"double_precision_assert_conformable_with – Fiats","text":"interface Called by interface~~double_precision_assert_conformable_with~~CalledByGraph interface~double_precision_assert_conformable_with neural_network_t%double_precision_assert_conformable_with none~assert_conformable_with neural_network_t%assert_conformable_with none~assert_conformable_with->interface~double_precision_assert_conformable_with proc~default_real_approximately_equal default_real_approximately_equal proc~default_real_approximately_equal->none~assert_conformable_with proc~double_precision_approximately_equal double_precision_approximately_equal proc~double_precision_approximately_equal->none~assert_conformable_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module subroutine double_precision_assert_conformable_with(self, neural_network) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self type( neural_network_t (double_precision)), intent(in) :: neural_network","tags":"","loc":"interface/double_precision_assert_conformable_with.html"},{"title":"double_precision_consistency – Fiats","text":"interface Called by interface~~double_precision_consistency~~CalledByGraph interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency neural_network_t%assert_consistency none~assert_consistency->interface~double_precision_consistency proc~default_real_approximately_equal default_real_approximately_equal proc~default_real_approximately_equal->none~assert_consistency proc~default_real_assert_conformable_with default_real_assert_conformable_with proc~default_real_assert_conformable_with->none~assert_consistency proc~default_real_construct_from_components default_real_construct_from_components proc~default_real_construct_from_components->none~assert_consistency proc~default_real_from_json default_real_from_json proc~default_real_from_json->none~assert_consistency proc~default_real_infer default_real_infer proc~default_real_infer->none~assert_consistency proc~default_real_infer_unmapped default_real_infer_unmapped proc~default_real_infer_unmapped->none~assert_consistency proc~default_real_learn default_real_learn proc~default_real_learn->none~assert_consistency proc~default_real_nodes_per_layer default_real_nodes_per_layer proc~default_real_nodes_per_layer->none~assert_consistency proc~default_real_num_hidden_layers default_real_num_hidden_layers proc~default_real_num_hidden_layers->none~assert_consistency proc~default_real_num_inputs default_real_num_inputs proc~default_real_num_inputs->none~assert_consistency proc~default_real_num_outputs default_real_num_outputs proc~default_real_num_outputs->none~assert_consistency proc~default_real_to_json default_real_to_json proc~default_real_to_json->none~assert_consistency proc~double_precision_approximately_equal double_precision_approximately_equal proc~double_precision_approximately_equal->none~assert_consistency proc~double_precision_assert_conformable_with double_precision_assert_conformable_with proc~double_precision_assert_conformable_with->none~assert_consistency proc~double_precision_construct_from_components double_precision_construct_from_components proc~double_precision_construct_from_components->none~assert_consistency proc~double_precision_from_json double_precision_from_json proc~double_precision_from_json->none~assert_consistency proc~double_precision_infer double_precision_infer proc~double_precision_infer->none~assert_consistency proc~double_precision_infer_unmapped double_precision_infer_unmapped proc~double_precision_infer_unmapped->none~assert_consistency proc~double_precision_nodes_per_layer double_precision_nodes_per_layer proc~double_precision_nodes_per_layer->none~assert_consistency proc~double_precision_num_hidden_layers double_precision_num_hidden_layers proc~double_precision_num_hidden_layers->none~assert_consistency proc~double_precision_num_inputs double_precision_num_inputs proc~double_precision_num_inputs->none~assert_consistency proc~double_precision_num_outputs double_precision_num_outputs proc~double_precision_num_outputs->none~assert_consistency proc~double_precision_to_json double_precision_to_json proc~double_precision_to_json->none~assert_consistency Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module subroutine double_precision_consistency(self) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self","tags":"","loc":"interface/double_precision_consistency.html"},{"title":"double_precision_infer – Fiats","text":"interface Called by interface~~double_precision_infer~~CalledByGraph interface~double_precision_infer neural_network_t%double_precision_infer none~infer neural_network_t%infer none~infer->interface~double_precision_infer proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->none~infer program~read_query_infer read_query_infer program~read_query_infer->none~infer program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function double_precision_infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: inputs Return Value type( tensor_t double_precision)","tags":"","loc":"interface/double_precision_infer.html"},{"title":"double_precision_infer_unmapped – Fiats","text":"interface private elemental module function double_precision_infer_unmapped(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( unmapped_network_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: inputs Return Value type( tensor_t double_precision)","tags":"","loc":"interface/double_precision_infer_unmapped.html"},{"title":"double_precision_map_from_output_range – Fiats","text":"interface private elemental module function double_precision_map_from_output_range(self, normalized_tensor) result(tensor) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: normalized_tensor Return Value type( tensor_t double_precision) Description The result contains the output tensor values unmapped via the inverse of the mapping used in training","tags":"","loc":"interface/double_precision_map_from_output_range.html"},{"title":"double_precision_map_to_input_range – Fiats","text":"interface private elemental module function double_precision_map_to_input_range(self, tensor) result(normalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: tensor Return Value type( tensor_t double_precision) Description The result contains the input tensor values normalized to fall on the range used during training","tags":"","loc":"interface/double_precision_map_to_input_range.html"},{"title":"double_precision_nodes_per_layer – Fiats","text":"interface Called by interface~~double_precision_nodes_per_layer~2~~CalledByGraph interface~double_precision_nodes_per_layer~2 neural_network_t%double_precision_nodes_per_layer none~nodes_per_layer~5 neural_network_t%nodes_per_layer none~nodes_per_layer~5->interface~double_precision_nodes_per_layer~2 proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->none~nodes_per_layer~5 program~read_query_infer read_query_infer program~read_query_infer->none~nodes_per_layer~5 program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function double_precision_nodes_per_layer(self) result(node_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value integer,allocatable,(:)","tags":"","loc":"interface/double_precision_nodes_per_layer~2.html"},{"title":"double_precision_num_hidden_layers – Fiats","text":"interface Called by interface~~double_precision_num_hidden_layers~~CalledByGraph interface~double_precision_num_hidden_layers neural_network_t%double_precision_num_hidden_layers none~num_hidden_layers~2 neural_network_t%num_hidden_layers none~num_hidden_layers~2->interface~double_precision_num_hidden_layers proc~default_real_learn default_real_learn proc~default_real_learn->none~num_hidden_layers~2 proc~default_real_to_json default_real_to_json proc~default_real_to_json->none~num_hidden_layers~2 proc~double_precision_to_json double_precision_to_json proc~double_precision_to_json->none~num_hidden_layers~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function double_precision_num_hidden_layers(self) result(hidden_layer_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value integer","tags":"","loc":"interface/double_precision_num_hidden_layers.html"},{"title":"double_precision_num_inputs – Fiats","text":"interface Called by interface~~double_precision_num_inputs~2~~CalledByGraph interface~double_precision_num_inputs~2 neural_network_t%double_precision_num_inputs none~num_inputs~6 neural_network_t%num_inputs none~num_inputs~6->interface~double_precision_num_inputs~2 proc~default_real_learn default_real_learn proc~default_real_learn->none~num_inputs~6 proc~default_real_to_json default_real_to_json proc~default_real_to_json->none~num_inputs~6 proc~double_precision_to_json double_precision_to_json proc~double_precision_to_json->none~num_inputs~6 proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->none~num_inputs~6 program~read_query_infer read_query_infer program~read_query_infer->none~num_inputs~6 program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function double_precision_num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value integer","tags":"","loc":"interface/double_precision_num_inputs~2.html"},{"title":"double_precision_num_outputs – Fiats","text":"interface Called by interface~~double_precision_num_outputs~~CalledByGraph interface~double_precision_num_outputs neural_network_t%double_precision_num_outputs none~num_outputs neural_network_t%num_outputs none~num_outputs->interface~double_precision_num_outputs proc~default_real_to_json default_real_to_json proc~default_real_to_json->none~num_outputs proc~double_precision_to_json double_precision_to_json proc~double_precision_to_json->none~num_outputs proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->none~num_outputs program~read_query_infer read_query_infer program~read_query_infer->none~num_outputs program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function double_precision_num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value integer","tags":"","loc":"interface/double_precision_num_outputs.html"},{"title":"double_precision_skip – Fiats","text":"interface private pure module function double_precision_skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value logical","tags":"","loc":"interface/double_precision_skip.html"},{"title":"double_precision_to_json – Fiats","text":"interface Called by interface~~double_precision_to_json~4~~CalledByGraph interface~double_precision_to_json~4 neural_network_t%double_precision_to_json none~to_json~5 neural_network_t%to_json none~to_json~5->interface~double_precision_to_json~4 proc~output output proc~output->none~to_json~5 proc~output~2 output proc~output~2->none~to_json~5 proc~output~3 output proc~output~3->none~to_json~5 proc~output~4 output proc~output~4->none~to_json~5 proc~output~5 output proc~output~5->none~to_json~5 proc~output~6 output proc~output~6->none~to_json~5 proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->none~to_json~5 program~learn_addition learn_addition program~learn_addition->proc~output~2 program~learn_exponentiation learn_exponentiation program~learn_exponentiation->proc~output~5 program~learn_multiplication learn_multiplication program~learn_multiplication->proc~output program~learn_power_series learn_power_series program~learn_power_series->proc~output~3 program~train_and_write train_and_write program~train_and_write->proc~output~6 program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~output~4 program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private impure elemental module function double_precision_to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value type(file_t)","tags":"","loc":"interface/double_precision_to_json~4.html"},{"title":"e – Fiats","text":"pure function e(m, n) result(e_mn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n Return Value real Called by proc~~e~6~~CalledByGraph proc~e~6 e proc~perturbed_identity_network~7 perturbed_identity_network proc~perturbed_identity_network~7->proc~e~6 program~train_and_write train_and_write program~train_and_write->proc~perturbed_identity_network~7 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/e~6.html"},{"title":"perturbed_identity_network – Fiats","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_network) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_network_t ) Calls proc~~perturbed_identity_network~7~~CallsGraph proc~perturbed_identity_network~7 perturbed_identity_network proc~e~6 e proc~perturbed_identity_network~7->proc~e~6 string_t string_t proc~perturbed_identity_network~7->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~perturbed_identity_network~7~~CalledByGraph proc~perturbed_identity_network~7 perturbed_identity_network program~train_and_write train_and_write program~train_and_write->proc~perturbed_identity_network~7 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network~7.html"},{"title":"output – Fiats","text":"subroutine output(neural_network, file_name) Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: neural_network type(string_t), intent(in) :: file_name Calls proc~~output~6~~CallsGraph proc~output~6 output none~to_json~5 neural_network_t%to_json proc~output~6->none~to_json~5 write_lines write_lines proc~output~6->write_lines interface~default_real_to_json~4 neural_network_t%default_real_to_json none~to_json~5->interface~default_real_to_json~4 interface~double_precision_to_json~4 neural_network_t%double_precision_to_json none~to_json~5->interface~double_precision_to_json~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~output~6~~CalledByGraph proc~output~6 output program~train_and_write train_and_write program~train_and_write->proc~output~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/output~6.html"},{"title":"tensor_map_t – Fiats","text":"public interface tensor_map_t Functions private pure module function construct_default_real(layer, minima, maxima) result(tensor_map) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: layer real, intent(in), dimension(:) :: minima real, intent(in), dimension(:) :: maxima Return Value type( tensor_map_t ) private pure module function construct_double_precision(layer, minima, maxima) result(tensor_map) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: layer double precision, intent(in), dimension(:) :: minima double precision, intent(in), dimension(:) :: maxima Return Value type( tensor_map_t (double_precision)) private module function double_precision_from_json(lines) result(tensor_map) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: lines (:) Return Value type( tensor_map_t (double_precision)) private module function from_json(lines) result(tensor_map) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( tensor_map_t )","tags":"","loc":"interface/tensor_map_t.html"},{"title":"default_real_equals – Fiats","text":"interface private elemental module function default_real_equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t ), intent(in) :: lhs class( tensor_map_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/default_real_equals~3.html"},{"title":"default_real_map_from_training_range – Fiats","text":"interface Called by interface~~default_real_map_from_training_range~~CalledByGraph interface~default_real_map_from_training_range tensor_map_t%default_real_map_from_training_range none~map_from_training_range tensor_map_t%map_from_training_range none~map_from_training_range->interface~default_real_map_from_training_range proc~default_real_infer default_real_infer proc~default_real_infer->none~map_from_training_range proc~default_real_map_from_output_range default_real_map_from_output_range proc~default_real_map_from_output_range->none~map_from_training_range proc~double_precision_infer double_precision_infer proc~double_precision_infer->none~map_from_training_range proc~double_precision_map_from_output_range double_precision_map_from_output_range proc~double_precision_map_from_output_range->none~map_from_training_range Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function default_real_map_from_training_range(self, tensor) result(unnormalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t )","tags":"","loc":"interface/default_real_map_from_training_range.html"},{"title":"default_real_map_to_training_range – Fiats","text":"interface Called by interface~~default_real_map_to_training_range~~CalledByGraph interface~default_real_map_to_training_range tensor_map_t%default_real_map_to_training_range none~map_to_training_range tensor_map_t%map_to_training_range none~map_to_training_range->interface~default_real_map_to_training_range proc~default_real_infer default_real_infer proc~default_real_infer->none~map_to_training_range proc~default_real_map_to_input_range default_real_map_to_input_range proc~default_real_map_to_input_range->none~map_to_training_range proc~double_precision_infer double_precision_infer proc~double_precision_infer->none~map_to_training_range proc~double_precision_map_to_input_range double_precision_map_to_input_range proc~double_precision_map_to_input_range->none~map_to_training_range Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function default_real_map_to_training_range(self, tensor) result(normalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t )","tags":"","loc":"interface/default_real_map_to_training_range.html"},{"title":"default_real_to_json – Fiats","text":"interface Called by interface~~default_real_to_json~5~~CalledByGraph interface~default_real_to_json~5 tensor_map_t%default_real_to_json none~to_json~6 tensor_map_t%to_json none~to_json~6->interface~default_real_to_json~5 proc~default_real_from_json default_real_from_json proc~default_real_from_json->none~to_json~6 proc~double_precision_from_json double_precision_from_json proc~double_precision_from_json->none~to_json~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function default_real_to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t ), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/default_real_to_json~5.html"},{"title":"double_precision_equals – Fiats","text":"interface private elemental module function double_precision_equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t (double_precision)), intent(in) :: lhs class( tensor_map_t (double_precision)), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/double_precision_equals~3.html"},{"title":"double_precision_map_from_training_range – Fiats","text":"interface Called by interface~~double_precision_map_from_training_range~~CalledByGraph interface~double_precision_map_from_training_range tensor_map_t%double_precision_map_from_training_range none~map_from_training_range tensor_map_t%map_from_training_range none~map_from_training_range->interface~double_precision_map_from_training_range proc~default_real_infer default_real_infer proc~default_real_infer->none~map_from_training_range proc~default_real_map_from_output_range default_real_map_from_output_range proc~default_real_map_from_output_range->none~map_from_training_range proc~double_precision_infer double_precision_infer proc~double_precision_infer->none~map_from_training_range proc~double_precision_map_from_output_range double_precision_map_from_output_range proc~double_precision_map_from_output_range->none~map_from_training_range Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function double_precision_map_from_training_range(self, tensor) result(unnormalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: tensor Return Value type( tensor_t double_precision)","tags":"","loc":"interface/double_precision_map_from_training_range.html"},{"title":"double_precision_map_to_training_range – Fiats","text":"interface Called by interface~~double_precision_map_to_training_range~~CalledByGraph interface~double_precision_map_to_training_range tensor_map_t%double_precision_map_to_training_range none~map_to_training_range tensor_map_t%map_to_training_range none~map_to_training_range->interface~double_precision_map_to_training_range proc~default_real_infer default_real_infer proc~default_real_infer->none~map_to_training_range proc~default_real_map_to_input_range default_real_map_to_input_range proc~default_real_map_to_input_range->none~map_to_training_range proc~double_precision_infer double_precision_infer proc~double_precision_infer->none~map_to_training_range proc~double_precision_map_to_input_range double_precision_map_to_input_range proc~double_precision_map_to_input_range->none~map_to_training_range Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function double_precision_map_to_training_range(self, tensor) result(normalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: tensor Return Value type( tensor_t double_precision)","tags":"","loc":"interface/double_precision_map_to_training_range.html"},{"title":"double_precision_to_json – Fiats","text":"interface Called by interface~~double_precision_to_json~5~~CalledByGraph interface~double_precision_to_json~5 tensor_map_t%double_precision_to_json none~to_json~6 tensor_map_t%to_json none~to_json~6->interface~double_precision_to_json~5 proc~default_real_from_json default_real_from_json proc~default_real_from_json->none~to_json~6 proc~double_precision_from_json double_precision_from_json proc~double_precision_from_json->none~to_json~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function double_precision_to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t (double_precision)), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/double_precision_to_json~5.html"},{"title":"metadata_t – Fiats","text":"public interface metadata_t Functions private pure module function double_precision_from_json(lines) result(metadata) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: lines (:) Return Value type( metadata_t ) private pure module function from_components(modelName, modelAuthor, compilationDate, activationFunction, usingSkipConnections) result(metadata) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: modelName type(string_t), intent(in) :: modelAuthor type(string_t), intent(in) :: compilationDate type(string_t), intent(in) :: activationFunction type(string_t), intent(in) :: usingSkipConnections Return Value type( metadata_t ) private pure module function from_json(lines) result(metadata) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( metadata_t )","tags":"","loc":"interface/metadata_t.html"},{"title":"activation_name – Fiats","text":"interface Called by interface~~activation_name~2~~CalledByGraph interface~activation_name~2 metadata_t%activation_name proc~default_real_from_json default_real_from_json proc~default_real_from_json->interface~activation_name~2 proc~double_precision_construct_from_components double_precision_construct_from_components proc~double_precision_construct_from_components->interface~activation_name~2 proc~double_precision_from_json double_precision_from_json proc~double_precision_from_json->interface~activation_name~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function activation_name(self) result(function_name) Implementation → Arguments Type Intent Optional Attributes Name class( metadata_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/activation_name~2.html"},{"title":"equals – Fiats","text":"interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( metadata_t ), intent(in) :: lhs class( metadata_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/equals~3.html"},{"title":"strings – Fiats","text":"interface Called by interface~~strings~~CalledByGraph interface~strings metadata_t%strings proc~default_real_activation_name default_real_activation_name proc~default_real_activation_name->interface~strings proc~default_real_from_json default_real_from_json proc~default_real_from_json->interface~strings proc~default_real_skip default_real_skip proc~default_real_skip->interface~strings proc~double_precision_activation_name double_precision_activation_name proc~double_precision_activation_name->interface~strings proc~double_precision_skip double_precision_skip proc~double_precision_skip->interface~strings Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function strings(self) result(components) Implementation → Arguments Type Intent Optional Attributes Name class( metadata_t ), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/strings.html"},{"title":"to_json – Fiats","text":"interface Called by interface~~to_json~2~~CalledByGraph interface~to_json~2 metadata_t%to_json proc~default_real_to_json default_real_to_json proc~default_real_to_json->interface~to_json~2 proc~double_precision_to_json double_precision_to_json proc~double_precision_to_json->interface~to_json~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( metadata_t ), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/to_json~2.html"},{"title":"construct_default_real – Fiats","text":"module procedure construct_default_real pure module function construct_default_real(values) result(tensor) Arguments Type Intent Optional Attributes Name real, intent(in) :: values (:) Return Value type( tensor_t )","tags":"","loc":"proc/construct_default_real.html"},{"title":"construct_double_precision – Fiats","text":"module procedure construct_double_precision pure module function construct_double_precision(values) result(tensor) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: values (:) Return Value type( tensor_t (double_precision))","tags":"","loc":"proc/construct_double_precision.html"},{"title":"default_real_num_components – Fiats","text":"module procedure default_real_num_components pure module function default_real_num_components(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer","tags":"","loc":"proc/default_real_num_components.html"},{"title":"default_real_values – Fiats","text":"module procedure default_real_values pure module function default_real_values(self) result(tensor_values) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real, allocatable, (:)","tags":"","loc":"proc/default_real_values.html"},{"title":"double_precision_num_components – Fiats","text":"module procedure double_precision_num_components pure module function double_precision_num_components(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t (double_precision)), intent(in) :: self Return Value integer","tags":"","loc":"proc/double_precision_num_components.html"},{"title":"double_precision_values – Fiats","text":"module procedure double_precision_values pure module function double_precision_values(self) result(tensor_values) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t (double_precision)), intent(in) :: self Return Value double precision, allocatable, (:)","tags":"","loc":"proc/double_precision_values.html"},{"title":"default_real_activation_name – Fiats","text":"module procedure default_real_activation_name elemental module function default_real_activation_name(self) result(activation_name) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value type(string_t) Calls proc~~default_real_activation_name~~CallsGraph proc~default_real_activation_name default_real_activation_name interface~strings metadata_t%strings proc~default_real_activation_name->interface~strings Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_activation_name.html"},{"title":"default_real_approximately_equal – Fiats","text":"module procedure default_real_approximately_equal elemental module function default_real_approximately_equal(lhs, rhs) result(lhs_eq_rhs) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: lhs class( neural_network_t ), intent(in) :: rhs Return Value logical Calls proc~~default_real_approximately_equal~~CallsGraph proc~default_real_approximately_equal default_real_approximately_equal layer_eq layer_eq proc~default_real_approximately_equal->layer_eq none~assert_conformable_with neural_network_t%assert_conformable_with proc~default_real_approximately_equal->none~assert_conformable_with none~assert_consistency neural_network_t%assert_consistency proc~default_real_approximately_equal->none~assert_consistency interface~default_real_assert_conformable_with neural_network_t%default_real_assert_conformable_with none~assert_conformable_with->interface~default_real_assert_conformable_with interface~double_precision_assert_conformable_with neural_network_t%double_precision_assert_conformable_with none~assert_conformable_with->interface~double_precision_assert_conformable_with interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_approximately_equal.html"},{"title":"default_real_assert_conformable_with – Fiats","text":"module procedure default_real_assert_conformable_with elemental module subroutine default_real_assert_conformable_with(self, neural_network) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self type( neural_network_t ), intent(in) :: neural_network Calls proc~~default_real_assert_conformable_with~~CallsGraph proc~default_real_assert_conformable_with default_real_assert_conformable_with assert assert proc~default_real_assert_conformable_with->assert intrinsic_array_t intrinsic_array_t proc~default_real_assert_conformable_with->intrinsic_array_t none~assert_consistency neural_network_t%assert_consistency proc~default_real_assert_conformable_with->none~assert_consistency interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_assert_conformable_with.html"},{"title":"default_real_consistency – Fiats","text":"module procedure default_real_consistency pure module subroutine default_real_consistency(self) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Calls proc~~default_real_consistency~~CallsGraph proc~default_real_consistency default_real_consistency assert assert proc~default_real_consistency->assert intrinsic_array_t intrinsic_array_t proc~default_real_consistency->intrinsic_array_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_consistency.html"},{"title":"default_real_construct_from_components – Fiats","text":"module procedure default_real_construct_from_components module function default_real_construct_from_components(metadata, weights, biases, nodes, input_map, output_map) result(neural_network) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real, intent(in) :: weights (:,:,:) real, intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) type( tensor_map_t ), intent(in), optional :: input_map type( tensor_map_t ), intent(in), optional :: output_map Return Value type( neural_network_t ) Calls proc~~default_real_construct_from_components~~CallsGraph proc~default_real_construct_from_components default_real_construct_from_components none~assert_consistency neural_network_t%assert_consistency proc~default_real_construct_from_components->none~assert_consistency string string proc~default_real_construct_from_components->string interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_construct_from_components.html"},{"title":"default_real_from_json – Fiats","text":"module procedure default_real_from_json impure elemental module function default_real_from_json(file_) result(neural_network) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( neural_network_t ) Calls proc~~default_real_from_json~~CallsGraph proc~default_real_from_json default_real_from_json assert assert proc~default_real_from_json->assert get_json_value get_json_value proc~default_real_from_json->get_json_value interface~activation_name~2 metadata_t%activation_name proc~default_real_from_json->interface~activation_name~2 interface~strings metadata_t%strings proc~default_real_from_json->interface~strings lines lines proc~default_real_from_json->lines none~assert_consistency neural_network_t%assert_consistency proc~default_real_from_json->none~assert_consistency none~count_layers layer_t%count_layers proc~default_real_from_json->none~count_layers none~count_neurons layer_t%count_neurons proc~default_real_from_json->none~count_neurons none~neural_network~9 layer_t%neural_network proc~default_real_from_json->none~neural_network~9 none~to_json~6 tensor_map_t%to_json proc~default_real_from_json->none~to_json~6 string string proc~default_real_from_json->string string_t string_t proc~default_real_from_json->string_t interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency interface~default_real_count_layers layer_t%default_real_count_layers none~count_layers->interface~default_real_count_layers interface~double_precision_count_layers layer_t%double_precision_count_layers none~count_layers->interface~double_precision_count_layers interface~default_real_count_neurons layer_t%default_real_count_neurons none~count_neurons->interface~default_real_count_neurons interface~double_precision_count_neurons layer_t%double_precision_count_neurons none~count_neurons->interface~double_precision_count_neurons interface~default_real_neural_network layer_t%default_real_neural_network none~neural_network~9->interface~default_real_neural_network interface~double_precision_neural_network layer_t%double_precision_neural_network none~neural_network~9->interface~double_precision_neural_network interface~default_real_to_json~5 tensor_map_t%default_real_to_json none~to_json~6->interface~default_real_to_json~5 interface~double_precision_to_json~5 tensor_map_t%double_precision_to_json none~to_json~6->interface~double_precision_to_json~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_from_json.html"},{"title":"default_real_infer – Fiats","text":"module procedure default_real_infer elemental module function default_real_infer(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) Calls proc~~default_real_infer~~CallsGraph proc~default_real_infer default_real_infer none~assert_consistency neural_network_t%assert_consistency proc~default_real_infer->none~assert_consistency none~evaluate activation_t%evaluate proc~default_real_infer->none~evaluate none~map_from_training_range tensor_map_t%map_from_training_range proc~default_real_infer->none~map_from_training_range none~map_to_training_range tensor_map_t%map_to_training_range proc~default_real_infer->none~map_to_training_range values values proc~default_real_infer->values interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency interface~default_real_evaluate activation_t%default_real_evaluate none~evaluate->interface~default_real_evaluate interface~double_precision_evaluate activation_t%double_precision_evaluate none~evaluate->interface~double_precision_evaluate interface~default_real_map_from_training_range tensor_map_t%default_real_map_from_training_range none~map_from_training_range->interface~default_real_map_from_training_range interface~double_precision_map_from_training_range tensor_map_t%double_precision_map_from_training_range none~map_from_training_range->interface~double_precision_map_from_training_range interface~default_real_map_to_training_range tensor_map_t%default_real_map_to_training_range none~map_to_training_range->interface~default_real_map_to_training_range interface~double_precision_map_to_training_range tensor_map_t%double_precision_map_to_training_range none~map_to_training_range->interface~double_precision_map_to_training_range Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_infer.html"},{"title":"default_real_learn – Fiats","text":"module procedure default_real_learn pure module subroutine default_real_learn(self, mini_batches_arr, cost, adam, learning_rate, workspace) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches_arr (:) real, intent(out), optional, allocatable :: cost (:) logical, intent(in) :: adam real, intent(in) :: learning_rate type( workspace_t ), intent(inout) :: workspace Calls proc~~default_real_learn~~CallsGraph proc~default_real_learn default_real_learn assert assert proc~default_real_learn->assert beta beta proc~default_real_learn->beta expected_outputs expected_outputs proc~default_real_learn->expected_outputs inputs inputs proc~default_real_learn->inputs none~assert_consistency neural_network_t%assert_consistency proc~default_real_learn->none~assert_consistency none~differentiate activation_t%differentiate proc~default_real_learn->none~differentiate none~evaluate activation_t%evaluate proc~default_real_learn->none~evaluate none~fully_allocated workspace_t%fully_allocated proc~default_real_learn->none~fully_allocated none~input_output_pairs~3 mini_batch_t%input_output_pairs proc~default_real_learn->none~input_output_pairs~3 none~num_hidden_layers~2 neural_network_t%num_hidden_layers proc~default_real_learn->none~num_hidden_layers~2 none~num_inputs~6 neural_network_t%num_inputs proc~default_real_learn->none~num_inputs~6 none~values tensor_t%values proc~default_real_learn->none~values obeta obeta proc~default_real_learn->obeta pair_cost pair_cost proc~default_real_learn->pair_cost reduce_dcdb reduce_dcdb proc~default_real_learn->reduce_dcdb reduce_dcdw reduce_dcdw proc~default_real_learn->reduce_dcdw interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency interface~default_real_differentiate activation_t%default_real_differentiate none~differentiate->interface~default_real_differentiate interface~double_precision_differentiate activation_t%double_precision_differentiate none~differentiate->interface~double_precision_differentiate interface~default_real_evaluate activation_t%default_real_evaluate none~evaluate->interface~default_real_evaluate interface~double_precision_evaluate activation_t%double_precision_evaluate none~evaluate->interface~double_precision_evaluate interface~default_real_allocated workspace_t%default_real_allocated none~fully_allocated->interface~default_real_allocated interface~default_real_input_output_pairs mini_batch_t%default_real_input_output_pairs none~input_output_pairs~3->interface~default_real_input_output_pairs interface~double_precision_input_output_pairs mini_batch_t%double_precision_input_output_pairs none~input_output_pairs~3->interface~double_precision_input_output_pairs interface~default_real_num_hidden_layers neural_network_t%default_real_num_hidden_layers none~num_hidden_layers~2->interface~default_real_num_hidden_layers interface~double_precision_num_hidden_layers neural_network_t%double_precision_num_hidden_layers none~num_hidden_layers~2->interface~double_precision_num_hidden_layers interface~default_real_num_inputs~2 neural_network_t%default_real_num_inputs none~num_inputs~6->interface~default_real_num_inputs~2 interface~double_precision_num_inputs~2 neural_network_t%double_precision_num_inputs none~num_inputs~6->interface~double_precision_num_inputs~2 interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_learn.html"},{"title":"default_real_map_from_output_range – Fiats","text":"module procedure default_real_map_from_output_range elemental module function default_real_map_from_output_range(self, normalized_tensor) result(tensor) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self type( tensor_t ), intent(in) :: normalized_tensor Return Value type( tensor_t ) Calls proc~~default_real_map_from_output_range~~CallsGraph proc~default_real_map_from_output_range default_real_map_from_output_range none~map_from_training_range tensor_map_t%map_from_training_range proc~default_real_map_from_output_range->none~map_from_training_range interface~default_real_map_from_training_range tensor_map_t%default_real_map_from_training_range none~map_from_training_range->interface~default_real_map_from_training_range interface~double_precision_map_from_training_range tensor_map_t%double_precision_map_from_training_range none~map_from_training_range->interface~double_precision_map_from_training_range Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_map_from_output_range.html"},{"title":"default_real_map_to_input_range – Fiats","text":"module procedure default_real_map_to_input_range elemental module function default_real_map_to_input_range(self, tensor) result(normalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) Calls proc~~default_real_map_to_input_range~~CallsGraph proc~default_real_map_to_input_range default_real_map_to_input_range none~map_to_training_range tensor_map_t%map_to_training_range proc~default_real_map_to_input_range->none~map_to_training_range interface~default_real_map_to_training_range tensor_map_t%default_real_map_to_training_range none~map_to_training_range->interface~default_real_map_to_training_range interface~double_precision_map_to_training_range tensor_map_t%double_precision_map_to_training_range none~map_to_training_range->interface~double_precision_map_to_training_range Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_map_to_input_range.html"},{"title":"default_real_nodes_per_layer – Fiats","text":"module procedure default_real_nodes_per_layer pure module function default_real_nodes_per_layer(self) result(node_count) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value integer, allocatable, (:) Calls proc~~default_real_nodes_per_layer~~CallsGraph proc~default_real_nodes_per_layer default_real_nodes_per_layer none~assert_consistency neural_network_t%assert_consistency proc~default_real_nodes_per_layer->none~assert_consistency interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_nodes_per_layer.html"},{"title":"default_real_num_hidden_layers – Fiats","text":"module procedure default_real_num_hidden_layers elemental module function default_real_num_hidden_layers(self) result(hidden_layer_count) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value integer Calls proc~~default_real_num_hidden_layers~~CallsGraph proc~default_real_num_hidden_layers default_real_num_hidden_layers none~assert_consistency neural_network_t%assert_consistency proc~default_real_num_hidden_layers->none~assert_consistency interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_num_hidden_layers.html"},{"title":"default_real_num_inputs – Fiats","text":"module procedure default_real_num_inputs elemental module function default_real_num_inputs(self) result(input_count) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value integer Calls proc~~default_real_num_inputs~~CallsGraph proc~default_real_num_inputs default_real_num_inputs none~assert_consistency neural_network_t%assert_consistency proc~default_real_num_inputs->none~assert_consistency interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_num_inputs.html"},{"title":"default_real_num_outputs – Fiats","text":"module procedure default_real_num_outputs elemental module function default_real_num_outputs(self) result(output_count) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value integer Calls proc~~default_real_num_outputs~~CallsGraph proc~default_real_num_outputs default_real_num_outputs none~assert_consistency neural_network_t%assert_consistency proc~default_real_num_outputs->none~assert_consistency interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_num_outputs.html"},{"title":"default_real_skip – Fiats","text":"module procedure default_real_skip pure module function default_real_skip(self) result(use_skip_connections) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value logical Calls proc~~default_real_skip~~CallsGraph proc~default_real_skip default_real_skip interface~strings metadata_t%strings proc~default_real_skip->interface~strings Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_skip.html"},{"title":"default_real_to_json – Fiats","text":"module procedure default_real_to_json impure elemental module function default_real_to_json(self) result(json_file) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value type(file_t) Calls proc~~default_real_to_json~~CallsGraph proc~default_real_to_json default_real_to_json assert assert proc~default_real_to_json->assert file_t file_t proc~default_real_to_json->file_t interface~to_json~2 metadata_t%to_json proc~default_real_to_json->interface~to_json~2 intrinsic_array_t intrinsic_array_t proc~default_real_to_json->intrinsic_array_t lines lines proc~default_real_to_json->lines none~assert_consistency neural_network_t%assert_consistency proc~default_real_to_json->none~assert_consistency none~num_hidden_layers~2 neural_network_t%num_hidden_layers proc~default_real_to_json->none~num_hidden_layers~2 none~num_inputs~6 neural_network_t%num_inputs proc~default_real_to_json->none~num_inputs~6 none~num_outputs neural_network_t%num_outputs proc~default_real_to_json->none~num_outputs string_t string_t proc~default_real_to_json->string_t interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency interface~default_real_num_hidden_layers neural_network_t%default_real_num_hidden_layers none~num_hidden_layers~2->interface~default_real_num_hidden_layers interface~double_precision_num_hidden_layers neural_network_t%double_precision_num_hidden_layers none~num_hidden_layers~2->interface~double_precision_num_hidden_layers interface~default_real_num_inputs~2 neural_network_t%default_real_num_inputs none~num_inputs~6->interface~default_real_num_inputs~2 interface~double_precision_num_inputs~2 neural_network_t%double_precision_num_inputs none~num_inputs~6->interface~double_precision_num_inputs~2 interface~default_real_num_outputs neural_network_t%default_real_num_outputs none~num_outputs->interface~default_real_num_outputs interface~double_precision_num_outputs neural_network_t%double_precision_num_outputs none~num_outputs->interface~double_precision_num_outputs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_to_json.html"},{"title":"double_precision_activation_name – Fiats","text":"module procedure double_precision_activation_name elemental module function double_precision_activation_name(self) result(activation_name) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value type(string_t) Calls proc~~double_precision_activation_name~~CallsGraph proc~double_precision_activation_name double_precision_activation_name interface~strings metadata_t%strings proc~double_precision_activation_name->interface~strings Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_activation_name.html"},{"title":"double_precision_approximately_equal – Fiats","text":"module procedure double_precision_approximately_equal elemental module function double_precision_approximately_equal(lhs, rhs) result(lhs_eq_rhs) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: lhs class( neural_network_t (double_precision)), intent(in) :: rhs Return Value logical Calls proc~~double_precision_approximately_equal~~CallsGraph proc~double_precision_approximately_equal double_precision_approximately_equal layer_eq layer_eq proc~double_precision_approximately_equal->layer_eq none~assert_conformable_with neural_network_t%assert_conformable_with proc~double_precision_approximately_equal->none~assert_conformable_with none~assert_consistency neural_network_t%assert_consistency proc~double_precision_approximately_equal->none~assert_consistency interface~default_real_assert_conformable_with neural_network_t%default_real_assert_conformable_with none~assert_conformable_with->interface~default_real_assert_conformable_with interface~double_precision_assert_conformable_with neural_network_t%double_precision_assert_conformable_with none~assert_conformable_with->interface~double_precision_assert_conformable_with interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_approximately_equal.html"},{"title":"double_precision_assert_conformable_with – Fiats","text":"module procedure double_precision_assert_conformable_with elemental module subroutine double_precision_assert_conformable_with(self, neural_network) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self type( neural_network_t (double_precision)), intent(in) :: neural_network Calls proc~~double_precision_assert_conformable_with~~CallsGraph proc~double_precision_assert_conformable_with double_precision_assert_conformable_with assert assert proc~double_precision_assert_conformable_with->assert intrinsic_array_t intrinsic_array_t proc~double_precision_assert_conformable_with->intrinsic_array_t none~assert_consistency neural_network_t%assert_consistency proc~double_precision_assert_conformable_with->none~assert_consistency interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_assert_conformable_with.html"},{"title":"double_precision_consistency – Fiats","text":"module procedure double_precision_consistency pure module subroutine double_precision_consistency(self) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Calls proc~~double_precision_consistency~~CallsGraph proc~double_precision_consistency double_precision_consistency assert assert proc~double_precision_consistency->assert intrinsic_array_t intrinsic_array_t proc~double_precision_consistency->intrinsic_array_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_consistency.html"},{"title":"double_precision_construct_from_components – Fiats","text":"module procedure double_precision_construct_from_components module function double_precision_construct_from_components(metadata, weights, biases, nodes, input_map, output_map) result(neural_network) Arguments Type Intent Optional Attributes Name type( metadata_t ), intent(in) :: metadata double precision, intent(in) :: weights (:,:,:) double precision, intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) type( tensor_map_t (double_precision)), intent(in), optional :: input_map type( tensor_map_t (double_precision)), intent(in), optional :: output_map Return Value type( neural_network_t (double_precision)) Calls proc~~double_precision_construct_from_components~~CallsGraph proc~double_precision_construct_from_components double_precision_construct_from_components interface~activation_name~2 metadata_t%activation_name proc~double_precision_construct_from_components->interface~activation_name~2 none~assert_consistency neural_network_t%assert_consistency proc~double_precision_construct_from_components->none~assert_consistency string string proc~double_precision_construct_from_components->string interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_construct_from_components.html"},{"title":"double_precision_from_json – Fiats","text":"module procedure double_precision_from_json impure elemental module function double_precision_from_json(file) result(neural_network) Arguments Type Intent Optional Attributes Name type( double_precision_file_t ), intent(in) :: file Return Value type( neural_network_t (double_precision)) Calls proc~~double_precision_from_json~~CallsGraph proc~double_precision_from_json double_precision_from_json assert assert proc~double_precision_from_json->assert get_json_value get_json_value proc~double_precision_from_json->get_json_value interface~activation_name~2 metadata_t%activation_name proc~double_precision_from_json->interface~activation_name~2 interface~double_precision_lines double_precision_file_t%double_precision_lines proc~double_precision_from_json->interface~double_precision_lines none~assert_consistency neural_network_t%assert_consistency proc~double_precision_from_json->none~assert_consistency none~count_layers layer_t%count_layers proc~double_precision_from_json->none~count_layers none~count_neurons layer_t%count_neurons proc~double_precision_from_json->none~count_neurons none~neural_network~9 layer_t%neural_network proc~double_precision_from_json->none~neural_network~9 none~to_json~6 tensor_map_t%to_json proc~double_precision_from_json->none~to_json~6 string string proc~double_precision_from_json->string string_t string_t proc~double_precision_from_json->string_t interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency interface~default_real_count_layers layer_t%default_real_count_layers none~count_layers->interface~default_real_count_layers interface~double_precision_count_layers layer_t%double_precision_count_layers none~count_layers->interface~double_precision_count_layers interface~default_real_count_neurons layer_t%default_real_count_neurons none~count_neurons->interface~default_real_count_neurons interface~double_precision_count_neurons layer_t%double_precision_count_neurons none~count_neurons->interface~double_precision_count_neurons interface~default_real_neural_network layer_t%default_real_neural_network none~neural_network~9->interface~default_real_neural_network interface~double_precision_neural_network layer_t%double_precision_neural_network none~neural_network~9->interface~double_precision_neural_network interface~default_real_to_json~5 tensor_map_t%default_real_to_json none~to_json~6->interface~default_real_to_json~5 interface~double_precision_to_json~5 tensor_map_t%double_precision_to_json none~to_json~6->interface~double_precision_to_json~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_from_json.html"},{"title":"double_precision_infer – Fiats","text":"module procedure double_precision_infer elemental module function double_precision_infer(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: inputs Return Value type( tensor_t (double_precision)) Calls proc~~double_precision_infer~~CallsGraph proc~double_precision_infer double_precision_infer none~assert_consistency neural_network_t%assert_consistency proc~double_precision_infer->none~assert_consistency none~evaluate activation_t%evaluate proc~double_precision_infer->none~evaluate none~map_from_training_range tensor_map_t%map_from_training_range proc~double_precision_infer->none~map_from_training_range none~map_to_training_range tensor_map_t%map_to_training_range proc~double_precision_infer->none~map_to_training_range values values proc~double_precision_infer->values interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency interface~default_real_evaluate activation_t%default_real_evaluate none~evaluate->interface~default_real_evaluate interface~double_precision_evaluate activation_t%double_precision_evaluate none~evaluate->interface~double_precision_evaluate interface~default_real_map_from_training_range tensor_map_t%default_real_map_from_training_range none~map_from_training_range->interface~default_real_map_from_training_range interface~double_precision_map_from_training_range tensor_map_t%double_precision_map_from_training_range none~map_from_training_range->interface~double_precision_map_from_training_range interface~default_real_map_to_training_range tensor_map_t%default_real_map_to_training_range none~map_to_training_range->interface~default_real_map_to_training_range interface~double_precision_map_to_training_range tensor_map_t%double_precision_map_to_training_range none~map_to_training_range->interface~double_precision_map_to_training_range Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_infer.html"},{"title":"double_precision_map_from_output_range – Fiats","text":"module procedure double_precision_map_from_output_range elemental module function double_precision_map_from_output_range(self, normalized_tensor) result(tensor) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: normalized_tensor Return Value type( tensor_t (double_precision)) Calls proc~~double_precision_map_from_output_range~~CallsGraph proc~double_precision_map_from_output_range double_precision_map_from_output_range none~map_from_training_range tensor_map_t%map_from_training_range proc~double_precision_map_from_output_range->none~map_from_training_range interface~default_real_map_from_training_range tensor_map_t%default_real_map_from_training_range none~map_from_training_range->interface~default_real_map_from_training_range interface~double_precision_map_from_training_range tensor_map_t%double_precision_map_from_training_range none~map_from_training_range->interface~double_precision_map_from_training_range Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_map_from_output_range.html"},{"title":"double_precision_map_to_input_range – Fiats","text":"module procedure double_precision_map_to_input_range elemental module function double_precision_map_to_input_range(self, tensor) result(normalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: tensor Return Value type( tensor_t (double_precision)) Calls proc~~double_precision_map_to_input_range~~CallsGraph proc~double_precision_map_to_input_range double_precision_map_to_input_range none~map_to_training_range tensor_map_t%map_to_training_range proc~double_precision_map_to_input_range->none~map_to_training_range interface~default_real_map_to_training_range tensor_map_t%default_real_map_to_training_range none~map_to_training_range->interface~default_real_map_to_training_range interface~double_precision_map_to_training_range tensor_map_t%double_precision_map_to_training_range none~map_to_training_range->interface~double_precision_map_to_training_range Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_map_to_input_range.html"},{"title":"double_precision_nodes_per_layer – Fiats","text":"module procedure double_precision_nodes_per_layer pure module function double_precision_nodes_per_layer(self) result(node_count) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value integer, allocatable, (:) Calls proc~~double_precision_nodes_per_layer~~CallsGraph proc~double_precision_nodes_per_layer double_precision_nodes_per_layer none~assert_consistency neural_network_t%assert_consistency proc~double_precision_nodes_per_layer->none~assert_consistency interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_nodes_per_layer.html"},{"title":"double_precision_num_hidden_layers – Fiats","text":"module procedure double_precision_num_hidden_layers elemental module function double_precision_num_hidden_layers(self) result(hidden_layer_count) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value integer Calls proc~~double_precision_num_hidden_layers~~CallsGraph proc~double_precision_num_hidden_layers double_precision_num_hidden_layers none~assert_consistency neural_network_t%assert_consistency proc~double_precision_num_hidden_layers->none~assert_consistency interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_num_hidden_layers.html"},{"title":"double_precision_num_inputs – Fiats","text":"module procedure double_precision_num_inputs elemental module function double_precision_num_inputs(self) result(input_count) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value integer Calls proc~~double_precision_num_inputs~~CallsGraph proc~double_precision_num_inputs double_precision_num_inputs none~assert_consistency neural_network_t%assert_consistency proc~double_precision_num_inputs->none~assert_consistency interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_num_inputs.html"},{"title":"double_precision_num_outputs – Fiats","text":"module procedure double_precision_num_outputs elemental module function double_precision_num_outputs(self) result(output_count) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value integer Calls proc~~double_precision_num_outputs~~CallsGraph proc~double_precision_num_outputs double_precision_num_outputs none~assert_consistency neural_network_t%assert_consistency proc~double_precision_num_outputs->none~assert_consistency interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_num_outputs.html"},{"title":"double_precision_skip – Fiats","text":"module procedure double_precision_skip pure module function double_precision_skip(self) result(use_skip_connections) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value logical Calls proc~~double_precision_skip~~CallsGraph proc~double_precision_skip double_precision_skip interface~strings metadata_t%strings proc~double_precision_skip->interface~strings Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_skip.html"},{"title":"double_precision_to_json – Fiats","text":"module procedure double_precision_to_json impure elemental module function double_precision_to_json(self) result(json_file) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value type(file_t) Calls proc~~double_precision_to_json~~CallsGraph proc~double_precision_to_json double_precision_to_json assert assert proc~double_precision_to_json->assert file_t file_t proc~double_precision_to_json->file_t interface~to_json~2 metadata_t%to_json proc~double_precision_to_json->interface~to_json~2 intrinsic_array_t intrinsic_array_t proc~double_precision_to_json->intrinsic_array_t lines lines proc~double_precision_to_json->lines none~assert_consistency neural_network_t%assert_consistency proc~double_precision_to_json->none~assert_consistency none~num_hidden_layers~2 neural_network_t%num_hidden_layers proc~double_precision_to_json->none~num_hidden_layers~2 none~num_inputs~6 neural_network_t%num_inputs proc~double_precision_to_json->none~num_inputs~6 none~num_outputs neural_network_t%num_outputs proc~double_precision_to_json->none~num_outputs string_t string_t proc~double_precision_to_json->string_t interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency interface~default_real_num_hidden_layers neural_network_t%default_real_num_hidden_layers none~num_hidden_layers~2->interface~default_real_num_hidden_layers interface~double_precision_num_hidden_layers neural_network_t%double_precision_num_hidden_layers none~num_hidden_layers~2->interface~double_precision_num_hidden_layers interface~default_real_num_inputs~2 neural_network_t%default_real_num_inputs none~num_inputs~6->interface~default_real_num_inputs~2 interface~double_precision_num_inputs~2 neural_network_t%double_precision_num_inputs none~num_inputs~6->interface~double_precision_num_inputs~2 interface~default_real_num_outputs neural_network_t%default_real_num_outputs none~num_outputs->interface~default_real_num_outputs interface~double_precision_num_outputs neural_network_t%double_precision_num_outputs none~num_outputs->interface~double_precision_num_outputs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_to_json.html"},{"title":"construct_from_string – Fiats","text":"module procedure construct_from_string elemental module function construct_from_string(string) result(double_precision_string) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: string Return Value type( double_precision_string_t )","tags":"","loc":"proc/construct_from_string.html"},{"title":"construct_from_character – Fiats","text":"module procedure construct_from_character impure elemental module function construct_from_character(file_name) result(double_precision_file) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value type( double_precision_file_t ) Calls proc~~construct_from_character~~CallsGraph proc~construct_from_character construct_from_character file_t file_t proc~construct_from_character->file_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/construct_from_character.html"},{"title":"construct_from_string – Fiats","text":"module procedure construct_from_string impure elemental module function construct_from_string(file_name) result(double_precision_file) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: file_name Return Value type( double_precision_file_t ) Calls proc~~construct_from_string~2~~CallsGraph proc~construct_from_string~2 construct_from_string file_t file_t proc~construct_from_string~2->file_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/construct_from_string~2.html"},{"title":"double_precision_lines – Fiats","text":"module procedure double_precision_lines pure module function double_precision_lines(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( double_precision_file_t ), intent(in) :: self Return Value type( double_precision_string_t ), allocatable, (:) Calls proc~~double_precision_lines~~CallsGraph proc~double_precision_lines double_precision_lines lines lines proc~double_precision_lines->lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_lines.html"},{"title":"default_real_map_to_training_ranges – Fiats","text":"module procedure default_real_map_to_training_ranges elemental module function default_real_map_to_training_ranges(self, input_output_pair) result(normalized_input_output_pair) Interface → Arguments Type Intent Optional Attributes Name class( trainable_network_t ), intent(in) :: self type( input_output_pair_t ), intent(in) :: input_output_pair Return Value type( input_output_pair_t ) Calls proc~~default_real_map_to_training_ranges~~CallsGraph proc~default_real_map_to_training_ranges default_real_map_to_training_ranges map_to_training_range map_to_training_range proc~default_real_map_to_training_ranges->map_to_training_range none~expected_outputs~2 input_output_pair_t%expected_outputs proc~default_real_map_to_training_ranges->none~expected_outputs~2 none~inputs~3 input_output_pair_t%inputs proc~default_real_map_to_training_ranges->none~inputs~3 interface~default_real_expected_outputs input_output_pair_t%default_real_expected_outputs none~expected_outputs~2->interface~default_real_expected_outputs interface~double_precision_expected_outputs input_output_pair_t%double_precision_expected_outputs none~expected_outputs~2->interface~double_precision_expected_outputs interface~default_real_inputs input_output_pair_t%default_real_inputs none~inputs~3->interface~default_real_inputs interface~double_precision_inputs input_output_pair_t%double_precision_inputs none~inputs~3->interface~double_precision_inputs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_map_to_training_ranges.html"},{"title":"default_real_network – Fiats","text":"module procedure default_real_network pure module function default_real_network(neural_network) result(trainable_network) Arguments Type Intent Optional Attributes Name type( neural_network_t ), intent(in) :: neural_network Return Value type( trainable_network_t )","tags":"","loc":"proc/default_real_network.html"},{"title":"default_real_train – Fiats","text":"module procedure default_real_train pure module subroutine default_real_train(self, mini_batches_arr, cost, adam, learning_rate) Interface → Arguments Type Intent Optional Attributes Name class( trainable_network_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches_arr (:) real, intent(out), optional, allocatable :: cost (:) logical, intent(in) :: adam real, intent(in) :: learning_rate Calls proc~~default_real_train~~CallsGraph proc~default_real_train default_real_train none~learn~2 trainable_network_t%learn proc~default_real_train->none~learn~2 interface~default_real_learn neural_network_t%default_real_learn none~learn~2->interface~default_real_learn Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_train.html"},{"title":"perturbed_identity_network – Fiats","text":"module procedure perturbed_identity_network module function perturbed_identity_network(training_configuration, perturbation_magnitude, metadata, input_map, output_map) result(trainable_network) Arguments Type Intent Optional Attributes Name type( training_configuration_t ), intent(in) :: training_configuration real, intent(in) :: perturbation_magnitude type(string_t), intent(in) :: metadata (:) type( tensor_map_t ) :: input_map type( tensor_map_t ) :: output_map Return Value type( trainable_network_t ) Calls proc~~perturbed_identity_network~5~~CallsGraph proc~perturbed_identity_network~5 perturbed_identity_network none~nodes_per_layer~2 training_configuration_t%nodes_per_layer proc~perturbed_identity_network~5->none~nodes_per_layer~2 interface~default_real_nodes_per_layer training_configuration_t%default_real_nodes_per_layer none~nodes_per_layer~2->interface~default_real_nodes_per_layer interface~double_precision_nodes_per_layer training_configuration_t%double_precision_nodes_per_layer none~nodes_per_layer~2->interface~double_precision_nodes_per_layer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network~5.html"},{"title":"construct_default_real – Fiats","text":"module procedure construct_default_real pure module function construct_default_real(layer, minima, maxima) result(tensor_map) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: layer real, intent(in), dimension(:) :: minima real, intent(in), dimension(:) :: maxima Return Value type( tensor_map_t ) Calls proc~~construct_default_real~2~~CallsGraph proc~construct_default_real~2 construct_default_real assert assert proc~construct_default_real~2->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/construct_default_real~2.html"},{"title":"construct_double_precision – Fiats","text":"module procedure construct_double_precision pure module function construct_double_precision(layer, minima, maxima) result(tensor_map) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: layer double precision, intent(in), dimension(:) :: minima double precision, intent(in), dimension(:) :: maxima Return Value type( tensor_map_t (double_precision)) Calls proc~~construct_double_precision~2~~CallsGraph proc~construct_double_precision~2 construct_double_precision assert assert proc~construct_double_precision~2->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/construct_double_precision~2.html"},{"title":"default_real_equals – Fiats","text":"module procedure default_real_equals elemental module function default_real_equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( tensor_map_t ), intent(in) :: lhs class( tensor_map_t ), intent(in) :: rhs Return Value logical Calls proc~~default_real_equals~~CallsGraph proc~default_real_equals default_real_equals assert assert proc~default_real_equals->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_equals.html"},{"title":"default_real_map_from_training_range – Fiats","text":"module procedure default_real_map_from_training_range elemental module function default_real_map_from_training_range(self, tensor) result(unnormalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( tensor_map_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) Calls proc~~default_real_map_from_training_range~~CallsGraph proc~default_real_map_from_training_range default_real_map_from_training_range none~values tensor_t%values proc~default_real_map_from_training_range->none~values interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_map_from_training_range.html"},{"title":"default_real_map_to_training_range – Fiats","text":"module procedure default_real_map_to_training_range elemental module function default_real_map_to_training_range(self, tensor) result(normalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( tensor_map_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) Calls proc~~default_real_map_to_training_range~~CallsGraph proc~default_real_map_to_training_range default_real_map_to_training_range none~values tensor_t%values proc~default_real_map_to_training_range->none~values interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_map_to_training_range.html"},{"title":"default_real_to_json – Fiats","text":"module procedure default_real_to_json pure module function default_real_to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( tensor_map_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Calls proc~~default_real_to_json~2~~CallsGraph proc~default_real_to_json~2 default_real_to_json assert assert proc~default_real_to_json~2->assert separated_values separated_values proc~default_real_to_json~2->separated_values string_t string_t proc~default_real_to_json~2->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_to_json~2.html"},{"title":"double_precision_equals – Fiats","text":"module procedure double_precision_equals elemental module function double_precision_equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( tensor_map_t (double_precision)), intent(in) :: lhs class( tensor_map_t (double_precision)), intent(in) :: rhs Return Value logical Calls proc~~double_precision_equals~~CallsGraph proc~double_precision_equals double_precision_equals assert assert proc~double_precision_equals->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_equals.html"},{"title":"double_precision_from_json – Fiats","text":"module procedure double_precision_from_json module function double_precision_from_json(lines) result(tensor_map) Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: lines (:) Return Value type( tensor_map_t (double_precision)) Calls proc~~double_precision_from_json~2~~CallsGraph proc~double_precision_from_json~2 double_precision_from_json assert assert proc~double_precision_from_json~2->assert get_json_key get_json_key proc~double_precision_from_json~2->get_json_key get_json_value get_json_value proc~double_precision_from_json~2->get_json_value string_t string_t proc~double_precision_from_json~2->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_from_json~2.html"},{"title":"double_precision_map_from_training_range – Fiats","text":"module procedure double_precision_map_from_training_range elemental module function double_precision_map_from_training_range(self, tensor) result(unnormalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( tensor_map_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: tensor Return Value type( tensor_t (double_precision)) Calls proc~~double_precision_map_from_training_range~~CallsGraph proc~double_precision_map_from_training_range double_precision_map_from_training_range none~values tensor_t%values proc~double_precision_map_from_training_range->none~values interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_map_from_training_range.html"},{"title":"double_precision_map_to_training_range – Fiats","text":"module procedure double_precision_map_to_training_range elemental module function double_precision_map_to_training_range(self, tensor) result(normalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( tensor_map_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: tensor Return Value type( tensor_t (double_precision)) Calls proc~~double_precision_map_to_training_range~~CallsGraph proc~double_precision_map_to_training_range double_precision_map_to_training_range none~values tensor_t%values proc~double_precision_map_to_training_range->none~values interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_map_to_training_range.html"},{"title":"double_precision_to_json – Fiats","text":"module procedure double_precision_to_json pure module function double_precision_to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( tensor_map_t (double_precision)), intent(in) :: self Return Value type(string_t), allocatable, (:) Calls proc~~double_precision_to_json~2~~CallsGraph proc~double_precision_to_json~2 double_precision_to_json assert assert proc~double_precision_to_json~2->assert separated_values separated_values proc~double_precision_to_json~2->separated_values string_t string_t proc~double_precision_to_json~2->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_to_json~2.html"},{"title":"from_json – Fiats","text":"module procedure from_json module function from_json(lines) result(tensor_map) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( tensor_map_t ) Calls proc~~from_json~~CallsGraph proc~from_json from_json assert assert proc~from_json->assert get_json_key get_json_key proc~from_json->get_json_key get_json_value get_json_value proc~from_json->get_json_value string_t string_t proc~from_json->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/from_json.html"},{"title":"default_real_construct – Fiats","text":"module procedure default_real_construct elemental module function default_real_construct(inputs, expected_outputs) result(input_output_pair) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t )","tags":"","loc":"proc/default_real_construct.html"},{"title":"default_real_expected_outputs – Fiats","text":"module procedure default_real_expected_outputs elemental module function default_real_expected_outputs(self) result(my_expected_outputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"proc/default_real_expected_outputs.html"},{"title":"default_real_inputs – Fiats","text":"module procedure default_real_inputs elemental module function default_real_inputs(self) result(my_inputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"proc/default_real_inputs.html"},{"title":"default_real_shuffle – Fiats","text":"module procedure default_real_shuffle module subroutine default_real_shuffle(pairs) Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(inout) :: pairs (:)","tags":"","loc":"proc/default_real_shuffle.html"},{"title":"default_real_write_to_stdout – Fiats","text":"module procedure default_real_write_to_stdout module subroutine default_real_write_to_stdout(input_output_pairs) Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Calls proc~~default_real_write_to_stdout~~CallsGraph proc~default_real_write_to_stdout default_real_write_to_stdout none~values tensor_t%values proc~default_real_write_to_stdout->none~values interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_write_to_stdout.html"},{"title":"double_precision_construct – Fiats","text":"module procedure double_precision_construct elemental module function double_precision_construct(inputs, expected_outputs) result(input_output_pair) Arguments Type Intent Optional Attributes Name type( tensor_t (double_precision)), intent(in) :: inputs type( tensor_t (double_precision)), intent(in) :: expected_outputs Return Value type( input_output_pair_t (double_precision))","tags":"","loc":"proc/double_precision_construct.html"},{"title":"double_precision_expected_outputs – Fiats","text":"module procedure double_precision_expected_outputs elemental module function double_precision_expected_outputs(self) result(my_expected_outputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t (double_precision)), intent(in) :: self Return Value type( tensor_t (double_precision))","tags":"","loc":"proc/double_precision_expected_outputs.html"},{"title":"double_precision_inputs – Fiats","text":"module procedure double_precision_inputs elemental module function double_precision_inputs(self) result(my_inputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t (double_precision)), intent(in) :: self Return Value type( tensor_t (double_precision))","tags":"","loc":"proc/double_precision_inputs.html"},{"title":"double_precision_shuffle – Fiats","text":"module procedure double_precision_shuffle module subroutine double_precision_shuffle(pairs) Arguments Type Intent Optional Attributes Name type( input_output_pair_t (double_precision)), intent(inout) :: pairs (:)","tags":"","loc":"proc/double_precision_shuffle.html"},{"title":"double_precision_write_to_stdout – Fiats","text":"module procedure double_precision_write_to_stdout module subroutine double_precision_write_to_stdout(input_output_pairs) Arguments Type Intent Optional Attributes Name type( input_output_pair_t (double_precision)), intent(in) :: input_output_pairs (:) Calls proc~~double_precision_write_to_stdout~~CallsGraph proc~double_precision_write_to_stdout double_precision_write_to_stdout none~values tensor_t%values proc~double_precision_write_to_stdout->none~values interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_write_to_stdout.html"},{"title":"default_real_infer_unmapped – Fiats","text":"module procedure default_real_infer_unmapped elemental module function default_real_infer_unmapped(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( unmapped_network_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) Calls proc~~default_real_infer_unmapped~~CallsGraph proc~default_real_infer_unmapped default_real_infer_unmapped matmul+b matmul+b proc~default_real_infer_unmapped->matmul+b none~assert_consistency neural_network_t%assert_consistency proc~default_real_infer_unmapped->none~assert_consistency none~evaluate activation_t%evaluate proc~default_real_infer_unmapped->none~evaluate none~values tensor_t%values proc~default_real_infer_unmapped->none~values interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency interface~default_real_evaluate activation_t%default_real_evaluate none~evaluate->interface~default_real_evaluate interface~double_precision_evaluate activation_t%double_precision_evaluate none~evaluate->interface~double_precision_evaluate interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_infer_unmapped.html"},{"title":"double_precision_infer_unmapped – Fiats","text":"module procedure double_precision_infer_unmapped elemental module function double_precision_infer_unmapped(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( unmapped_network_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: inputs Return Value type( tensor_t (double_precision)) Calls proc~~double_precision_infer_unmapped~~CallsGraph proc~double_precision_infer_unmapped double_precision_infer_unmapped matmul+b matmul+b proc~double_precision_infer_unmapped->matmul+b none~assert_consistency neural_network_t%assert_consistency proc~double_precision_infer_unmapped->none~assert_consistency none~evaluate activation_t%evaluate proc~double_precision_infer_unmapped->none~evaluate none~values tensor_t%values proc~double_precision_infer_unmapped->none~values interface~default_real_consistency neural_network_t%default_real_consistency none~assert_consistency->interface~default_real_consistency interface~double_precision_consistency neural_network_t%double_precision_consistency none~assert_consistency->interface~double_precision_consistency interface~default_real_evaluate activation_t%default_real_evaluate none~evaluate->interface~default_real_evaluate interface~double_precision_evaluate activation_t%double_precision_evaluate none~evaluate->interface~double_precision_evaluate interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_infer_unmapped.html"},{"title":"double_precision_unmapped_from_json – Fiats","text":"module procedure double_precision_unmapped_from_json impure elemental module function double_precision_unmapped_from_json(file) result(unmapped_network) Arguments Type Intent Optional Attributes Name type( double_precision_file_t ), intent(in) :: file Return Value type( unmapped_network_t (double_precision))","tags":"","loc":"proc/double_precision_unmapped_from_json.html"},{"title":"default_real_construct_layer – Fiats","text":"module procedure default_real_construct_layer recursive module function default_real_construct_layer(layer_lines, start) result(layer) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ), target Calls proc~~default_real_construct_layer~~CallsGraph proc~default_real_construct_layer default_real_construct_layer assert assert proc~default_real_construct_layer->assert none~next_allocated~2 neuron_t%next_allocated proc~default_real_construct_layer->none~next_allocated~2 none~next_pointer~2 neuron_t%next_pointer proc~default_real_construct_layer->none~next_pointer~2 none~weights neuron_t%weights proc~default_real_construct_layer->none~weights string string proc~default_real_construct_layer->string interface~default_real_next_allocated~2 neuron_t%default_real_next_allocated none~next_allocated~2->interface~default_real_next_allocated~2 interface~double_precision_next_allocated~2 neuron_t%double_precision_next_allocated none~next_allocated~2->interface~double_precision_next_allocated~2 interface~default_real_next_pointer~2 neuron_t%default_real_next_pointer none~next_pointer~2->interface~default_real_next_pointer~2 interface~double_precision_next_pointer~2 neuron_t%double_precision_next_pointer none~next_pointer~2->interface~double_precision_next_pointer~2 interface~default_real_weights neuron_t%default_real_weights none~weights->interface~default_real_weights interface~double_precision_weights neuron_t%double_precision_weights none~weights->interface~double_precision_weights Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_construct_layer.html"},{"title":"default_real_count_inputs – Fiats","text":"module procedure default_real_count_inputs module function default_real_count_inputs(layer) result(num_inputs) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer Calls proc~~default_real_count_inputs~~CallsGraph proc~default_real_count_inputs default_real_count_inputs none~num_inputs~5 neuron_t%num_inputs proc~default_real_count_inputs->none~num_inputs~5 interface~default_real_num_inputs neuron_t%default_real_num_inputs none~num_inputs~5->interface~default_real_num_inputs interface~double_precision_num_inputs neuron_t%double_precision_num_inputs none~num_inputs~5->interface~double_precision_num_inputs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_count_inputs.html"},{"title":"default_real_count_layers – Fiats","text":"module procedure default_real_count_layers module function default_real_count_layers(layer) result(num_layers) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer","tags":"","loc":"proc/default_real_count_layers.html"},{"title":"default_real_count_neurons – Fiats","text":"module procedure default_real_count_neurons module function default_real_count_neurons(layer) result(neurons_per_layer_result) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer, allocatable, (:) Calls proc~~default_real_count_neurons~~CallsGraph proc~default_real_count_neurons default_real_count_neurons none~next_allocated~2 neuron_t%next_allocated proc~default_real_count_neurons->none~next_allocated~2 none~next_pointer~2 neuron_t%next_pointer proc~default_real_count_neurons->none~next_pointer~2 interface~default_real_next_allocated~2 neuron_t%default_real_next_allocated none~next_allocated~2->interface~default_real_next_allocated~2 interface~double_precision_next_allocated~2 neuron_t%double_precision_next_allocated none~next_allocated~2->interface~double_precision_next_allocated~2 interface~default_real_next_pointer~2 neuron_t%default_real_next_pointer none~next_pointer~2->interface~default_real_next_pointer~2 interface~double_precision_next_pointer~2 neuron_t%double_precision_next_pointer none~next_pointer~2->interface~double_precision_next_pointer~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_count_neurons.html"},{"title":"default_real_neural_network – Fiats","text":"module procedure default_real_neural_network module function default_real_neural_network(hidden_layers, metadata, output_layer, input_map, output_map) result(neural_network_) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer type( tensor_map_t ), intent(in) :: input_map type( tensor_map_t ), intent(in) :: output_map Return Value type( neural_network_t ) Calls proc~~default_real_neural_network~~CallsGraph proc~default_real_neural_network default_real_neural_network assert assert proc~default_real_neural_network->assert bias bias proc~default_real_neural_network->bias biases biases proc~default_real_neural_network->biases next_allocated next_allocated proc~default_real_neural_network->next_allocated next_pointer next_pointer proc~default_real_neural_network->next_pointer none~count_inputs layer_t%count_inputs proc~default_real_neural_network->none~count_inputs none~count_layers layer_t%count_layers proc~default_real_neural_network->none~count_layers none~count_neurons layer_t%count_neurons proc~default_real_neural_network->none~count_neurons weights weights proc~default_real_neural_network->weights interface~default_real_count_inputs layer_t%default_real_count_inputs none~count_inputs->interface~default_real_count_inputs interface~double_precision_count_inputs layer_t%double_precision_count_inputs none~count_inputs->interface~double_precision_count_inputs interface~default_real_count_layers layer_t%default_real_count_layers none~count_layers->interface~default_real_count_layers interface~double_precision_count_layers layer_t%double_precision_count_layers none~count_layers->interface~double_precision_count_layers interface~default_real_count_neurons layer_t%default_real_count_neurons none~count_neurons->interface~default_real_count_neurons interface~double_precision_count_neurons layer_t%double_precision_count_neurons none~count_neurons->interface~double_precision_count_neurons Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_neural_network.html"},{"title":"default_real_neurons_per_layer – Fiats","text":"module procedure default_real_neurons_per_layer module function default_real_neurons_per_layer(self) result(num_neurons) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer Calls proc~~default_real_neurons_per_layer~~CallsGraph proc~default_real_neurons_per_layer default_real_neurons_per_layer none~next_allocated~2 neuron_t%next_allocated proc~default_real_neurons_per_layer->none~next_allocated~2 none~next_pointer~2 neuron_t%next_pointer proc~default_real_neurons_per_layer->none~next_pointer~2 interface~default_real_next_allocated~2 neuron_t%default_real_next_allocated none~next_allocated~2->interface~default_real_next_allocated~2 interface~double_precision_next_allocated~2 neuron_t%double_precision_next_allocated none~next_allocated~2->interface~double_precision_next_allocated~2 interface~default_real_next_pointer~2 neuron_t%default_real_next_pointer none~next_pointer~2->interface~default_real_next_pointer~2 interface~double_precision_next_pointer~2 neuron_t%double_precision_next_pointer none~next_pointer~2->interface~double_precision_next_pointer~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_neurons_per_layer.html"},{"title":"default_real_next_allocated – Fiats","text":"module procedure default_real_next_allocated module function default_real_next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical","tags":"","loc":"proc/default_real_next_allocated.html"},{"title":"default_real_next_pointer – Fiats","text":"module procedure default_real_next_pointer module function default_real_next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ), pointer","tags":"","loc":"proc/default_real_next_pointer.html"},{"title":"double_precision_construct_layer – Fiats","text":"module procedure double_precision_construct_layer recursive module function double_precision_construct_layer(layer_lines, start) result(layer) Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t (double_precision)), target Calls proc~~double_precision_construct_layer~~CallsGraph proc~double_precision_construct_layer double_precision_construct_layer assert assert proc~double_precision_construct_layer->assert none~next_allocated~2 neuron_t%next_allocated proc~double_precision_construct_layer->none~next_allocated~2 none~next_pointer~2 neuron_t%next_pointer proc~double_precision_construct_layer->none~next_pointer~2 none~weights neuron_t%weights proc~double_precision_construct_layer->none~weights string string proc~double_precision_construct_layer->string interface~default_real_next_allocated~2 neuron_t%default_real_next_allocated none~next_allocated~2->interface~default_real_next_allocated~2 interface~double_precision_next_allocated~2 neuron_t%double_precision_next_allocated none~next_allocated~2->interface~double_precision_next_allocated~2 interface~default_real_next_pointer~2 neuron_t%default_real_next_pointer none~next_pointer~2->interface~default_real_next_pointer~2 interface~double_precision_next_pointer~2 neuron_t%double_precision_next_pointer none~next_pointer~2->interface~double_precision_next_pointer~2 interface~default_real_weights neuron_t%default_real_weights none~weights->interface~default_real_weights interface~double_precision_weights neuron_t%double_precision_weights none~weights->interface~double_precision_weights Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_construct_layer.html"},{"title":"double_precision_count_inputs – Fiats","text":"module procedure double_precision_count_inputs module function double_precision_count_inputs(layer) result(num_inputs) Interface → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in) :: layer Return Value integer Calls proc~~double_precision_count_inputs~~CallsGraph proc~double_precision_count_inputs double_precision_count_inputs none~num_inputs~5 neuron_t%num_inputs proc~double_precision_count_inputs->none~num_inputs~5 interface~default_real_num_inputs neuron_t%default_real_num_inputs none~num_inputs~5->interface~default_real_num_inputs interface~double_precision_num_inputs neuron_t%double_precision_num_inputs none~num_inputs~5->interface~double_precision_num_inputs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_count_inputs.html"},{"title":"double_precision_count_layers – Fiats","text":"module procedure double_precision_count_layers module function double_precision_count_layers(layer) result(num_layers) Interface → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: layer Return Value integer","tags":"","loc":"proc/double_precision_count_layers.html"},{"title":"double_precision_count_neurons – Fiats","text":"module procedure double_precision_count_neurons module function double_precision_count_neurons(layer) result(neurons_per_layer_result) Interface → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: layer Return Value integer, allocatable, (:) Calls proc~~double_precision_count_neurons~~CallsGraph proc~double_precision_count_neurons double_precision_count_neurons none~next_allocated~2 neuron_t%next_allocated proc~double_precision_count_neurons->none~next_allocated~2 none~next_pointer~2 neuron_t%next_pointer proc~double_precision_count_neurons->none~next_pointer~2 interface~default_real_next_allocated~2 neuron_t%default_real_next_allocated none~next_allocated~2->interface~default_real_next_allocated~2 interface~double_precision_next_allocated~2 neuron_t%double_precision_next_allocated none~next_allocated~2->interface~double_precision_next_allocated~2 interface~default_real_next_pointer~2 neuron_t%default_real_next_pointer none~next_pointer~2->interface~default_real_next_pointer~2 interface~double_precision_next_pointer~2 neuron_t%double_precision_next_pointer none~next_pointer~2->interface~double_precision_next_pointer~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_count_neurons.html"},{"title":"double_precision_neural_network – Fiats","text":"module procedure double_precision_neural_network module function double_precision_neural_network(hidden_layers, metadata, output_layer, input_map, output_map) result(neural_network_) Interface → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: hidden_layers type( metadata_t ), intent(in) :: metadata type( layer_t (double_precision)), intent(in), target :: output_layer type( tensor_map_t (double_precision)), intent(in) :: input_map type( tensor_map_t (double_precision)), intent(in) :: output_map Return Value type( neural_network_t (double_precision)) Calls proc~~double_precision_neural_network~~CallsGraph proc~double_precision_neural_network double_precision_neural_network assert assert proc~double_precision_neural_network->assert bias bias proc~double_precision_neural_network->bias biases biases proc~double_precision_neural_network->biases next_allocated next_allocated proc~double_precision_neural_network->next_allocated next_pointer next_pointer proc~double_precision_neural_network->next_pointer none~count_inputs layer_t%count_inputs proc~double_precision_neural_network->none~count_inputs none~count_layers layer_t%count_layers proc~double_precision_neural_network->none~count_layers none~count_neurons layer_t%count_neurons proc~double_precision_neural_network->none~count_neurons weights weights proc~double_precision_neural_network->weights interface~default_real_count_inputs layer_t%default_real_count_inputs none~count_inputs->interface~default_real_count_inputs interface~double_precision_count_inputs layer_t%double_precision_count_inputs none~count_inputs->interface~double_precision_count_inputs interface~default_real_count_layers layer_t%default_real_count_layers none~count_layers->interface~default_real_count_layers interface~double_precision_count_layers layer_t%double_precision_count_layers none~count_layers->interface~double_precision_count_layers interface~default_real_count_neurons layer_t%default_real_count_neurons none~count_neurons->interface~default_real_count_neurons interface~double_precision_count_neurons layer_t%double_precision_count_neurons none~count_neurons->interface~double_precision_count_neurons Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_neural_network.html"},{"title":"double_precision_neurons_per_layer – Fiats","text":"module procedure double_precision_neurons_per_layer module function double_precision_neurons_per_layer(self) result(num_neurons) Interface → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: self Return Value integer Calls proc~~double_precision_neurons_per_layer~~CallsGraph proc~double_precision_neurons_per_layer double_precision_neurons_per_layer none~next_allocated~2 neuron_t%next_allocated proc~double_precision_neurons_per_layer->none~next_allocated~2 none~next_pointer~2 neuron_t%next_pointer proc~double_precision_neurons_per_layer->none~next_pointer~2 interface~default_real_next_allocated~2 neuron_t%default_real_next_allocated none~next_allocated~2->interface~default_real_next_allocated~2 interface~double_precision_next_allocated~2 neuron_t%double_precision_next_allocated none~next_allocated~2->interface~double_precision_next_allocated~2 interface~default_real_next_pointer~2 neuron_t%default_real_next_pointer none~next_pointer~2->interface~default_real_next_pointer~2 interface~double_precision_next_pointer~2 neuron_t%double_precision_next_pointer none~next_pointer~2->interface~double_precision_next_pointer~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_neurons_per_layer.html"},{"title":"double_precision_next_allocated – Fiats","text":"module procedure double_precision_next_allocated module function double_precision_next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in) :: self Return Value logical","tags":"","loc":"proc/double_precision_next_allocated.html"},{"title":"double_precision_next_pointer – Fiats","text":"module procedure double_precision_next_pointer module function double_precision_next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: self Return Value type( layer_t (double_precision)), pointer","tags":"","loc":"proc/double_precision_next_pointer.html"},{"title":"construct_from_component – Fiats","text":"module procedure construct_from_component elemental module function construct_from_component(selection) result(activation) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: selection Return Value type( activation_t )","tags":"","loc":"proc/construct_from_component.html"},{"title":"construct_from_name – Fiats","text":"module procedure construct_from_name elemental module function construct_from_name(name) result(activation) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value type( activation_t )","tags":"","loc":"proc/construct_from_name.html"},{"title":"default_real_differentiate – Fiats","text":"module procedure default_real_differentiate elemental module function default_real_differentiate(self, x) result(dy_dx) Interface → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self real, intent(in) :: x Return Value real","tags":"","loc":"proc/default_real_differentiate.html"},{"title":"default_real_evaluate – Fiats","text":"module procedure default_real_evaluate elemental module function default_real_evaluate(self, x) result(y) Interface → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self real, intent(in) :: x Return Value real","tags":"","loc":"proc/default_real_evaluate.html"},{"title":"double_precision_differentiate – Fiats","text":"module procedure double_precision_differentiate elemental module function double_precision_differentiate(self, x) result(dy_dx) Interface → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self double precision, intent(in) :: x Return Value double precision","tags":"","loc":"proc/double_precision_differentiate.html"},{"title":"double_precision_evaluate – Fiats","text":"module procedure double_precision_evaluate elemental module function double_precision_evaluate(self, x) result(y) Interface → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self double precision, intent(in) :: x Return Value double precision","tags":"","loc":"proc/double_precision_evaluate.html"},{"title":"equals – Fiats","text":"module procedure equals elemental module function equals(self, rhs) result(self_eq_rhs) Interface → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self type( activation_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"proc/equals~2.html"},{"title":"function_name – Fiats","text":"module procedure function_name elemental module function function_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self Return Value type(string_t) Calls proc~~function_name~~CallsGraph proc~function_name function_name assert assert proc~function_name->assert string_t string_t proc~function_name->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/function_name.html"},{"title":"default_real_equals – Fiats","text":"module procedure default_real_equals elemental module function default_real_equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: lhs class( hyperparameters_t ), intent(in) :: rhs Return Value logical Calls proc~~default_real_equals~2~~CallsGraph proc~default_real_equals~2 default_real_equals assert assert proc~default_real_equals~2->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_equals~2.html"},{"title":"default_real_from_components – Fiats","text":"module procedure default_real_from_components pure module function default_real_from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches real, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t )","tags":"","loc":"proc/default_real_from_components.html"},{"title":"default_real_from_json – Fiats","text":"module procedure default_real_from_json pure module function default_real_from_json(lines) result(hyperparameters) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( hyperparameters_t ) Calls proc~~default_real_from_json~2~~CallsGraph proc~default_real_from_json~2 default_real_from_json assert assert proc~default_real_from_json~2->assert get_json_key get_json_key proc~default_real_from_json~2->get_json_key get_json_value get_json_value proc~default_real_from_json~2->get_json_value string_t string_t proc~default_real_from_json~2->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_from_json~2.html"},{"title":"default_real_learning_rate – Fiats","text":"module procedure default_real_learning_rate elemental module function default_real_learning_rate(self) result(rate) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value real","tags":"","loc":"proc/default_real_learning_rate.html"},{"title":"default_real_mini_batches – Fiats","text":"module procedure default_real_mini_batches elemental module function default_real_mini_batches(self) result(num_mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value integer","tags":"","loc":"proc/default_real_mini_batches.html"},{"title":"default_real_optimizer_name – Fiats","text":"module procedure default_real_optimizer_name elemental module function default_real_optimizer_name(self) result(identifier) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t) Calls proc~~default_real_optimizer_name~~CallsGraph proc~default_real_optimizer_name default_real_optimizer_name string_t string_t proc~default_real_optimizer_name->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_optimizer_name.html"},{"title":"default_real_to_json – Fiats","text":"module procedure default_real_to_json pure module function default_real_to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Calls proc~~default_real_to_json~3~~CallsGraph proc~default_real_to_json~3 default_real_to_json string_t string_t proc~default_real_to_json~3->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_to_json~3.html"},{"title":"double_precision_equals – Fiats","text":"module procedure double_precision_equals elemental module function double_precision_equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: lhs class( hyperparameters_t (double_precision)), intent(in) :: rhs Return Value logical Calls proc~~double_precision_equals~2~~CallsGraph proc~double_precision_equals~2 double_precision_equals assert assert proc~double_precision_equals~2->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_equals~2.html"},{"title":"double_precision_from_components – Fiats","text":"module procedure double_precision_from_components pure module function double_precision_from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches double precision, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t (double_precision))","tags":"","loc":"proc/double_precision_from_components.html"},{"title":"double_precision_from_json – Fiats","text":"module procedure double_precision_from_json pure module function double_precision_from_json(lines) result(hyperparameters) Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: lines (:) Return Value type( hyperparameters_t (double_precision)) Calls proc~~double_precision_from_json~3~~CallsGraph proc~double_precision_from_json~3 double_precision_from_json assert assert proc~double_precision_from_json~3->assert get_json_key get_json_key proc~double_precision_from_json~3->get_json_key get_json_value get_json_value proc~double_precision_from_json~3->get_json_value string_t string_t proc~double_precision_from_json~3->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_from_json~3.html"},{"title":"double_precision_learning_rate – Fiats","text":"module procedure double_precision_learning_rate elemental module function double_precision_learning_rate(self) result(rate) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: self Return Value double precision","tags":"","loc":"proc/double_precision_learning_rate.html"},{"title":"double_precision_mini_batches – Fiats","text":"module procedure double_precision_mini_batches elemental module function double_precision_mini_batches(self) result(num_mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: self Return Value integer","tags":"","loc":"proc/double_precision_mini_batches.html"},{"title":"double_precision_optimizer_name – Fiats","text":"module procedure double_precision_optimizer_name elemental module function double_precision_optimizer_name(self) result(identifier) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: self Return Value type(string_t) Calls proc~~double_precision_optimizer_name~~CallsGraph proc~double_precision_optimizer_name double_precision_optimizer_name string_t string_t proc~double_precision_optimizer_name->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_optimizer_name.html"},{"title":"double_precision_to_json – Fiats","text":"module procedure double_precision_to_json pure module function double_precision_to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: self Return Value type(string_t), allocatable, (:) Calls proc~~double_precision_to_json~3~~CallsGraph proc~double_precision_to_json~3 double_precision_to_json string_t string_t proc~double_precision_to_json~3->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_to_json~3.html"},{"title":"activation_name – Fiats","text":"module procedure activation_name pure module function activation_name(self) result(function_name) Interface → Arguments Type Intent Optional Attributes Name class( metadata_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"proc/activation_name.html"},{"title":"double_precision_from_json – Fiats","text":"module procedure double_precision_from_json pure module function double_precision_from_json(lines) result(metadata) Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: lines (:) Return Value type( metadata_t ) Calls proc~~double_precision_from_json~4~~CallsGraph proc~double_precision_from_json~4 double_precision_from_json assert assert proc~double_precision_from_json~4->assert get_json_key get_json_key proc~double_precision_from_json~4->get_json_key get_json_value get_json_value proc~double_precision_from_json~4->get_json_value string string proc~double_precision_from_json~4->string string_t string_t proc~double_precision_from_json~4->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_from_json~4.html"},{"title":"equals – Fiats","text":"module procedure equals elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( metadata_t ), intent(in) :: lhs class( metadata_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"proc/equals~3.html"},{"title":"from_components – Fiats","text":"module procedure from_components pure module function from_components(modelName, modelAuthor, compilationDate, activationFunction, usingSkipConnections) result(metadata) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: modelName type(string_t), intent(in) :: modelAuthor type(string_t), intent(in) :: compilationDate type(string_t), intent(in) :: activationFunction type(string_t), intent(in) :: usingSkipConnections Return Value type( metadata_t )","tags":"","loc":"proc/from_components.html"},{"title":"from_json – Fiats","text":"module procedure from_json pure module function from_json(lines) result(metadata) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( metadata_t ) Calls proc~~from_json~2~~CallsGraph proc~from_json~2 from_json assert assert proc~from_json~2->assert get_json_key get_json_key proc~from_json~2->get_json_key get_json_value get_json_value proc~from_json~2->get_json_value string string proc~from_json~2->string string_t string_t proc~from_json~2->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/from_json~2.html"},{"title":"strings – Fiats","text":"module procedure strings pure module function strings(self) result(components) Interface → Arguments Type Intent Optional Attributes Name class( metadata_t ), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"proc/strings.html"},{"title":"to_json – Fiats","text":"module procedure to_json pure module function to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( metadata_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Calls proc~~to_json~~CallsGraph proc~to_json to_json string string proc~to_json->string string_t string_t proc~to_json->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/to_json.html"},{"title":"default_real_differentiable_activation – Fiats","text":"module procedure default_real_differentiable_activation module function default_real_differentiable_activation(self) result(activation) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type( activation_t ) Calls proc~~default_real_differentiable_activation~~CallsGraph proc~default_real_differentiable_activation default_real_differentiable_activation interface~activation_name network_configuration_t%activation_name proc~default_real_differentiable_activation->interface~activation_name string string proc~default_real_differentiable_activation->string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_differentiable_activation.html"},{"title":"default_real_equals – Fiats","text":"module procedure default_real_equals elemental module function default_real_equals(lhs, rhs) result(lhs_eq_rhs) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: lhs class( training_configuration_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"proc/default_real_equals~3.html"},{"title":"default_real_from_components – Fiats","text":"module procedure default_real_from_components module function default_real_from_components(hyperparameters, network_configuration) result(training_configuration) Arguments Type Intent Optional Attributes Name type( hyperparameters_t ), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t ) Calls proc~~default_real_from_components~2~~CallsGraph proc~default_real_from_components~2 default_real_from_components file_t file_t proc~default_real_from_components~2->file_t none~to_json~3 hyperparameters_t%to_json proc~default_real_from_components~2->none~to_json~3 string_t string_t proc~default_real_from_components~2->string_t interface~default_real_to_json~2 hyperparameters_t%default_real_to_json none~to_json~3->interface~default_real_to_json~2 interface~double_precision_to_json~2 hyperparameters_t%double_precision_to_json none~to_json~3->interface~double_precision_to_json~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_from_components~2.html"},{"title":"default_real_from_file – Fiats","text":"module procedure default_real_from_file module function default_real_from_file(file_object) result(training_configuration) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_object Return Value type( training_configuration_t ) Calls proc~~default_real_from_file~~CallsGraph proc~default_real_from_file default_real_from_file assert assert proc~default_real_from_file->assert lines lines proc~default_real_from_file->lines string string proc~default_real_from_file->string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_from_file.html"},{"title":"default_real_learning_rate – Fiats","text":"module procedure default_real_learning_rate elemental module function default_real_learning_rate(self) result(rate) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value real Calls proc~~default_real_learning_rate~2~~CallsGraph proc~default_real_learning_rate~2 default_real_learning_rate none~learning_rate~3 hyperparameters_t%learning_rate proc~default_real_learning_rate~2->none~learning_rate~3 interface~default_real_learning_rate~2 hyperparameters_t%default_real_learning_rate none~learning_rate~3->interface~default_real_learning_rate~2 interface~double_precision_learning_rate~2 hyperparameters_t%double_precision_learning_rate none~learning_rate~3->interface~double_precision_learning_rate~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_learning_rate~2.html"},{"title":"default_real_mini_batches – Fiats","text":"module procedure default_real_mini_batches elemental module function default_real_mini_batches(self) result(num_mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer Calls proc~~default_real_mini_batches~2~~CallsGraph proc~default_real_mini_batches~2 default_real_mini_batches none~mini_batches~2 hyperparameters_t%mini_batches proc~default_real_mini_batches~2->none~mini_batches~2 interface~default_real_mini_batches~2 hyperparameters_t%default_real_mini_batches none~mini_batches~2->interface~default_real_mini_batches~2 interface~double_precision_mini_batches~2 hyperparameters_t%double_precision_mini_batches none~mini_batches~2->interface~double_precision_mini_batches~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_mini_batches~2.html"},{"title":"default_real_nodes_per_layer – Fiats","text":"module procedure default_real_nodes_per_layer pure module function default_real_nodes_per_layer(self) result(nodes) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) Calls proc~~default_real_nodes_per_layer~2~~CallsGraph proc~default_real_nodes_per_layer~2 default_real_nodes_per_layer interface~nodes_per_layer network_configuration_t%nodes_per_layer proc~default_real_nodes_per_layer~2->interface~nodes_per_layer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_nodes_per_layer~2.html"},{"title":"default_real_optimizer_name – Fiats","text":"module procedure default_real_optimizer_name elemental module function default_real_optimizer_name(self) result(identifier) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t) Calls proc~~default_real_optimizer_name~2~~CallsGraph proc~default_real_optimizer_name~2 default_real_optimizer_name none~optimizer_name~2 hyperparameters_t%optimizer_name proc~default_real_optimizer_name~2->none~optimizer_name~2 interface~default_real_optimizer_name~2 hyperparameters_t%default_real_optimizer_name none~optimizer_name~2->interface~default_real_optimizer_name~2 interface~double_precision_optimizer_name~2 hyperparameters_t%double_precision_optimizer_name none~optimizer_name~2->interface~double_precision_optimizer_name~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_optimizer_name~2.html"},{"title":"default_real_skip_connections – Fiats","text":"module procedure default_real_skip_connections elemental module function default_real_skip_connections(self) result(using_skip) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value logical Calls proc~~default_real_skip_connections~~CallsGraph proc~default_real_skip_connections default_real_skip_connections interface~skip_connections network_configuration_t%skip_connections proc~default_real_skip_connections->interface~skip_connections Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_skip_connections.html"},{"title":"default_real_to_json – Fiats","text":"module procedure default_real_to_json pure module function default_real_to_json(self) result(json_lines) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Calls proc~~default_real_to_json~4~~CallsGraph proc~default_real_to_json~4 default_real_to_json lines lines proc~default_real_to_json~4->lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_to_json~4.html"},{"title":"double_precision_differentiable_activation – Fiats","text":"module procedure double_precision_differentiable_activation module function double_precision_differentiable_activation(self) result(activation) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value type( activation_t ) Calls proc~~double_precision_differentiable_activation~~CallsGraph proc~double_precision_differentiable_activation double_precision_differentiable_activation interface~activation_name network_configuration_t%activation_name proc~double_precision_differentiable_activation->interface~activation_name string string proc~double_precision_differentiable_activation->string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_differentiable_activation.html"},{"title":"double_precision_equals – Fiats","text":"module procedure double_precision_equals elemental module function double_precision_equals(lhs, rhs) result(lhs_eq_rhs) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: lhs class( training_configuration_t (double_precision)), intent(in) :: rhs Return Value logical","tags":"","loc":"proc/double_precision_equals~3.html"},{"title":"double_precision_from_components – Fiats","text":"module procedure double_precision_from_components module function double_precision_from_components(hyperparameters, network_configuration) result(training_configuration) Arguments Type Intent Optional Attributes Name type( hyperparameters_t (double_precision)), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t (double_precision)) Calls proc~~double_precision_from_components~2~~CallsGraph proc~double_precision_from_components~2 double_precision_from_components file_t file_t proc~double_precision_from_components~2->file_t none~to_json~3 hyperparameters_t%to_json proc~double_precision_from_components~2->none~to_json~3 string_t string_t proc~double_precision_from_components~2->string_t interface~default_real_to_json~2 hyperparameters_t%default_real_to_json none~to_json~3->interface~default_real_to_json~2 interface~double_precision_to_json~2 hyperparameters_t%double_precision_to_json none~to_json~3->interface~double_precision_to_json~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_from_components~2.html"},{"title":"double_precision_from_file – Fiats","text":"module procedure double_precision_from_file module function double_precision_from_file(file_object) result(training_configuration) Arguments Type Intent Optional Attributes Name type( double_precision_file_t ), intent(in) :: file_object Return Value type( training_configuration_t (double_precision)) Calls proc~~double_precision_from_file~~CallsGraph proc~double_precision_from_file double_precision_from_file assert assert proc~double_precision_from_file->assert interface~double_precision_lines double_precision_file_t%double_precision_lines proc~double_precision_from_file->interface~double_precision_lines string string proc~double_precision_from_file->string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_from_file.html"},{"title":"double_precision_learning_rate – Fiats","text":"module procedure double_precision_learning_rate elemental module function double_precision_learning_rate(self) result(rate) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value double precision Calls proc~~double_precision_learning_rate~2~~CallsGraph proc~double_precision_learning_rate~2 double_precision_learning_rate none~learning_rate~3 hyperparameters_t%learning_rate proc~double_precision_learning_rate~2->none~learning_rate~3 interface~default_real_learning_rate~2 hyperparameters_t%default_real_learning_rate none~learning_rate~3->interface~default_real_learning_rate~2 interface~double_precision_learning_rate~2 hyperparameters_t%double_precision_learning_rate none~learning_rate~3->interface~double_precision_learning_rate~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_learning_rate~2.html"},{"title":"double_precision_mini_batches – Fiats","text":"module procedure double_precision_mini_batches elemental module function double_precision_mini_batches(self) result(num_mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value integer Calls proc~~double_precision_mini_batches~2~~CallsGraph proc~double_precision_mini_batches~2 double_precision_mini_batches none~mini_batches~2 hyperparameters_t%mini_batches proc~double_precision_mini_batches~2->none~mini_batches~2 interface~default_real_mini_batches~2 hyperparameters_t%default_real_mini_batches none~mini_batches~2->interface~default_real_mini_batches~2 interface~double_precision_mini_batches~2 hyperparameters_t%double_precision_mini_batches none~mini_batches~2->interface~double_precision_mini_batches~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_mini_batches~2.html"},{"title":"double_precision_nodes_per_layer – Fiats","text":"module procedure double_precision_nodes_per_layer pure module function double_precision_nodes_per_layer(self) result(nodes) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value integer, allocatable, (:) Calls proc~~double_precision_nodes_per_layer~2~~CallsGraph proc~double_precision_nodes_per_layer~2 double_precision_nodes_per_layer interface~nodes_per_layer network_configuration_t%nodes_per_layer proc~double_precision_nodes_per_layer~2->interface~nodes_per_layer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_nodes_per_layer~2.html"},{"title":"double_precision_optimizer_name – Fiats","text":"module procedure double_precision_optimizer_name elemental module function double_precision_optimizer_name(self) result(identifier) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value type(string_t) Calls proc~~double_precision_optimizer_name~2~~CallsGraph proc~double_precision_optimizer_name~2 double_precision_optimizer_name none~optimizer_name~2 hyperparameters_t%optimizer_name proc~double_precision_optimizer_name~2->none~optimizer_name~2 interface~default_real_optimizer_name~2 hyperparameters_t%default_real_optimizer_name none~optimizer_name~2->interface~default_real_optimizer_name~2 interface~double_precision_optimizer_name~2 hyperparameters_t%double_precision_optimizer_name none~optimizer_name~2->interface~double_precision_optimizer_name~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_optimizer_name~2.html"},{"title":"double_precision_skip_connections – Fiats","text":"module procedure double_precision_skip_connections elemental module function double_precision_skip_connections(self) result(using_skip) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value logical Calls proc~~double_precision_skip_connections~~CallsGraph proc~double_precision_skip_connections double_precision_skip_connections interface~skip_connections network_configuration_t%skip_connections proc~double_precision_skip_connections->interface~skip_connections Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_skip_connections.html"},{"title":"double_precision_to_json – Fiats","text":"module procedure double_precision_to_json pure module function double_precision_to_json(self) result(json_lines) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value type(string_t), allocatable, (:) Calls proc~~double_precision_to_json~4~~CallsGraph proc~double_precision_to_json~4 double_precision_to_json lines lines proc~double_precision_to_json~4->lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_to_json~4.html"},{"title":"default_real_allocate – Fiats","text":"module procedure default_real_allocate module subroutine default_real_allocate(self, neural_network) Interface → Arguments Type Intent Optional Attributes Name class( workspace_t ), intent(inout) :: self type( neural_network_t ), intent(in) :: neural_network","tags":"","loc":"proc/default_real_allocate.html"},{"title":"default_real_allocated – Fiats","text":"module procedure default_real_allocated pure module function default_real_allocated(self) result(all_allocated) Interface → Arguments Type Intent Optional Attributes Name class( workspace_t ), intent(in) :: self Return Value logical","tags":"","loc":"proc/default_real_allocated.html"},{"title":"default_real_workspace – Fiats","text":"module procedure default_real_workspace pure module function default_real_workspace(neural_network) result(workspace) Arguments Type Intent Optional Attributes Name type( neural_network_t ), intent(in) :: neural_network Return Value type( workspace_t ) Calls proc~~default_real_workspace~~CallsGraph proc~default_real_workspace default_real_workspace assert assert proc~default_real_workspace->assert none~fully_allocated workspace_t%fully_allocated proc~default_real_workspace->none~fully_allocated interface~default_real_allocated workspace_t%default_real_allocated none~fully_allocated->interface~default_real_allocated Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_workspace.html"},{"title":"activation_name – Fiats","text":"module procedure activation_name elemental module function activation_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"proc/activation_name~2.html"},{"title":"equals – Fiats","text":"module procedure equals elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: lhs class( network_configuration_t ), intent(in) :: rhs Return Value logical Calls proc~~equals~4~~CallsGraph proc~equals~4 equals assert assert proc~equals~4->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/equals~4.html"},{"title":"from_components – Fiats","text":"module procedure from_components pure module function from_components(skip_connections, nodes_per_layer, activation_name) result(network_configuration) Arguments Type Intent Optional Attributes Name logical, intent(in) :: skip_connections integer, intent(in) :: nodes_per_layer (:) character(len=*), intent(in) :: activation_name Return Value type( network_configuration_t )","tags":"","loc":"proc/from_components~2.html"},{"title":"from_double_precision_string_json – Fiats","text":"module procedure from_double_precision_string_json pure module function from_double_precision_string_json(lines) result(network_configuration) Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: lines (:) Return Value type( network_configuration_t ) Calls proc~~from_double_precision_string_json~~CallsGraph proc~from_double_precision_string_json from_double_precision_string_json assert assert proc~from_double_precision_string_json->assert get_json_key get_json_key proc~from_double_precision_string_json->get_json_key get_json_value get_json_value proc~from_double_precision_string_json->get_json_value string_t string_t proc~from_double_precision_string_json->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/from_double_precision_string_json.html"},{"title":"from_json – Fiats","text":"module procedure from_json pure module function from_json(lines) result(network_configuration) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( network_configuration_t ) Calls proc~~from_json~3~~CallsGraph proc~from_json~3 from_json assert assert proc~from_json~3->assert get_json_key get_json_key proc~from_json~3->get_json_key get_json_value get_json_value proc~from_json~3->get_json_value string_t string_t proc~from_json~3->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/from_json~3.html"},{"title":"nodes_per_layer – Fiats","text":"module procedure nodes_per_layer pure module function nodes_per_layer(self) result(nodes) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:)","tags":"","loc":"proc/nodes_per_layer.html"},{"title":"skip_connections – Fiats","text":"module procedure skip_connections elemental module function skip_connections(self) result(using_skip) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value logical","tags":"","loc":"proc/skip_connections.html"},{"title":"to_json – Fiats","text":"module procedure to_json pure module function to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Calls proc~~to_json~2~~CallsGraph proc~to_json~2 to_json string_t string_t proc~to_json~2->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/to_json~2.html"},{"title":"default_real_construct – Fiats","text":"module procedure default_real_construct pure module function default_real_construct(input_output_pairs) result(mini_batch) Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t )","tags":"","loc":"proc/default_real_construct~2.html"},{"title":"default_real_input_output_pairs – Fiats","text":"module procedure default_real_input_output_pairs pure module function default_real_input_output_pairs(self) result(my_input_output_pairs) Interface → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ), allocatable, (:)","tags":"","loc":"proc/default_real_input_output_pairs.html"},{"title":"double_precision_construct – Fiats","text":"module procedure double_precision_construct pure module function double_precision_construct(input_output_pairs) result(mini_batch) Arguments Type Intent Optional Attributes Name type( input_output_pair_t (double_precision)), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t (double_precision))","tags":"","loc":"proc/double_precision_construct~2.html"},{"title":"double_precision_input_output_pairs – Fiats","text":"module procedure double_precision_input_output_pairs pure module function double_precision_input_output_pairs(self) result(my_input_output_pairs) Interface → Arguments Type Intent Optional Attributes Name class( mini_batch_t (double_precision)), intent(in) :: self Return Value type( input_output_pair_t (double_precision)), allocatable, (:)","tags":"","loc":"proc/double_precision_input_output_pairs.html"},{"title":"default_real_bias – Fiats","text":"module procedure default_real_bias module function default_real_bias(self) result(my_bias) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real","tags":"","loc":"proc/default_real_bias.html"},{"title":"default_real_from_components – Fiats","text":"module procedure default_real_from_components pure module function default_real_from_components(weights, bias) result(neuron) Arguments Type Intent Optional Attributes Name real, intent(in) :: weights (:) real, intent(in) :: bias Return Value type( neuron_t )","tags":"","loc":"proc/default_real_from_components~3.html"},{"title":"default_real_next_allocated – Fiats","text":"module procedure default_real_next_allocated module function default_real_next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical","tags":"","loc":"proc/default_real_next_allocated~2.html"},{"title":"default_real_next_pointer – Fiats","text":"module procedure default_real_next_pointer module function default_real_next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ), pointer","tags":"","loc":"proc/default_real_next_pointer~2.html"},{"title":"default_real_num_inputs – Fiats","text":"module procedure default_real_num_inputs pure module function default_real_num_inputs(self) result(size_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer","tags":"","loc":"proc/default_real_num_inputs~2.html"},{"title":"default_real_to_json – Fiats","text":"module procedure default_real_to_json pure module function default_real_to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Calls proc~~default_real_to_json~5~~CallsGraph proc~default_real_to_json~5 default_real_to_json assert assert proc~default_real_to_json~5->assert separated_values separated_values proc~default_real_to_json~5->separated_values string_t string_t proc~default_real_to_json~5->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/default_real_to_json~5.html"},{"title":"default_real_weights – Fiats","text":"module procedure default_real_weights module function default_real_weights(self) result(my_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real, allocatable, (:)","tags":"","loc":"proc/default_real_weights.html"},{"title":"double_precision_bias – Fiats","text":"module procedure double_precision_bias module function double_precision_bias(self) result(my_bias) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value double precision","tags":"","loc":"proc/double_precision_bias.html"},{"title":"double_precision_from_components – Fiats","text":"module procedure double_precision_from_components pure module function double_precision_from_components(weights, bias) result(neuron) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: weights (:) double precision, intent(in) :: bias Return Value type( neuron_t (double_precision))","tags":"","loc":"proc/double_precision_from_components~3.html"},{"title":"double_precision_from_json – Fiats","text":"module procedure double_precision_from_json pure recursive module function double_precision_from_json(neuron_lines, start) result(neuron) Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t (double_precision)) Calls proc~~double_precision_from_json~5~~CallsGraph proc~double_precision_from_json~5 double_precision_from_json assert assert proc~double_precision_from_json~5->assert string string proc~double_precision_from_json~5->string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_from_json~5.html"},{"title":"double_precision_next_allocated – Fiats","text":"module procedure double_precision_next_allocated module function double_precision_next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value logical","tags":"","loc":"proc/double_precision_next_allocated~2.html"},{"title":"double_precision_next_pointer – Fiats","text":"module procedure double_precision_next_pointer module function double_precision_next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in), target :: self Return Value type( neuron_t (double_precision)), pointer","tags":"","loc":"proc/double_precision_next_pointer~2.html"},{"title":"double_precision_num_inputs – Fiats","text":"module procedure double_precision_num_inputs pure module function double_precision_num_inputs(self) result(size_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value integer","tags":"","loc":"proc/double_precision_num_inputs~2.html"},{"title":"double_precision_to_json – Fiats","text":"module procedure double_precision_to_json pure module function double_precision_to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value type(string_t), allocatable, (:) Calls proc~~double_precision_to_json~5~~CallsGraph proc~double_precision_to_json~5 double_precision_to_json assert assert proc~double_precision_to_json~5->assert separated_values separated_values proc~double_precision_to_json~5->separated_values string_t string_t proc~double_precision_to_json~5->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/double_precision_to_json~5.html"},{"title":"double_precision_weights – Fiats","text":"module procedure double_precision_weights module function double_precision_weights(self) result(my_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value double precision, allocatable, (:)","tags":"","loc":"proc/double_precision_weights.html"},{"title":"from_json – Fiats","text":"module procedure from_json pure recursive module function from_json(neuron_lines, start) result(neuron) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) Calls proc~~from_json~4~~CallsGraph proc~from_json~4 from_json assert assert proc~from_json~4->assert string string proc~from_json~4->string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/from_json~4.html"},{"title":"trainable_network_m – Fiats","text":"Uses input_output_pair_m neural_network_m julienne_m kind_parameters_m mini_batch_m tensor_map_m training_configuration_m module~~trainable_network_m~~UsesGraph module~trainable_network_m trainable_network_m julienne_m julienne_m module~trainable_network_m->julienne_m module~input_output_pair_m input_output_pair_m module~trainable_network_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~trainable_network_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~trainable_network_m->module~mini_batch_m module~neural_network_m neural_network_m module~trainable_network_m->module~neural_network_m module~tensor_map_m tensor_map_m module~trainable_network_m->module~tensor_map_m module~training_configuration_m training_configuration_m module~trainable_network_m->module~training_configuration_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~neural_network_m->julienne_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~mini_batch_m module~neural_network_m->module~tensor_map_m module~activation_m activation_m module~neural_network_m->module~activation_m module~double_precision_file_m double_precision_file_m module~neural_network_m->module~double_precision_file_m module~metadata_m metadata_m module~neural_network_m->module~metadata_m module~neural_network_m->module~tensor_m module~tensor_map_m->julienne_m module~tensor_map_m->module~kind_parameters_m module~double_precision_string_m double_precision_string_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~tensor_m module~training_configuration_m->module~kind_parameters_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m julienne_string_m julienne_string_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~activation_m module~training_configuration_m->module~double_precision_file_m module~hyperparameters_m hyperparameters_m module~training_configuration_m->module~hyperparameters_m module~network_configuration_m network_configuration_m module~training_configuration_m->module~network_configuration_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding module~double_precision_file_m->julienne_m module~double_precision_file_m->module~double_precision_string_m module~double_precision_string_m->julienne_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~hyperparameters_m->module~double_precision_string_m module~metadata_m->julienne_string_m module~metadata_m->module~double_precision_string_m module~network_configuration_m->julienne_string_m module~network_configuration_m->module~double_precision_string_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: trainable_network_s module~~trainable_network_m~~UsedByGraph module~trainable_network_m trainable_network_m module~fiats_m fiats_m module~fiats_m->module~trainable_network_m module~trainable_network_s trainable_network_s module~trainable_network_s->module~trainable_network_m module~addition_m addition_m module~addition_m->module~fiats_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~fiats_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~fiats_m module~power_series power_series module~power_series->module~fiats_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~fiats_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~fiats_m program~learn_addition learn_addition program~learn_addition->module~fiats_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~fiats_m program~learn_exponentiation->module~exponentiation_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~fiats_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~fiats_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~fiats_m program~read_query_infer read_query_infer program~read_query_infer->module~fiats_m program~train_and_write train_and_write program~train_and_write->module~fiats_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~fiats_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~fiats_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface trainable_network_t private pure module function default_real_network(neural_network) result(trainable_network) Implementation → Arguments Type Intent Optional Attributes Name type( neural_network_t ), intent(in) :: neural_network Return Value type( trainable_network_t ) private module function perturbed_identity_network(training_configuration, perturbation_magnitude, metadata, input_map, output_map) result(trainable_network) Implementation → Arguments Type Intent Optional Attributes Name type( training_configuration_t ), intent(in) :: training_configuration real, intent(in) :: perturbation_magnitude type(string_t), intent(in) :: metadata (:) type( tensor_map_t ) :: input_map type( tensor_map_t ) :: output_map Return Value type( trainable_network_t ) interface private elemental module function default_real_map_to_training_ranges(self, input_output_pair) result(normalized_input_output_pair) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_network_t ), intent(in) :: self type( input_output_pair_t ), intent(in) :: input_output_pair Return Value type( input_output_pair_t ) interface private pure module subroutine default_real_train(self, mini_batches_arr, cost, adam, learning_rate) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_network_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches_arr (:) real, intent(out), optional, allocatable :: cost (:) logical, intent(in) :: adam real, intent(in) :: learning_rate Derived Types type, public, extends( neural_network_t ) :: trainable_network_t Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real integer, public, kind :: k = default_real type( workspace_t ), private :: workspace_ Constructor private\n\n                    pure, module\n                    function default_real_network (neural_network) private\n\n                    module\n                    function perturbed_identity_network (training_configuration, perturbation_magnitude, metadata, input_map, output_map) Type-Bound Procedures generic, public :: activation_function_name => default_real_activation_name , double_precision_activation_name generic, public :: assert_conformable_with => default_real_assert_conformable_with , double_precision_assert_conformable_with generic, public :: assert_consistency => default_real_consistency , double_precision_consistency generic, public :: infer => default_real_infer , double_precision_infer generic, public :: learn => default_real_learn generic, public :: map_from_output_range => default_real_map_from_output_range , double_precision_map_from_output_range generic, public :: map_to_input_range => default_real_map_to_input_range , double_precision_map_to_input_range generic, public :: map_to_training_ranges => default_real_map_to_training_ranges generic, public :: nodes_per_layer => default_real_nodes_per_layer , double_precision_nodes_per_layer generic, public :: num_hidden_layers => default_real_num_hidden_layers , double_precision_num_hidden_layers generic, public :: num_inputs => default_real_num_inputs , double_precision_num_inputs generic, public :: num_outputs => default_real_num_outputs , double_precision_num_outputs generic, public :: operator(==) => default_real_approximately_equal , double_precision_approximately_equal generic, public :: skip => default_real_skip , double_precision_skip generic, public :: to_json => default_real_to_json , double_precision_to_json generic, public :: train => default_real_train procedure, private, non_overridable :: default_real_map_to_training_ranges procedure, private, non_overridable :: default_real_train","tags":"","loc":"module/trainable_network_m.html"},{"title":"training_configuration_m – Fiats","text":"Uses double_precision_file_m julienne_string_m julienne_file_m activation_m network_configuration_m kind_parameters_m hyperparameters_m module~~training_configuration_m~~UsesGraph module~training_configuration_m training_configuration_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m julienne_string_m julienne_string_m module~training_configuration_m->julienne_string_m module~activation_m activation_m module~training_configuration_m->module~activation_m module~double_precision_file_m double_precision_file_m module~training_configuration_m->module~double_precision_file_m module~hyperparameters_m hyperparameters_m module~training_configuration_m->module~hyperparameters_m module~kind_parameters_m kind_parameters_m module~training_configuration_m->module~kind_parameters_m module~network_configuration_m network_configuration_m module~training_configuration_m->module~network_configuration_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding julienne_m julienne_m module~activation_m->julienne_m module~double_precision_file_m->julienne_m module~double_precision_string_m double_precision_string_m module~double_precision_file_m->module~double_precision_string_m module~hyperparameters_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->module~double_precision_string_m module~network_configuration_m->julienne_string_m module~network_configuration_m->module~double_precision_string_m module~double_precision_string_m->julienne_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: training_configuration_s module~~training_configuration_m~~UsedByGraph module~training_configuration_m training_configuration_m module~fiats_m fiats_m module~fiats_m->module~training_configuration_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~trainable_network_m->module~training_configuration_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~training_configuration_m module~addition_m addition_m module~addition_m->module~fiats_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~fiats_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~fiats_m module~power_series power_series module~power_series->module~fiats_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~fiats_m module~trainable_network_s trainable_network_s module~trainable_network_s->module~trainable_network_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~fiats_m program~learn_addition learn_addition program~learn_addition->module~fiats_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~fiats_m program~learn_exponentiation->module~exponentiation_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~fiats_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~fiats_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~fiats_m program~read_query_infer read_query_infer program~read_query_infer->module~fiats_m program~train_and_write train_and_write program~train_and_write->module~fiats_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~fiats_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~fiats_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface training_configuration_t private module function default_real_from_components(hyperparameters, network_configuration) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type( hyperparameters_t ), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t ) private module function default_real_from_file(file_object) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_object Return Value type( training_configuration_t ) private module function double_precision_from_components(hyperparameters, network_configuration) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type( hyperparameters_t (double_precision)), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t (double_precision)) private module function double_precision_from_file(file_object) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_file_t ), intent(in) :: file_object Return Value type( training_configuration_t (double_precision)) interface private module function default_real_differentiable_activation(self) result(activation) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type( activation_t ) interface private elemental module function default_real_equals(lhs, rhs) result(lhs_eq_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: lhs class( training_configuration_t ), intent(in) :: rhs Return Value logical interface private elemental module function default_real_learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value real interface private elemental module function default_real_mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer interface private pure module function default_real_nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) interface private elemental module function default_real_optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t) interface private elemental module function default_real_skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value logical interface private pure module function default_real_to_json(self) result(json_lines) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) interface private module function double_precision_differentiable_activation(self) result(activation) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value type( activation_t ) interface private elemental module function double_precision_equals(lhs, rhs) result(lhs_eq_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: lhs class( training_configuration_t (double_precision)), intent(in) :: rhs Return Value logical interface private elemental module function double_precision_learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value double precision interface private elemental module function double_precision_mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value integer interface private pure module function double_precision_nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value integer, allocatable, (:) interface private elemental module function double_precision_optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value type(string_t) interface private elemental module function double_precision_skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value logical interface private pure module function double_precision_to_json(self) result(json_lines) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value type(string_t), allocatable, (:) Derived Types type, public, extends( double_precision_file_t ) :: training_configuration_t Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real type( hyperparameters_t (k)), private :: hyperparameters_ type( network_configuration_t ), private :: network_configuration_ Constructor private\n\n                    module\n                    function default_real_from_components (hyperparameters, network_configuration) private\n\n                    module\n                    function default_real_from_file (file_object) private\n\n                    module\n                    function double_precision_from_components (hyperparameters, network_configuration) private\n\n                    module\n                    function double_precision_from_file (file_object) Type-Bound Procedures generic, public :: differentiable_activation => default_real_differentiable_activation , double_precision_differentiable_activation procedure, public :: double_precision_lines generic, public :: learning_rate => default_real_learning_rate , double_precision_learning_rate generic, public :: mini_batches => default_real_mini_batches , double_precision_mini_batches generic, public :: nodes_per_layer => default_real_nodes_per_layer , double_precision_nodes_per_layer generic, public :: operator(==) => default_real_equals , double_precision_equals generic, public :: optimizer_name => default_real_optimizer_name , double_precision_optimizer_name generic, public :: skip_connections => default_real_skip_connections , double_precision_skip_connections generic, public :: to_json => default_real_to_json , double_precision_to_json procedure, private :: default_real_differentiable_activation procedure, private :: default_real_equals procedure, private :: default_real_learning_rate procedure, private :: default_real_mini_batches procedure, private :: default_real_nodes_per_layer procedure, private :: default_real_optimizer_name procedure, private :: default_real_skip_connections procedure, private :: default_real_to_json procedure, private :: double_precision_differentiable_activation procedure, private :: double_precision_equals procedure, private :: double_precision_learning_rate procedure, private :: double_precision_mini_batches procedure, private :: double_precision_nodes_per_layer procedure, private :: double_precision_optimizer_name procedure, private :: double_precision_skip_connections procedure, private :: double_precision_to_json","tags":"","loc":"module/training_configuration_m.html"},{"title":"network_configuration_m – Fiats","text":"Uses double_precision_string_m julienne_string_m module~~network_configuration_m~~UsesGraph module~network_configuration_m network_configuration_m julienne_string_m julienne_string_m module~network_configuration_m->julienne_string_m module~double_precision_string_m double_precision_string_m module~network_configuration_m->module~double_precision_string_m julienne_m julienne_m module~double_precision_string_m->julienne_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: network_configuration_s module~~network_configuration_m~~UsedByGraph module~network_configuration_m network_configuration_m module~fiats_m fiats_m module~fiats_m->module~network_configuration_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~network_configuration_s network_configuration_s module~network_configuration_s->module~network_configuration_m module~training_configuration_m->module~network_configuration_m module~addition_m addition_m module~addition_m->module~fiats_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~fiats_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~fiats_m module~power_series power_series module~power_series->module~fiats_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~fiats_m module~trainable_network_m->module~training_configuration_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~training_configuration_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~fiats_m program~learn_addition learn_addition program~learn_addition->module~fiats_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~fiats_m program~learn_exponentiation->module~exponentiation_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~fiats_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~fiats_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~fiats_m program~read_query_infer read_query_infer program~read_query_infer->module~fiats_m program~train_and_write train_and_write program~train_and_write->module~fiats_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~fiats_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~fiats_m module~trainable_network_s trainable_network_s module~trainable_network_s->module~trainable_network_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface network_configuration_t private pure module function from_components(skip_connections, nodes_per_layer, activation_name) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name logical, intent(in) :: skip_connections integer, intent(in) :: nodes_per_layer (:) character(len=*), intent(in) :: activation_name Return Value type( network_configuration_t ) private pure module function from_double_precision_string_json(lines) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: lines (:) Return Value type( network_configuration_t ) private pure module function from_json(lines) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( network_configuration_t ) interface private elemental module function activation_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t) interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: lhs class( network_configuration_t ), intent(in) :: rhs Return Value logical interface private pure module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) interface private elemental module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value logical interface private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Derived Types type, public :: network_configuration_t Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: activation_name_ integer, private, allocatable :: nodes_per_layer_ (:) logical, private :: skip_connections_ = .false. Constructor private\n\n                    pure, module\n                    function from_components (skip_connections, nodes_per_layer, activation_name) private\n\n                    pure, module\n                    function from_double_precision_string_json (lines) private\n\n                    pure, module\n                    function from_json (lines) Type-Bound Procedures procedure, public :: activation_name procedure, public :: equals procedure, public :: nodes_per_layer generic, public :: operator(==) => equals procedure, public :: skip_connections procedure, public :: to_json","tags":"","loc":"module/network_configuration_m.html"},{"title":"multiply_inputs – Fiats","text":"Define a function that produces the desired network output for a given network input Uses assert_m fiats_m module~~multiply_inputs~~UsesGraph module~multiply_inputs multiply_inputs assert_m assert_m module~multiply_inputs->assert_m module~fiats_m fiats_m module~multiply_inputs->module~fiats_m module~double_precision_file_m double_precision_file_m module~fiats_m->module~double_precision_file_m module~double_precision_string_m double_precision_string_m module~fiats_m->module~double_precision_string_m module~hyperparameters_m hyperparameters_m module~fiats_m->module~hyperparameters_m module~input_output_pair_m input_output_pair_m module~fiats_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~fiats_m->module~kind_parameters_m module~metadata_m metadata_m module~fiats_m->module~metadata_m module~mini_batch_m mini_batch_m module~fiats_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~fiats_m->module~network_configuration_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~tensor_m tensor_m module~fiats_m->module~tensor_m module~tensor_map_m tensor_map_m module~fiats_m->module~tensor_map_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~ubounds_m ubounds_m module~fiats_m->module~ubounds_m module~double_precision_file_m->module~double_precision_string_m julienne_m julienne_m module~double_precision_file_m->julienne_m module~double_precision_string_m->julienne_m module~hyperparameters_m->module~double_precision_string_m module~hyperparameters_m->module~kind_parameters_m julienne_string_m julienne_string_m module~hyperparameters_m->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~metadata_m->module~double_precision_string_m module~metadata_m->julienne_string_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->module~double_precision_string_m module~network_configuration_m->julienne_string_m module~neural_network_m->module~double_precision_file_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~metadata_m module~neural_network_m->module~mini_batch_m module~neural_network_m->module~tensor_m module~neural_network_m->module~tensor_map_m module~neural_network_m->julienne_m module~activation_m activation_m module~neural_network_m->module~activation_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->module~tensor_m module~tensor_map_m->julienne_m module~trainable_network_m->module~input_output_pair_m module~trainable_network_m->module~kind_parameters_m module~trainable_network_m->module~mini_batch_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~tensor_map_m module~trainable_network_m->module~training_configuration_m module~trainable_network_m->julienne_m module~training_configuration_m->module~double_precision_file_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~activation_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~multiply_inputs~~UsedByGraph module~multiply_inputs multiply_inputs program~learn_multiplication learn_multiplication program~learn_multiplication->module~multiply_inputs Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public elemental function y (x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t )","tags":"","loc":"module/multiply_inputs.html"},{"title":"activation_m – Fiats","text":"Uses julienne_m iso_c_binding module~~activation_m~~UsesGraph module~activation_m activation_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding julienne_m julienne_m module~activation_m->julienne_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: activation_s module~~activation_m~~UsedByGraph module~activation_m activation_m module~activation_s activation_s module~activation_s->module~activation_m module~neural_network_m neural_network_m module~neural_network_m->module~activation_m module~training_configuration_m training_configuration_m module~training_configuration_m->module~activation_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~activation_m module~training_configuration_s->module~training_configuration_m module~fiats_m fiats_m module~fiats_m->module~neural_network_m module~fiats_m->module~training_configuration_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~layer_m layer_m module~layer_m->module~neural_network_m module~neural_network_s neural_network_s module~neural_network_s->module~neural_network_m module~neural_network_s->module~layer_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~training_configuration_m module~unmapped_network_s unmapped_network_s module~unmapped_network_s->module~neural_network_m module~workspace_s workspace_s module~workspace_s->module~neural_network_m module~addition_m addition_m module~addition_m->module~fiats_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~fiats_m module~layer_s layer_s module~layer_s->module~layer_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~fiats_m module~power_series power_series module~power_series->module~fiats_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~fiats_m module~trainable_network_s trainable_network_s module~trainable_network_s->module~trainable_network_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~fiats_m program~learn_addition learn_addition program~learn_addition->module~fiats_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~fiats_m program~learn_exponentiation->module~exponentiation_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~fiats_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~fiats_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~fiats_m program~read_query_infer read_query_infer program~read_query_infer->module~fiats_m program~train_and_write train_and_write program~train_and_write->module~fiats_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~fiats_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~fiats_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: activation_name (*) = [character(len(\"sigmoid\"))::\"gelu\", \"relu\", \"sigmoid\", \"step\", \"swish\"] Enumerations enum, bind(c) Enumerators enumerator :: gelu = 1 enumerator :: relu = 2 enumerator :: sigmoid = 3 enumerator :: step = 4 enumerator :: swish = 5 Interfaces public        interface activation_t private elemental module function construct_from_component(selection) result(activation) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: selection Return Value type( activation_t ) private elemental module function construct_from_name(name) result(activation) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value type( activation_t ) interface private elemental module function default_real_differentiate(self, x) result(dy_dx) Implementation → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self real, intent(in) :: x Return Value real interface private elemental module function default_real_evaluate(self, x) result(y) Implementation → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self real, intent(in) :: x Return Value real interface private elemental module function double_precision_differentiate(self, x) result(dy_dx) Implementation → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self double precision, intent(in) :: x Return Value double precision interface private elemental module function double_precision_evaluate(self, x) result(y) Implementation → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self double precision, intent(in) :: x Return Value double precision interface private elemental module function equals(self, rhs) result(self_eq_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self type( activation_t ), intent(in) :: rhs Return Value logical interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self Return Value type(string_t) Derived Types type, public :: activation_t Components Type Visibility Attributes Name Initial integer(kind=c_int), private :: selection_ = sigmoid Constructor private\n\n                    elemental, module\n                    function construct_from_component (selection) private\n\n                    elemental, module\n                    function construct_from_name (name) Type-Bound Procedures generic, public :: differentiate => default_real_differentiate , double_precision_differentiate generic, public :: evaluate => default_real_evaluate , double_precision_evaluate procedure, public, non_overridable :: function_name generic, public :: operator(==) => equals procedure, private, non_overridable :: default_real_differentiate procedure, private, non_overridable :: default_real_evaluate procedure, private, non_overridable :: double_precision_differentiate procedure, private, non_overridable :: double_precision_evaluate procedure, private :: equals","tags":"","loc":"module/activation_m.html"},{"title":"double_precision_string_m – Fiats","text":"Uses julienne_m module~~double_precision_string_m~~UsesGraph module~double_precision_string_m double_precision_string_m julienne_m julienne_m module~double_precision_string_m->julienne_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: double_precision_string_s module~~double_precision_string_m~~UsedByGraph module~double_precision_string_m double_precision_string_m module~double_precision_file_m double_precision_file_m module~double_precision_file_m->module~double_precision_string_m module~double_precision_string_s double_precision_string_s module~double_precision_string_s->module~double_precision_string_m module~fiats_m fiats_m module~fiats_m->module~double_precision_string_m module~fiats_m->module~double_precision_file_m module~hyperparameters_m hyperparameters_m module~fiats_m->module~hyperparameters_m module~metadata_m metadata_m module~fiats_m->module~metadata_m module~network_configuration_m network_configuration_m module~fiats_m->module~network_configuration_m module~tensor_map_m tensor_map_m module~fiats_m->module~tensor_map_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~hyperparameters_m->module~double_precision_string_m module~layer_m layer_m module~layer_m->module~double_precision_string_m module~layer_m->module~metadata_m module~neuron_m neuron_m module~layer_m->module~neuron_m module~layer_m->module~tensor_map_m module~layer_m->module~neural_network_m module~metadata_m->module~double_precision_string_m module~network_configuration_m->module~double_precision_string_m module~neural_network_s neural_network_s module~neural_network_s->module~double_precision_string_m module~neural_network_s->module~layer_m module~neural_network_s->module~neuron_m module~neural_network_s->module~neural_network_m module~neuron_m->module~double_precision_string_m module~tensor_map_m->module~double_precision_string_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~double_precision_string_m module~training_configuration_s->module~training_configuration_m module~addition_m addition_m module~addition_m->module~fiats_m module~double_precision_file_s double_precision_file_s module~double_precision_file_s->module~double_precision_file_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~fiats_m module~hyperparameters_s hyperparameters_s module~hyperparameters_s->module~hyperparameters_m module~layer_s layer_s module~layer_s->module~layer_m module~metadata_s metadata_s module~metadata_s->module~metadata_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~fiats_m module~network_configuration_s network_configuration_s module~network_configuration_s->module~network_configuration_m module~neural_network_m->module~double_precision_file_m module~neural_network_m->module~metadata_m module~neural_network_m->module~tensor_map_m module~neuron_s neuron_s module~neuron_s->module~neuron_m module~power_series power_series module~power_series->module~fiats_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~fiats_m module~tensor_map_s tensor_map_s module~tensor_map_s->module~tensor_map_m module~trainable_network_m->module~tensor_map_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~training_configuration_m module~training_configuration_m->module~double_precision_file_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~network_configuration_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~fiats_m program~learn_addition learn_addition program~learn_addition->module~fiats_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~fiats_m program~learn_exponentiation->module~exponentiation_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~fiats_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~fiats_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~fiats_m program~read_query_infer read_query_infer program~read_query_infer->module~fiats_m program~train_and_write train_and_write program~train_and_write->module~fiats_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~fiats_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~fiats_m module~trainable_network_s trainable_network_s module~trainable_network_s->module~trainable_network_m module~unmapped_network_s unmapped_network_s module~unmapped_network_s->module~neural_network_m module~workspace_s workspace_s module~workspace_s->module~neural_network_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface double_precision_string_t public elemental module function construct_from_string(string) result(double_precision_string) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: string Return Value type( double_precision_string_t ) Derived Types type, public, extends(string_t) :: double_precision_string_t Constructor public\n\n                    elemental, module\n                    function construct_from_string (string)","tags":"","loc":"module/double_precision_string_m.html"},{"title":"addition_m – Fiats","text":"Define a function that produces the desired network output for a given network input Uses assert_m fiats_m module~~addition_m~~UsesGraph module~addition_m addition_m assert_m assert_m module~addition_m->assert_m module~fiats_m fiats_m module~addition_m->module~fiats_m module~double_precision_file_m double_precision_file_m module~fiats_m->module~double_precision_file_m module~double_precision_string_m double_precision_string_m module~fiats_m->module~double_precision_string_m module~hyperparameters_m hyperparameters_m module~fiats_m->module~hyperparameters_m module~input_output_pair_m input_output_pair_m module~fiats_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~fiats_m->module~kind_parameters_m module~metadata_m metadata_m module~fiats_m->module~metadata_m module~mini_batch_m mini_batch_m module~fiats_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~fiats_m->module~network_configuration_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~tensor_m tensor_m module~fiats_m->module~tensor_m module~tensor_map_m tensor_map_m module~fiats_m->module~tensor_map_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~ubounds_m ubounds_m module~fiats_m->module~ubounds_m module~double_precision_file_m->module~double_precision_string_m julienne_m julienne_m module~double_precision_file_m->julienne_m module~double_precision_string_m->julienne_m module~hyperparameters_m->module~double_precision_string_m module~hyperparameters_m->module~kind_parameters_m julienne_string_m julienne_string_m module~hyperparameters_m->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~metadata_m->module~double_precision_string_m module~metadata_m->julienne_string_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->module~double_precision_string_m module~network_configuration_m->julienne_string_m module~neural_network_m->module~double_precision_file_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~metadata_m module~neural_network_m->module~mini_batch_m module~neural_network_m->module~tensor_m module~neural_network_m->module~tensor_map_m module~neural_network_m->julienne_m module~activation_m activation_m module~neural_network_m->module~activation_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->module~tensor_m module~tensor_map_m->julienne_m module~trainable_network_m->module~input_output_pair_m module~trainable_network_m->module~kind_parameters_m module~trainable_network_m->module~mini_batch_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~tensor_map_m module~trainable_network_m->module~training_configuration_m module~trainable_network_m->julienne_m module~training_configuration_m->module~double_precision_file_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~activation_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~addition_m~~UsedByGraph module~addition_m addition_m program~learn_addition learn_addition program~learn_addition->module~addition_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public elemental function y (x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t )","tags":"","loc":"module/addition_m.html"},{"title":"input_output_pair_m – Fiats","text":"Uses tensor_m kind_parameters_m module~~input_output_pair_m~~UsesGraph module~input_output_pair_m input_output_pair_m module~kind_parameters_m kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: input_output_pair_s module~~input_output_pair_m~~UsedByGraph module~input_output_pair_m input_output_pair_m module~fiats_m fiats_m module~fiats_m->module~input_output_pair_m module~mini_batch_m mini_batch_m module~fiats_m->module~mini_batch_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~input_output_pair_s input_output_pair_s module~input_output_pair_s->module~input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~trainable_network_m->module~input_output_pair_m module~trainable_network_m->module~mini_batch_m module~trainable_network_m->module~neural_network_m module~addition_m addition_m module~addition_m->module~fiats_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~fiats_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~fiats_m module~neural_network_m->module~mini_batch_m module~power_series power_series module~power_series->module~fiats_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~fiats_m module~trainable_network_s trainable_network_s module~trainable_network_s->module~trainable_network_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~fiats_m program~learn_addition learn_addition program~learn_addition->module~fiats_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~fiats_m program~learn_exponentiation->module~exponentiation_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~fiats_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~fiats_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~fiats_m program~read_query_infer read_query_infer program~read_query_infer->module~fiats_m program~train_and_write train_and_write program~train_and_write->module~fiats_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~fiats_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~fiats_m module~layer_m layer_m module~layer_m->module~neural_network_m module~neural_network_s neural_network_s module~neural_network_s->module~neural_network_m module~neural_network_s->module~layer_m module~unmapped_network_s unmapped_network_s module~unmapped_network_s->module~neural_network_m module~workspace_s workspace_s module~workspace_s->module~neural_network_m module~layer_s layer_s module~layer_s->module~layer_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface input_output_pair_t private elemental module function default_real_construct(inputs, expected_outputs) result(input_output_pair) Implementation → Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t ) private elemental module function double_precision_construct(inputs, expected_outputs) result(input_output_pair) Implementation → Arguments Type Intent Optional Attributes Name type( tensor_t (double_precision)), intent(in) :: inputs type( tensor_t (double_precision)), intent(in) :: expected_outputs Return Value type( input_output_pair_t (double_precision)) public        interface shuffle private module subroutine default_real_shuffle(pairs) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(inout) :: pairs (:) private module subroutine double_precision_shuffle(pairs) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t (double_precision)), intent(inout) :: pairs (:) public        interface write_to_stdout private module subroutine default_real_write_to_stdout(input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) private module subroutine double_precision_write_to_stdout(input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t (double_precision)), intent(in) :: input_output_pairs (:) interface private elemental module function default_real_expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) interface private elemental module function default_real_inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) interface private elemental module function double_precision_expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t (double_precision)), intent(in) :: self Return Value type( tensor_t (double_precision)) interface private elemental module function double_precision_inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t (double_precision)), intent(in) :: self Return Value type( tensor_t (double_precision)) Derived Types type, public :: input_output_pair_t Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real type( tensor_t (k)), private :: expected_outputs_ type( tensor_t (k)), private :: inputs_ Constructor private\n\n                    elemental, module\n                    function default_real_construct (inputs, expected_outputs) private\n\n                    elemental, module\n                    function double_precision_construct (inputs, expected_outputs) Type-Bound Procedures generic, public :: expected_outputs => default_real_expected_outputs , double_precision_expected_outputs generic, public :: inputs => default_real_inputs , double_precision_inputs procedure, private, non_overridable :: default_real_expected_outputs procedure, private, non_overridable :: default_real_inputs procedure, private, non_overridable :: double_precision_expected_outputs procedure, private, non_overridable :: double_precision_inputs","tags":"","loc":"module/input_output_pair_m.html"},{"title":"double_precision_file_m – Fiats","text":"Uses double_precision_string_m julienne_m module~~double_precision_file_m~~UsesGraph module~double_precision_file_m double_precision_file_m julienne_m julienne_m module~double_precision_file_m->julienne_m module~double_precision_string_m double_precision_string_m module~double_precision_file_m->module~double_precision_string_m module~double_precision_string_m->julienne_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: double_precision_file_s module~~double_precision_file_m~~UsedByGraph module~double_precision_file_m double_precision_file_m module~double_precision_file_s double_precision_file_s module~double_precision_file_s->module~double_precision_file_m module~fiats_m fiats_m module~fiats_m->module~double_precision_file_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~neural_network_m->module~double_precision_file_m module~training_configuration_m->module~double_precision_file_m module~addition_m addition_m module~addition_m->module~fiats_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~fiats_m module~layer_m layer_m module~layer_m->module~neural_network_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~fiats_m module~neural_network_s neural_network_s module~neural_network_s->module~neural_network_m module~neural_network_s->module~layer_m module~power_series power_series module~power_series->module~fiats_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~fiats_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~training_configuration_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~training_configuration_m module~unmapped_network_s unmapped_network_s module~unmapped_network_s->module~neural_network_m module~workspace_s workspace_s module~workspace_s->module~neural_network_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~fiats_m program~learn_addition learn_addition program~learn_addition->module~fiats_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~fiats_m program~learn_exponentiation->module~exponentiation_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~fiats_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~fiats_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~fiats_m program~read_query_infer read_query_infer program~read_query_infer->module~fiats_m program~train_and_write train_and_write program~train_and_write->module~fiats_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~fiats_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~fiats_m module~layer_s layer_s module~layer_s->module~layer_m module~trainable_network_s trainable_network_s module~trainable_network_s->module~trainable_network_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface double_precision_file_t public impure elemental module function construct_from_character(file_name) result(double_precision_file) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value type( double_precision_file_t ) public impure elemental module function construct_from_string(file_name) result(double_precision_file) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: file_name Return Value type( double_precision_file_t ) interface public pure module function double_precision_lines(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( double_precision_file_t ), intent(in) :: self Return Value type( double_precision_string_t ), allocatable, (:) Derived Types type, public, extends(file_t) :: double_precision_file_t Constructor public\n\n                    impure, elemental, module\n                    function construct_from_character (file_name) public\n\n                    impure, elemental, module\n                    function construct_from_string (file_name) Type-Bound Procedures procedure, public :: double_precision_lines","tags":"","loc":"module/double_precision_file_m.html"},{"title":"power_series – Fiats","text":"Define a function that produces the desired network output for a given network input Uses assert_m fiats_m module~~power_series~~UsesGraph module~power_series power_series assert_m assert_m module~power_series->assert_m module~fiats_m fiats_m module~power_series->module~fiats_m module~double_precision_file_m double_precision_file_m module~fiats_m->module~double_precision_file_m module~double_precision_string_m double_precision_string_m module~fiats_m->module~double_precision_string_m module~hyperparameters_m hyperparameters_m module~fiats_m->module~hyperparameters_m module~input_output_pair_m input_output_pair_m module~fiats_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~fiats_m->module~kind_parameters_m module~metadata_m metadata_m module~fiats_m->module~metadata_m module~mini_batch_m mini_batch_m module~fiats_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~fiats_m->module~network_configuration_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~tensor_m tensor_m module~fiats_m->module~tensor_m module~tensor_map_m tensor_map_m module~fiats_m->module~tensor_map_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~ubounds_m ubounds_m module~fiats_m->module~ubounds_m module~double_precision_file_m->module~double_precision_string_m julienne_m julienne_m module~double_precision_file_m->julienne_m module~double_precision_string_m->julienne_m module~hyperparameters_m->module~double_precision_string_m module~hyperparameters_m->module~kind_parameters_m julienne_string_m julienne_string_m module~hyperparameters_m->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~metadata_m->module~double_precision_string_m module~metadata_m->julienne_string_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->module~double_precision_string_m module~network_configuration_m->julienne_string_m module~neural_network_m->module~double_precision_file_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~metadata_m module~neural_network_m->module~mini_batch_m module~neural_network_m->module~tensor_m module~neural_network_m->module~tensor_map_m module~neural_network_m->julienne_m module~activation_m activation_m module~neural_network_m->module~activation_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->module~tensor_m module~tensor_map_m->julienne_m module~trainable_network_m->module~input_output_pair_m module~trainable_network_m->module~kind_parameters_m module~trainable_network_m->module~mini_batch_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~tensor_map_m module~trainable_network_m->module~training_configuration_m module~trainable_network_m->julienne_m module~training_configuration_m->module~double_precision_file_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~activation_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~power_series~~UsedByGraph module~power_series power_series program~learn_power_series learn_power_series program~learn_power_series->module~power_series Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public elemental function y (x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t )","tags":"","loc":"module/power_series.html"},{"title":"ubounds_m – Fiats","text":"This module serves only to support array bounds checking in the main program below Used by module~~ubounds_m~~UsedByGraph module~ubounds_m ubounds_m module~fiats_m fiats_m module~fiats_m->module~ubounds_m module~addition_m addition_m module~addition_m->module~fiats_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~fiats_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~fiats_m module~power_series power_series module~power_series->module~fiats_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~fiats_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~fiats_m program~learn_addition learn_addition program~learn_addition->module~fiats_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~fiats_m program~learn_exponentiation->module~exponentiation_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~fiats_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~fiats_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~fiats_m program~read_query_infer read_query_infer program~read_query_infer->module~fiats_m program~train_and_write train_and_write program~train_and_write->module~fiats_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~fiats_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~fiats_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: ubounds_t Components Type Visibility Attributes Name Initial integer, public, allocatable :: ubounds_ (:) Type-Bound Procedures procedure, public :: equals generic, public :: operator(==) => equals Functions public elemental function equals (lhs, rhs) result(lhs_equals_rhs) Arguments Type Intent Optional Attributes Name class( ubounds_t ), intent(in) :: lhs class( ubounds_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"module/ubounds_m.html"},{"title":"kind_parameters_m – Fiats","text":"Used by module~~kind_parameters_m~~UsedByGraph module~kind_parameters_m kind_parameters_m module~fiats_m fiats_m module~fiats_m->module~kind_parameters_m module~hyperparameters_m hyperparameters_m module~fiats_m->module~hyperparameters_m module~input_output_pair_m input_output_pair_m module~fiats_m->module~input_output_pair_m module~mini_batch_m mini_batch_m module~fiats_m->module~mini_batch_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~tensor_m tensor_m module~fiats_m->module~tensor_m module~tensor_map_m tensor_map_m module~fiats_m->module~tensor_map_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~hyperparameters_m->module~kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~layer_m layer_m module~layer_m->module~kind_parameters_m module~layer_m->module~neural_network_m module~neuron_m neuron_m module~layer_m->module~neuron_m module~layer_m->module~tensor_map_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~mini_batch_m module~neural_network_m->module~tensor_m module~neural_network_m->module~tensor_map_m module~neural_network_s neural_network_s module~neural_network_s->module~kind_parameters_m module~neural_network_s->module~layer_m module~neural_network_s->module~neural_network_m module~neural_network_s->module~neuron_m module~neuron_m->module~kind_parameters_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->module~tensor_m module~tensor_map_s tensor_map_s module~tensor_map_s->module~kind_parameters_m module~tensor_map_s->module~tensor_map_m module~trainable_network_m->module~kind_parameters_m module~trainable_network_m->module~input_output_pair_m module~trainable_network_m->module~mini_batch_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~tensor_map_m module~trainable_network_m->module~training_configuration_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~hyperparameters_m module~addition_m addition_m module~addition_m->module~fiats_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~fiats_m module~hyperparameters_s hyperparameters_s module~hyperparameters_s->module~hyperparameters_m module~input_output_pair_s input_output_pair_s module~input_output_pair_s->module~input_output_pair_m module~layer_s layer_s module~layer_s->module~layer_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~fiats_m module~neuron_s neuron_s module~neuron_s->module~neuron_m module~power_series power_series module~power_series->module~fiats_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~fiats_m module~tensor_s tensor_s module~tensor_s->module~tensor_m module~trainable_network_s trainable_network_s module~trainable_network_s->module~trainable_network_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~training_configuration_m module~unmapped_network_s unmapped_network_s module~unmapped_network_s->module~neural_network_m module~workspace_s workspace_s module~workspace_s->module~neural_network_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~fiats_m program~learn_addition learn_addition program~learn_addition->module~fiats_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~fiats_m program~learn_exponentiation->module~exponentiation_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~fiats_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~fiats_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~fiats_m program~read_query_infer read_query_infer program~read_query_infer->module~fiats_m program~train_and_write train_and_write program~train_and_write->module~fiats_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~fiats_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~fiats_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: default_real = kind(1.) integer, public, parameter :: double_precision = kind(1D0)","tags":"","loc":"module/kind_parameters_m.html"},{"title":"hyperparameters_m – Fiats","text":"Uses double_precision_string_m julienne_string_m kind_parameters_m module~~hyperparameters_m~~UsesGraph module~hyperparameters_m hyperparameters_m julienne_string_m julienne_string_m module~hyperparameters_m->julienne_string_m module~double_precision_string_m double_precision_string_m module~hyperparameters_m->module~double_precision_string_m module~kind_parameters_m kind_parameters_m module~hyperparameters_m->module~kind_parameters_m julienne_m julienne_m module~double_precision_string_m->julienne_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: hyperparameters_s module~~hyperparameters_m~~UsedByGraph module~hyperparameters_m hyperparameters_m module~fiats_m fiats_m module~fiats_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~hyperparameters_s hyperparameters_s module~hyperparameters_s->module~hyperparameters_m module~training_configuration_m->module~hyperparameters_m module~addition_m addition_m module~addition_m->module~fiats_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~fiats_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~fiats_m module~power_series power_series module~power_series->module~fiats_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~fiats_m module~trainable_network_m->module~training_configuration_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~training_configuration_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~fiats_m program~learn_addition learn_addition program~learn_addition->module~fiats_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~fiats_m program~learn_exponentiation->module~exponentiation_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~fiats_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~fiats_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~fiats_m program~read_query_infer read_query_infer program~read_query_infer->module~fiats_m program~train_and_write train_and_write program~train_and_write->module~fiats_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~fiats_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~fiats_m module~trainable_network_s trainable_network_s module~trainable_network_s->module~trainable_network_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface hyperparameters_t private pure module function default_real_from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches real, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t ) private pure module function default_real_from_json(lines) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( hyperparameters_t ) private pure module function double_precision_from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches double precision, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t (double_precision)) private pure module function double_precision_from_json(lines) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: lines (:) Return Value type( hyperparameters_t (double_precision)) interface private elemental module function default_real_equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: lhs class( hyperparameters_t ), intent(in) :: rhs Return Value logical interface private elemental module function default_real_learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value real interface private elemental module function default_real_mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value integer interface private elemental module function default_real_optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t) interface private pure module function default_real_to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) interface private elemental module function double_precision_equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: lhs class( hyperparameters_t (double_precision)), intent(in) :: rhs Return Value logical interface private elemental module function double_precision_learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: self Return Value double precision interface private elemental module function double_precision_mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: self Return Value integer interface private elemental module function double_precision_optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: self Return Value type(string_t) interface private pure module function double_precision_to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: self Return Value type(string_t), allocatable, (:) Derived Types type, public :: hyperparameters_t Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real character(len=:), public, allocatable :: optimizer_ real(kind=k), private :: learning_rate_ = real(1.5, k) integer, private :: mini_batches_ = 10 Constructor private\n\n                    pure, module\n                    function default_real_from_components (mini_batches, learning_rate, optimizer) private\n\n                    pure, module\n                    function default_real_from_json (lines) private\n\n                    pure, module\n                    function double_precision_from_components (mini_batches, learning_rate, optimizer) private\n\n                    pure, module\n                    function double_precision_from_json (lines) Type-Bound Procedures generic, public :: learning_rate => default_real_learning_rate , double_precision_learning_rate generic, public :: mini_batches => default_real_mini_batches , double_precision_mini_batches generic, public :: operator(==) => default_real_equals , double_precision_equals generic, public :: optimizer_name => default_real_optimizer_name , double_precision_optimizer_name generic, public :: to_json => default_real_to_json , double_precision_to_json procedure, private :: default_real_equals procedure, private :: default_real_learning_rate procedure, private :: default_real_mini_batches procedure, private :: default_real_optimizer_name procedure, private :: default_real_to_json procedure, private :: double_precision_equals procedure, private :: double_precision_learning_rate procedure, private :: double_precision_mini_batches procedure, private :: double_precision_optimizer_name procedure, private :: double_precision_to_json","tags":"","loc":"module/hyperparameters_m.html"},{"title":"saturated_mixing_ratio_m – Fiats","text":"This module supports the program in the file example/learn-saturated-mixing-ratio.f90.\nThe saturated_mixing_ratio function in this module resulted from refactoring the sat_mr function\nin the Intermediate Complexity Atmospheric Research (ICAR) model file src/physics/mp_simple.f90.\nICAR is distributed under the above MIT license.  See https://github.com/ncar/icar. Uses assert_m fiats_m module~~saturated_mixing_ratio_m~~UsesGraph module~saturated_mixing_ratio_m saturated_mixing_ratio_m assert_m assert_m module~saturated_mixing_ratio_m->assert_m module~fiats_m fiats_m module~saturated_mixing_ratio_m->module~fiats_m module~double_precision_file_m double_precision_file_m module~fiats_m->module~double_precision_file_m module~double_precision_string_m double_precision_string_m module~fiats_m->module~double_precision_string_m module~hyperparameters_m hyperparameters_m module~fiats_m->module~hyperparameters_m module~input_output_pair_m input_output_pair_m module~fiats_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~fiats_m->module~kind_parameters_m module~metadata_m metadata_m module~fiats_m->module~metadata_m module~mini_batch_m mini_batch_m module~fiats_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~fiats_m->module~network_configuration_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~tensor_m tensor_m module~fiats_m->module~tensor_m module~tensor_map_m tensor_map_m module~fiats_m->module~tensor_map_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~ubounds_m ubounds_m module~fiats_m->module~ubounds_m module~double_precision_file_m->module~double_precision_string_m julienne_m julienne_m module~double_precision_file_m->julienne_m module~double_precision_string_m->julienne_m module~hyperparameters_m->module~double_precision_string_m module~hyperparameters_m->module~kind_parameters_m julienne_string_m julienne_string_m module~hyperparameters_m->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~metadata_m->module~double_precision_string_m module~metadata_m->julienne_string_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->module~double_precision_string_m module~network_configuration_m->julienne_string_m module~neural_network_m->module~double_precision_file_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~metadata_m module~neural_network_m->module~mini_batch_m module~neural_network_m->module~tensor_m module~neural_network_m->module~tensor_map_m module~neural_network_m->julienne_m module~activation_m activation_m module~neural_network_m->module~activation_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->module~tensor_m module~tensor_map_m->julienne_m module~trainable_network_m->module~input_output_pair_m module~trainable_network_m->module~kind_parameters_m module~trainable_network_m->module~mini_batch_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~tensor_map_m module~trainable_network_m->module~training_configuration_m module~trainable_network_m->julienne_m module~training_configuration_m->module~double_precision_file_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~activation_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~saturated_mixing_ratio_m~~UsedByGraph module~saturated_mixing_ratio_m saturated_mixing_ratio_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real, public, parameter :: T (*) = [(real(i)/real(resolution), i=0, resolution)] real, public, parameter :: p (*) = [(real(i)/real(resolution), i=0, resolution)] real, private, parameter :: T_max = 307.610779 real, private, parameter :: T_min = 236.352524 real, private, parameter :: freezing_threshold = 273.15 integer, private :: i real, private, parameter :: p_max = 98596.7578 real, private, parameter :: p_min = 29671.1348 integer, private, parameter :: resolution = 20 Functions public elemental function y (x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t ) private pure function saturated_mixing_ratio (T_normalized, p_normalized) result(sat_mr) Calculate the saturated mixing ratio for normalized tempetatures (k) and pressures (Pa) Arguments Type Intent Optional Attributes Name real, intent(in) :: T_normalized real, intent(in) :: p_normalized Return Value real","tags":"","loc":"module/saturated_mixing_ratio_m.html"},{"title":"tensor_m – Fiats","text":"Uses kind_parameters_m module~~tensor_m~~UsesGraph module~tensor_m tensor_m module~kind_parameters_m kind_parameters_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: tensor_s module~~tensor_m~~UsedByGraph module~tensor_m tensor_m module~fiats_m fiats_m module~fiats_m->module~tensor_m module~input_output_pair_m input_output_pair_m module~fiats_m->module~input_output_pair_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~tensor_map_m tensor_map_m module~fiats_m->module~tensor_map_m module~mini_batch_m mini_batch_m module~fiats_m->module~mini_batch_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~input_output_pair_m->module~tensor_m module~neural_network_m->module~tensor_m module~neural_network_m->module~tensor_map_m module~neural_network_m->module~mini_batch_m module~tensor_map_m->module~tensor_m module~tensor_s tensor_s module~tensor_s->module~tensor_m module~addition_m addition_m module~addition_m->module~fiats_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~fiats_m module~input_output_pair_s input_output_pair_s module~input_output_pair_s->module~input_output_pair_m module~layer_m layer_m module~layer_m->module~neural_network_m module~layer_m->module~tensor_map_m module~mini_batch_m->module~input_output_pair_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~fiats_m module~neural_network_s neural_network_s module~neural_network_s->module~neural_network_m module~neural_network_s->module~layer_m module~power_series power_series module~power_series->module~fiats_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~fiats_m module~tensor_map_s tensor_map_s module~tensor_map_s->module~tensor_map_m module~trainable_network_m->module~input_output_pair_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~tensor_map_m module~trainable_network_m->module~mini_batch_m module~unmapped_network_s unmapped_network_s module~unmapped_network_s->module~neural_network_m module~workspace_s workspace_s module~workspace_s->module~neural_network_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~fiats_m program~learn_addition learn_addition program~learn_addition->module~fiats_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~fiats_m program~learn_exponentiation->module~exponentiation_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~fiats_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~fiats_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~fiats_m program~read_query_infer read_query_infer program~read_query_infer->module~fiats_m program~train_and_write train_and_write program~train_and_write->module~fiats_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~fiats_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~fiats_m module~layer_s layer_s module~layer_s->module~layer_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m module~trainable_network_s trainable_network_s module~trainable_network_s->module~trainable_network_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface tensor_t private pure module function construct_default_real(values) result(tensor) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: values (:) Return Value type( tensor_t ) private pure module function construct_double_precision(values) result(tensor) Implementation → Arguments Type Intent Optional Attributes Name double precision, intent(in) :: values (:) Return Value type( tensor_t (double_precision)) interface private pure module function default_real_num_components(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer interface private pure module function default_real_values(self) result(tensor_values) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real, allocatable, (:) interface private pure module function double_precision_num_components(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t (double_precision)), intent(in) :: self Return Value integer interface private pure module function double_precision_values(self) result(tensor_values) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t (double_precision)), intent(in) :: self Return Value double precision, allocatable, (:) Derived Types type, public :: tensor_t Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real real(kind=k), private, allocatable :: values_ (:) Constructor private\n\n                    pure, module\n                    function construct_default_real (values) private\n\n                    pure, module\n                    function construct_double_precision (values) Type-Bound Procedures generic, public :: num_components => default_real_num_components , double_precision_num_components generic, public :: values => default_real_values , double_precision_values procedure, private :: default_real_num_components procedure, private, non_overridable :: default_real_values procedure, private :: double_precision_num_components procedure, private, non_overridable :: double_precision_values","tags":"","loc":"module/tensor_m.html"},{"title":"fiats_m – Fiats","text":"Specify the user-facing modules, derived types, and type parameters Uses double_precision_file_m metadata_m tensor_m training_configuration_m input_output_pair_m trainable_network_m neural_network_m network_configuration_m ubounds_m kind_parameters_m mini_batch_m tensor_map_m double_precision_string_m hyperparameters_m module~~fiats_m~~UsesGraph module~fiats_m fiats_m module~double_precision_file_m double_precision_file_m module~fiats_m->module~double_precision_file_m module~double_precision_string_m double_precision_string_m module~fiats_m->module~double_precision_string_m module~hyperparameters_m hyperparameters_m module~fiats_m->module~hyperparameters_m module~input_output_pair_m input_output_pair_m module~fiats_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~fiats_m->module~kind_parameters_m module~metadata_m metadata_m module~fiats_m->module~metadata_m module~mini_batch_m mini_batch_m module~fiats_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~fiats_m->module~network_configuration_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~tensor_m tensor_m module~fiats_m->module~tensor_m module~tensor_map_m tensor_map_m module~fiats_m->module~tensor_map_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~ubounds_m ubounds_m module~fiats_m->module~ubounds_m module~double_precision_file_m->module~double_precision_string_m julienne_m julienne_m module~double_precision_file_m->julienne_m module~double_precision_string_m->julienne_m module~hyperparameters_m->module~double_precision_string_m module~hyperparameters_m->module~kind_parameters_m julienne_string_m julienne_string_m module~hyperparameters_m->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~metadata_m->module~double_precision_string_m module~metadata_m->julienne_string_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->module~double_precision_string_m module~network_configuration_m->julienne_string_m module~neural_network_m->module~double_precision_file_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~metadata_m module~neural_network_m->module~mini_batch_m module~neural_network_m->module~tensor_m module~neural_network_m->module~tensor_map_m module~neural_network_m->julienne_m module~activation_m activation_m module~neural_network_m->module~activation_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->module~tensor_m module~tensor_map_m->julienne_m module~trainable_network_m->module~input_output_pair_m module~trainable_network_m->module~kind_parameters_m module~trainable_network_m->module~mini_batch_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~tensor_map_m module~trainable_network_m->module~training_configuration_m module~trainable_network_m->julienne_m module~training_configuration_m->module~double_precision_file_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~activation_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~fiats_m~~UsedByGraph module~fiats_m fiats_m module~addition_m addition_m module~addition_m->module~fiats_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~fiats_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~fiats_m module~power_series power_series module~power_series->module~fiats_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~fiats_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~fiats_m program~learn_addition learn_addition program~learn_addition->module~fiats_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~fiats_m program~learn_exponentiation->module~exponentiation_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~fiats_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~fiats_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~fiats_m program~read_query_infer read_query_infer program~read_query_infer->module~fiats_m program~train_and_write train_and_write program~train_and_write->module~fiats_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~fiats_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~fiats_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"module/fiats_m.html"},{"title":"mini_batch_m – Fiats","text":"Uses kind_parameters_m input_output_pair_m module~~mini_batch_m~~UsesGraph module~mini_batch_m mini_batch_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: mini_batch_s module~~mini_batch_m~~UsedByGraph module~mini_batch_m mini_batch_m module~fiats_m fiats_m module~fiats_m->module~mini_batch_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m module~neural_network_m->module~mini_batch_m module~trainable_network_m->module~mini_batch_m module~trainable_network_m->module~neural_network_m module~addition_m addition_m module~addition_m->module~fiats_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~fiats_m module~layer_m layer_m module~layer_m->module~neural_network_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~fiats_m module~neural_network_s neural_network_s module~neural_network_s->module~neural_network_m module~neural_network_s->module~layer_m module~power_series power_series module~power_series->module~fiats_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~fiats_m module~trainable_network_s trainable_network_s module~trainable_network_s->module~trainable_network_m module~unmapped_network_s unmapped_network_s module~unmapped_network_s->module~neural_network_m module~workspace_s workspace_s module~workspace_s->module~neural_network_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~fiats_m program~learn_addition learn_addition program~learn_addition->module~fiats_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~fiats_m program~learn_exponentiation->module~exponentiation_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~fiats_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~fiats_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~fiats_m program~read_query_infer read_query_infer program~read_query_infer->module~fiats_m program~train_and_write train_and_write program~train_and_write->module~fiats_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~fiats_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~fiats_m module~layer_s layer_s module~layer_s->module~layer_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface mini_batch_t private pure module function default_real_construct(input_output_pairs) result(mini_batch) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t ) private pure module function double_precision_construct(input_output_pairs) result(mini_batch) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t (double_precision)), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t (double_precision)) interface private pure module function default_real_input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ), allocatable, (:) interface private pure module function double_precision_input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t (double_precision)), intent(in) :: self Return Value type( input_output_pair_t (double_precision)), allocatable, (:) Derived Types type, public :: mini_batch_t Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real type( input_output_pair_t (k)), private, allocatable :: input_output_pairs_ (:) Constructor private\n\n                    pure, module\n                    function default_real_construct (input_output_pairs) private\n\n                    pure, module\n                    function double_precision_construct (input_output_pairs) Type-Bound Procedures procedure, public, non_overridable :: default_real_input_output_pairs procedure, public, non_overridable :: double_precision_input_output_pairs generic, public :: input_output_pairs => default_real_input_output_pairs , double_precision_input_output_pairs","tags":"","loc":"module/mini_batch_m.html"},{"title":"exponentiation_m – Fiats","text":"Define a function that produces the desired network output for a given network input Uses assert_m fiats_m module~~exponentiation_m~~UsesGraph module~exponentiation_m exponentiation_m assert_m assert_m module~exponentiation_m->assert_m module~fiats_m fiats_m module~exponentiation_m->module~fiats_m module~double_precision_file_m double_precision_file_m module~fiats_m->module~double_precision_file_m module~double_precision_string_m double_precision_string_m module~fiats_m->module~double_precision_string_m module~hyperparameters_m hyperparameters_m module~fiats_m->module~hyperparameters_m module~input_output_pair_m input_output_pair_m module~fiats_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~fiats_m->module~kind_parameters_m module~metadata_m metadata_m module~fiats_m->module~metadata_m module~mini_batch_m mini_batch_m module~fiats_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~fiats_m->module~network_configuration_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~tensor_m tensor_m module~fiats_m->module~tensor_m module~tensor_map_m tensor_map_m module~fiats_m->module~tensor_map_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~ubounds_m ubounds_m module~fiats_m->module~ubounds_m module~double_precision_file_m->module~double_precision_string_m julienne_m julienne_m module~double_precision_file_m->julienne_m module~double_precision_string_m->julienne_m module~hyperparameters_m->module~double_precision_string_m module~hyperparameters_m->module~kind_parameters_m julienne_string_m julienne_string_m module~hyperparameters_m->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~metadata_m->module~double_precision_string_m module~metadata_m->julienne_string_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->module~double_precision_string_m module~network_configuration_m->julienne_string_m module~neural_network_m->module~double_precision_file_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~metadata_m module~neural_network_m->module~mini_batch_m module~neural_network_m->module~tensor_m module~neural_network_m->module~tensor_map_m module~neural_network_m->julienne_m module~activation_m activation_m module~neural_network_m->module~activation_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->module~tensor_m module~tensor_map_m->julienne_m module~trainable_network_m->module~input_output_pair_m module~trainable_network_m->module~kind_parameters_m module~trainable_network_m->module~mini_batch_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~tensor_map_m module~trainable_network_m->module~training_configuration_m module~trainable_network_m->julienne_m module~training_configuration_m->module~double_precision_file_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~activation_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~exponentiation_m~~UsedByGraph module~exponentiation_m exponentiation_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~exponentiation_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public elemental function y (x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t )","tags":"","loc":"module/exponentiation_m.html"},{"title":"layer_m – Fiats","text":"Uses julienne_string_m metadata_m neural_network_m kind_parameters_m tensor_map_m double_precision_string_m neuron_m module~~layer_m~~UsesGraph module~layer_m layer_m julienne_string_m julienne_string_m module~layer_m->julienne_string_m module~double_precision_string_m double_precision_string_m module~layer_m->module~double_precision_string_m module~kind_parameters_m kind_parameters_m module~layer_m->module~kind_parameters_m module~metadata_m metadata_m module~layer_m->module~metadata_m module~neural_network_m neural_network_m module~layer_m->module~neural_network_m module~neuron_m neuron_m module~layer_m->module~neuron_m module~tensor_map_m tensor_map_m module~layer_m->module~tensor_map_m julienne_m julienne_m module~double_precision_string_m->julienne_m module~metadata_m->julienne_string_m module~metadata_m->module~double_precision_string_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~metadata_m module~neural_network_m->module~tensor_map_m module~neural_network_m->julienne_m module~activation_m activation_m module~neural_network_m->module~activation_m module~double_precision_file_m double_precision_file_m module~neural_network_m->module~double_precision_file_m module~mini_batch_m mini_batch_m module~neural_network_m->module~mini_batch_m module~tensor_m tensor_m module~neural_network_m->module~tensor_m module~neuron_m->julienne_string_m module~neuron_m->module~double_precision_string_m module~neuron_m->module~kind_parameters_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->julienne_m module~tensor_map_m->module~tensor_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding module~double_precision_file_m->module~double_precision_string_m module~double_precision_file_m->julienne_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~tensor_m->module~kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: layer_s module~~layer_m~~UsedByGraph module~layer_m layer_m module~layer_s layer_s module~layer_s->module~layer_m module~neural_network_s neural_network_s module~neural_network_s->module~layer_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface layer_t private recursive module function default_real_construct_layer(layer_lines, start) result(layer) Implementation → construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ), target private recursive module function double_precision_construct_layer(layer_lines, start) result(layer) Implementation → construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t (double_precision)), target interface private module function default_real_count_inputs(layer) result(num_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer interface private module function default_real_count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer interface private module function default_real_count_neurons(layer) result(neurons_per_layer_result) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer, allocatable, (:) interface private module function default_real_neural_network(hidden_layers, metadata, output_layer, input_map, output_map) result(neural_network_) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer type( tensor_map_t ), intent(in) :: input_map type( tensor_map_t ), intent(in) :: output_map Return Value type( neural_network_t ) interface private module function default_real_neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer interface private module function default_real_next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical interface private module function default_real_next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ), pointer interface private module function double_precision_count_inputs(layer) result(num_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in) :: layer Return Value integer interface private module function double_precision_count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: layer Return Value integer interface private module function double_precision_count_neurons(layer) result(neurons_per_layer_result) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: layer Return Value integer, allocatable, (:) interface private module function double_precision_neural_network(hidden_layers, metadata, output_layer, input_map, output_map) result(neural_network_) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: hidden_layers type( metadata_t ), intent(in) :: metadata type( layer_t (double_precision)), intent(in), target :: output_layer type( tensor_map_t (double_precision)), intent(in) :: input_map type( tensor_map_t (double_precision)), intent(in) :: output_map Return Value type( neural_network_t (double_precision)) interface private module function double_precision_neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: self Return Value integer interface private module function double_precision_next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in) :: self Return Value logical interface private module function double_precision_next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: self Return Value type( layer_t (double_precision)), pointer Derived Types type, public :: layer_t linked list of layers, each comprised of a linked list of neurons Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real type( neuron_t (k)), private :: neuron linked list of this layer's neurons type( layer_t (k)), private, allocatable :: next next layer Constructor private\n\n                    recursive, module\n                    function default_real_construct_layer (layer_lines, start) construct a linked list of layer_t objects from an array of JSON-formatted text lines private\n\n                    recursive, module\n                    function double_precision_construct_layer (layer_lines, start) construct a linked list of layer_t objects from an array of JSON-formatted text lines Type-Bound Procedures generic, public :: count_inputs => default_real_count_inputs , double_precision_count_inputs generic, public :: count_layers => default_real_count_layers , double_precision_count_layers generic, public :: count_neurons => default_real_count_neurons , double_precision_count_neurons generic, public :: neural_network => default_real_neural_network , double_precision_neural_network generic, public :: neurons_per_layer => default_real_neurons_per_layer , double_precision_neurons_per_layer generic, public :: next_allocated => default_real_next_allocated , double_precision_next_allocated generic, public :: next_pointer => default_real_next_pointer , double_precision_next_pointer procedure, private :: default_real_count_inputs procedure, private :: default_real_count_layers procedure, private :: default_real_count_neurons procedure, private :: default_real_neural_network procedure, private :: default_real_neurons_per_layer procedure, private :: default_real_next_allocated procedure, private :: default_real_next_pointer procedure, private :: double_precision_count_inputs procedure, private :: double_precision_count_layers procedure, private :: double_precision_count_neurons procedure, private :: double_precision_neural_network procedure, private :: double_precision_neurons_per_layer procedure, private :: double_precision_next_allocated procedure, private :: double_precision_next_pointer","tags":"","loc":"module/layer_m.html"},{"title":"neuron_m – Fiats","text":"Uses double_precision_string_m julienne_string_m kind_parameters_m module~~neuron_m~~UsesGraph module~neuron_m neuron_m julienne_string_m julienne_string_m module~neuron_m->julienne_string_m module~double_precision_string_m double_precision_string_m module~neuron_m->module~double_precision_string_m module~kind_parameters_m kind_parameters_m module~neuron_m->module~kind_parameters_m julienne_m julienne_m module~double_precision_string_m->julienne_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: neuron_s module~~neuron_m~~UsedByGraph module~neuron_m neuron_m module~layer_m layer_m module~layer_m->module~neuron_m module~neural_network_s neural_network_s module~neural_network_s->module~neuron_m module~neural_network_s->module~layer_m module~neuron_s neuron_s module~neuron_s->module~neuron_m module~layer_s layer_s module~layer_s->module~layer_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface neuron_t private pure module function default_real_from_components(weights, bias) result(neuron) Implementation → construct single neuron_t object from an array of weights and a bias Arguments Type Intent Optional Attributes Name real, intent(in) :: weights (:) real, intent(in) :: bias Return Value type( neuron_t ) private pure module function double_precision_from_components(weights, bias) result(neuron) Implementation → construct single neuron_t object from an array of weights and a bias Arguments Type Intent Optional Attributes Name double precision, intent(in) :: weights (:) double precision, intent(in) :: bias Return Value type( neuron_t (double_precision)) private pure recursive module function double_precision_from_json(neuron_lines, start) result(neuron) Implementation → construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t (double_precision)) private pure recursive module function from_json(neuron_lines, start) result(neuron) Implementation → construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) interface private module function default_real_bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real interface private module function default_real_next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical interface private module function default_real_next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ), pointer interface private pure module function default_real_num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer interface private pure module function default_real_to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) interface private module function default_real_weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real, allocatable, (:) interface private module function double_precision_bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value double precision interface private module function double_precision_next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value logical interface private module function double_precision_next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in), target :: self Return Value type( neuron_t (double_precision)), pointer interface private pure module function double_precision_num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value integer interface private pure module function double_precision_to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value type(string_t), allocatable, (:) interface private module function double_precision_weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value double precision, allocatable, (:) Derived Types type, public :: neuron_t linked list of neurons Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real real(kind=k), private :: bias_ type( neuron_t (k)), private, allocatable :: next real(kind=k), private, allocatable :: weights_ (:) Constructor private\n\n                    pure, module\n                    function default_real_from_components (weights, bias) construct single neuron_t object from an array of weights and a bias private\n\n                    pure, module\n                    function double_precision_from_components (weights, bias) construct single neuron_t object from an array of weights and a bias private\n\n                    pure, recursive, module\n                    function double_precision_from_json (neuron_lines, start) construct linked list of neuron_t objects from an array of JSON-formatted text lines private\n\n                    pure, recursive, module\n                    function from_json (neuron_lines, start) construct linked list of neuron_t objects from an array of JSON-formatted text lines Type-Bound Procedures generic, public :: bias => default_real_bias , double_precision_bias generic, public :: next_allocated => default_real_next_allocated , double_precision_next_allocated generic, public :: next_pointer => default_real_next_pointer , double_precision_next_pointer generic, public :: num_inputs => default_real_num_inputs , double_precision_num_inputs generic, public :: to_json => default_real_to_json , double_precision_to_json generic, public :: weights => default_real_weights , double_precision_weights procedure, private :: default_real_bias procedure, private :: default_real_next_allocated procedure, private :: default_real_next_pointer procedure, private :: default_real_num_inputs procedure, private :: default_real_to_json procedure, private :: default_real_weights procedure, private :: double_precision_bias procedure, private :: double_precision_next_allocated procedure, private :: double_precision_next_pointer procedure, private :: double_precision_num_inputs procedure, private :: double_precision_to_json procedure, private :: double_precision_weights","tags":"","loc":"module/neuron_m.html"},{"title":"neural_network_m – Fiats","text":"Define an abstraction that supports inference operations on a neural network Uses double_precision_file_m activation_m tensor_m julienne_m kind_parameters_m mini_batch_m tensor_map_m metadata_m module~~neural_network_m~~UsesGraph module~neural_network_m neural_network_m julienne_m julienne_m module~neural_network_m->julienne_m module~activation_m activation_m module~neural_network_m->module~activation_m module~double_precision_file_m double_precision_file_m module~neural_network_m->module~double_precision_file_m module~kind_parameters_m kind_parameters_m module~neural_network_m->module~kind_parameters_m module~metadata_m metadata_m module~neural_network_m->module~metadata_m module~mini_batch_m mini_batch_m module~neural_network_m->module~mini_batch_m module~tensor_m tensor_m module~neural_network_m->module~tensor_m module~tensor_map_m tensor_map_m module~neural_network_m->module~tensor_map_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding module~double_precision_file_m->julienne_m module~double_precision_string_m double_precision_string_m module~double_precision_file_m->module~double_precision_string_m julienne_string_m julienne_string_m module~metadata_m->julienne_string_m module~metadata_m->module~double_precision_string_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->julienne_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->module~tensor_m module~tensor_map_m->module~double_precision_string_m module~double_precision_string_m->julienne_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: unmapped_network_s workspace_s neural_network_s module~~neural_network_m~~UsedByGraph module~neural_network_m neural_network_m module~fiats_m fiats_m module~fiats_m->module~neural_network_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~layer_m layer_m module~layer_m->module~neural_network_m module~neural_network_s neural_network_s module~neural_network_s->module~neural_network_m module~neural_network_s->module~layer_m module~trainable_network_m->module~neural_network_m module~unmapped_network_s unmapped_network_s module~unmapped_network_s->module~neural_network_m module~workspace_s workspace_s module~workspace_s->module~neural_network_m module~addition_m addition_m module~addition_m->module~fiats_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~fiats_m module~layer_s layer_s module~layer_s->module~layer_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~fiats_m module~power_series power_series module~power_series->module~fiats_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~fiats_m module~trainable_network_s trainable_network_s module~trainable_network_s->module~trainable_network_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~fiats_m program~learn_addition learn_addition program~learn_addition->module~fiats_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~fiats_m program~learn_exponentiation->module~exponentiation_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~fiats_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~fiats_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~fiats_m program~read_query_infer read_query_infer program~read_query_infer->module~fiats_m program~train_and_write train_and_write program~train_and_write->module~fiats_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~fiats_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~fiats_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface neural_network_t private module function default_real_construct_from_components(metadata, weights, biases, nodes, input_map, output_map) result(neural_network) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real, intent(in) :: weights (:,:,:) real, intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) type( tensor_map_t ), intent(in), optional :: input_map type( tensor_map_t ), intent(in), optional :: output_map Return Value type( neural_network_t ) private impure elemental module function default_real_from_json(file_) result(neural_network) Implementation → Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( neural_network_t ) private module function double_precision_construct_from_components(metadata, weights, biases, nodes, input_map, output_map) result(neural_network) Implementation → Arguments Type Intent Optional Attributes Name type( metadata_t ), intent(in) :: metadata double precision, intent(in) :: weights (:,:,:) double precision, intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) type( tensor_map_t (double_precision)), intent(in), optional :: input_map type( tensor_map_t (double_precision)), intent(in), optional :: output_map Return Value type( neural_network_t (double_precision)) private impure elemental module function double_precision_from_json(file) result(neural_network) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_file_t ), intent(in) :: file Return Value type( neural_network_t (double_precision)) public        interface unmapped_network_t private impure elemental module function double_precision_unmapped_from_json(file) result(unmapped_network) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_file_t ), intent(in) :: file Return Value type( unmapped_network_t (double_precision)) public        interface workspace_t private pure module function default_real_workspace(neural_network) result(workspace) Implementation → Arguments Type Intent Optional Attributes Name type( neural_network_t ), intent(in) :: neural_network Return Value type( workspace_t ) interface private elemental module function default_real_activation_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value type(string_t) interface private module subroutine default_real_allocate(self, neural_network) Implementation → Arguments Type Intent Optional Attributes Name class( workspace_t ), intent(inout) :: self type( neural_network_t ), intent(in) :: neural_network interface private pure module function default_real_allocated(self) result(all_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( workspace_t ), intent(in) :: self Return Value logical interface private elemental module function default_real_approximately_equal(lhs, rhs) result(lhs_eq_rhs) Implementation → The result is true if lhs and rhs are the same to within a tolerance Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: lhs class( neural_network_t ), intent(in) :: rhs Return Value logical interface private elemental module subroutine default_real_assert_conformable_with(self, neural_network) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self type( neural_network_t ), intent(in) :: neural_network interface private pure module subroutine default_real_consistency(self) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self interface private elemental module function default_real_infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) interface private elemental module function default_real_infer_unmapped(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( unmapped_network_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) interface private pure module subroutine default_real_learn(self, mini_batches_arr, cost, adam, learning_rate, workspace) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches_arr (:) real, intent(out), optional, allocatable :: cost (:) logical, intent(in) :: adam real, intent(in) :: learning_rate type( workspace_t ), intent(inout) :: workspace interface private elemental module function default_real_map_from_output_range(self, normalized_tensor) result(tensor) Implementation → The result contains the output tensor values unmapped via the inverse of the mapping used in training Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self type( tensor_t ), intent(in) :: normalized_tensor Return Value type( tensor_t ) interface private elemental module function default_real_map_to_input_range(self, tensor) result(normalized_tensor) Implementation → The result contains the input tensor values normalized to fall on the range used during training Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) interface private pure module function default_real_nodes_per_layer(self) result(node_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value integer, allocatable, (:) interface private elemental module function default_real_num_hidden_layers(self) result(hidden_layer_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value integer interface private elemental module function default_real_num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value integer interface private elemental module function default_real_num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value integer interface private pure module function default_real_skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value logical interface private impure elemental module function default_real_to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value type(file_t) interface private elemental module function double_precision_activation_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value type(string_t) interface private elemental module function double_precision_approximately_equal(lhs, rhs) result(lhs_eq_rhs) Implementation → The result is true if lhs and rhs are the same to within a tolerance Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: lhs class( neural_network_t (double_precision)), intent(in) :: rhs Return Value logical interface private elemental module subroutine double_precision_assert_conformable_with(self, neural_network) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self type( neural_network_t (double_precision)), intent(in) :: neural_network interface private pure module subroutine double_precision_consistency(self) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self interface private elemental module function double_precision_infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: inputs Return Value type( tensor_t (double_precision)) interface private elemental module function double_precision_infer_unmapped(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( unmapped_network_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: inputs Return Value type( tensor_t (double_precision)) interface private elemental module function double_precision_map_from_output_range(self, normalized_tensor) result(tensor) Implementation → The result contains the output tensor values unmapped via the inverse of the mapping used in training Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: normalized_tensor Return Value type( tensor_t (double_precision)) interface private elemental module function double_precision_map_to_input_range(self, tensor) result(normalized_tensor) Implementation → The result contains the input tensor values normalized to fall on the range used during training Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: tensor Return Value type( tensor_t (double_precision)) interface private pure module function double_precision_nodes_per_layer(self) result(node_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value integer, allocatable, (:) interface private elemental module function double_precision_num_hidden_layers(self) result(hidden_layer_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value integer interface private elemental module function double_precision_num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value integer interface private elemental module function double_precision_num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value integer interface private pure module function double_precision_skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value logical interface private impure elemental module function double_precision_to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value type(file_t) Derived Types type, public :: neural_network_t Encapsulate the information needed to perform inference Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real type( activation_t ), private :: activation_ real(kind=k), private, allocatable :: biases_ (:,:) type( tensor_map_t (k)), private :: input_map_ type( metadata_t ), private :: metadata_ integer, private, allocatable :: nodes_ (:) type( tensor_map_t (k)), private :: output_map_ real(kind=k), private, allocatable :: weights_ (:,:,:) Constructor private\n\n                    module\n                    function default_real_construct_from_components (metadata, weights, biases, nodes, input_map, output_map) private\n\n                    impure, elemental, module\n                    function default_real_from_json (file_) private\n\n                    module\n                    function double_precision_construct_from_components (metadata, weights, biases, nodes, input_map, output_map) private\n\n                    impure, elemental, module\n                    function double_precision_from_json (file) Type-Bound Procedures generic, public :: activation_function_name => default_real_activation_name , double_precision_activation_name generic, public :: assert_conformable_with => default_real_assert_conformable_with , double_precision_assert_conformable_with generic, public :: assert_consistency => default_real_consistency , double_precision_consistency generic, public :: infer => default_real_infer , double_precision_infer generic, public :: learn => default_real_learn generic, public :: map_from_output_range => default_real_map_from_output_range , double_precision_map_from_output_range generic, public :: map_to_input_range => default_real_map_to_input_range , double_precision_map_to_input_range generic, public :: nodes_per_layer => default_real_nodes_per_layer , double_precision_nodes_per_layer generic, public :: num_hidden_layers => default_real_num_hidden_layers , double_precision_num_hidden_layers generic, public :: num_inputs => default_real_num_inputs , double_precision_num_inputs generic, public :: num_outputs => default_real_num_outputs , double_precision_num_outputs generic, public :: operator(==) => default_real_approximately_equal , double_precision_approximately_equal generic, public :: skip => default_real_skip , double_precision_skip generic, public :: to_json => default_real_to_json , double_precision_to_json procedure, private, non_overridable :: default_real_activation_name procedure, private, non_overridable :: default_real_approximately_equal procedure, private, non_overridable :: default_real_assert_conformable_with procedure, private, non_overridable :: default_real_consistency procedure, private, non_overridable :: default_real_infer procedure, private, non_overridable :: default_real_learn procedure, private, non_overridable :: default_real_map_from_output_range procedure, private, non_overridable :: default_real_map_to_input_range procedure, private, non_overridable :: default_real_nodes_per_layer procedure, private, non_overridable :: default_real_num_hidden_layers procedure, private, non_overridable :: default_real_num_inputs procedure, private, non_overridable :: default_real_num_outputs procedure, private, non_overridable :: default_real_skip procedure, private, non_overridable :: default_real_to_json procedure, private, non_overridable :: double_precision_activation_name procedure, private, non_overridable :: double_precision_approximately_equal procedure, private, non_overridable :: double_precision_assert_conformable_with procedure, private, non_overridable :: double_precision_consistency procedure, private, non_overridable :: double_precision_infer procedure, private, non_overridable :: double_precision_map_from_output_range procedure, private, non_overridable :: double_precision_map_to_input_range procedure, private, non_overridable :: double_precision_nodes_per_layer procedure, private, non_overridable :: double_precision_num_hidden_layers procedure, private, non_overridable :: double_precision_num_inputs procedure, private, non_overridable :: double_precision_num_outputs procedure, private, non_overridable :: double_precision_skip procedure, private, non_overridable :: double_precision_to_json type, public :: unmapped_network_t Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real type( neural_network_t (k)), private :: neural_network_ Constructor private\n\n                    impure, elemental, module\n                    function double_precision_unmapped_from_json (file) Type-Bound Procedures generic, public :: infer => default_real_infer_unmapped , double_precision_infer_unmapped procedure, private, non_overridable :: default_real_infer_unmapped procedure, private, non_overridable :: double_precision_infer_unmapped type, public :: workspace_t Components Type Visibility Attributes Name Initial real(kind=k), public, allocatable, dimension(:,:) :: a real(kind=k), public, allocatable, dimension(:,:) :: dcdb real(kind=k), public, allocatable, dimension(:,:,:) :: dcdw real(kind=k), public, allocatable, dimension(:,:) :: delta integer, public, kind :: k = default_real real(kind=k), public, allocatable, dimension(:,:) :: sdb real(kind=k), public, allocatable, dimension(:,:) :: sdbc real(kind=k), public, allocatable, dimension(:,:,:) :: sdw real(kind=k), public, allocatable, dimension(:,:,:) :: sdwc real(kind=k), public, allocatable, dimension(:,:) :: vdb real(kind=k), public, allocatable, dimension(:,:) :: vdbc real(kind=k), public, allocatable, dimension(:,:,:) :: vdw real(kind=k), public, allocatable, dimension(:,:,:) :: vdwc real(kind=k), public, allocatable, dimension(:,:) :: z Constructor private\n\n                    pure, module\n                    function default_real_workspace (neural_network) Type-Bound Procedures generic, public :: allocate_if_necessary => default_real_allocate generic, public :: fully_allocated => default_real_allocated procedure, private, non_overridable :: default_real_allocate procedure, private, non_overridable :: default_real_allocated","tags":"","loc":"module/neural_network_m.html"},{"title":"tensor_map_m – Fiats","text":"Uses tensor_m double_precision_string_m julienne_m kind_parameters_m module~~tensor_map_m~~UsesGraph module~tensor_map_m tensor_map_m julienne_m julienne_m module~tensor_map_m->julienne_m module~double_precision_string_m double_precision_string_m module~tensor_map_m->module~double_precision_string_m module~kind_parameters_m kind_parameters_m module~tensor_map_m->module~kind_parameters_m module~tensor_m tensor_m module~tensor_map_m->module~tensor_m module~double_precision_string_m->julienne_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: tensor_map_s module~~tensor_map_m~~UsedByGraph module~tensor_map_m tensor_map_m module~fiats_m fiats_m module~fiats_m->module~tensor_map_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~layer_m layer_m module~layer_m->module~tensor_map_m module~layer_m->module~neural_network_m module~neural_network_m->module~tensor_map_m module~tensor_map_s tensor_map_s module~tensor_map_s->module~tensor_map_m module~trainable_network_m->module~tensor_map_m module~trainable_network_m->module~neural_network_m module~addition_m addition_m module~addition_m->module~fiats_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~fiats_m module~layer_s layer_s module~layer_s->module~layer_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~fiats_m module~neural_network_s neural_network_s module~neural_network_s->module~layer_m module~neural_network_s->module~neural_network_m module~power_series power_series module~power_series->module~fiats_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~fiats_m module~trainable_network_s trainable_network_s module~trainable_network_s->module~trainable_network_m module~unmapped_network_s unmapped_network_s module~unmapped_network_s->module~neural_network_m module~workspace_s workspace_s module~workspace_s->module~neural_network_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~fiats_m program~learn_addition learn_addition program~learn_addition->module~fiats_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~fiats_m program~learn_exponentiation->module~exponentiation_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~fiats_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~fiats_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~fiats_m program~read_query_infer read_query_infer program~read_query_infer->module~fiats_m program~train_and_write train_and_write program~train_and_write->module~fiats_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~fiats_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~fiats_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface tensor_map_t private pure module function construct_default_real(layer, minima, maxima) result(tensor_map) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: layer real, intent(in), dimension(:) :: minima real, intent(in), dimension(:) :: maxima Return Value type( tensor_map_t ) private pure module function construct_double_precision(layer, minima, maxima) result(tensor_map) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: layer double precision, intent(in), dimension(:) :: minima double precision, intent(in), dimension(:) :: maxima Return Value type( tensor_map_t (double_precision)) private module function double_precision_from_json(lines) result(tensor_map) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: lines (:) Return Value type( tensor_map_t (double_precision)) private module function from_json(lines) result(tensor_map) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( tensor_map_t ) interface private elemental module function default_real_equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t ), intent(in) :: lhs class( tensor_map_t ), intent(in) :: rhs Return Value logical interface private elemental module function default_real_map_from_training_range(self, tensor) result(unnormalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) interface private elemental module function default_real_map_to_training_range(self, tensor) result(normalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) interface private pure module function default_real_to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) interface private elemental module function double_precision_equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t (double_precision)), intent(in) :: lhs class( tensor_map_t (double_precision)), intent(in) :: rhs Return Value logical interface private elemental module function double_precision_map_from_training_range(self, tensor) result(unnormalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: tensor Return Value type( tensor_t (double_precision)) interface private elemental module function double_precision_map_to_training_range(self, tensor) result(normalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: tensor Return Value type( tensor_t (double_precision)) interface private pure module function double_precision_to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_map_t (double_precision)), intent(in) :: self Return Value type(string_t), allocatable, (:) Derived Types type, public :: tensor_map_t Components Type Visibility Attributes Name Initial integer, public, kind :: k = default_real real(kind=k), private, dimension(:), allocatable :: intercept_ character(len=:), private, allocatable :: layer_ real(kind=k), private, dimension(:), allocatable :: slope_ Constructor private\n\n                    pure, module\n                    function construct_default_real (layer, minima, maxima) private\n\n                    pure, module\n                    function construct_double_precision (layer, minima, maxima) private\n\n                    module\n                    function double_precision_from_json (lines) private\n\n                    module\n                    function from_json (lines) Type-Bound Procedures generic, public :: map_from_training_range => default_real_map_from_training_range , double_precision_map_from_training_range generic, public :: map_to_training_range => default_real_map_to_training_range , double_precision_map_to_training_range generic, public :: operator(==) => default_real_equals , double_precision_equals generic, public :: to_json => default_real_to_json , double_precision_to_json procedure, private :: default_real_equals procedure, private, non_overridable :: default_real_map_from_training_range procedure, private, non_overridable :: default_real_map_to_training_range procedure, private :: default_real_to_json procedure, private :: double_precision_equals procedure, private, non_overridable :: double_precision_map_from_training_range procedure, private, non_overridable :: double_precision_map_to_training_range procedure, private :: double_precision_to_json","tags":"","loc":"module/tensor_map_m.html"},{"title":"metadata_m – Fiats","text":"Uses double_precision_string_m julienne_string_m module~~metadata_m~~UsesGraph module~metadata_m metadata_m julienne_string_m julienne_string_m module~metadata_m->julienne_string_m module~double_precision_string_m double_precision_string_m module~metadata_m->module~double_precision_string_m julienne_m julienne_m module~double_precision_string_m->julienne_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: metadata_s module~~metadata_m~~UsedByGraph module~metadata_m metadata_m module~fiats_m fiats_m module~fiats_m->module~metadata_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~layer_m layer_m module~layer_m->module~metadata_m module~layer_m->module~neural_network_m module~metadata_s metadata_s module~metadata_s->module~metadata_m module~neural_network_m->module~metadata_m module~addition_m addition_m module~addition_m->module~fiats_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~fiats_m module~layer_s layer_s module~layer_s->module~layer_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~fiats_m module~neural_network_s neural_network_s module~neural_network_s->module~layer_m module~neural_network_s->module~neural_network_m module~power_series power_series module~power_series->module~fiats_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~fiats_m module~trainable_network_m->module~neural_network_m module~unmapped_network_s unmapped_network_s module~unmapped_network_s->module~neural_network_m module~workspace_s workspace_s module~workspace_s->module~neural_network_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~fiats_m program~learn_addition learn_addition program~learn_addition->module~fiats_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~fiats_m program~learn_exponentiation->module~exponentiation_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~fiats_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~fiats_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~fiats_m program~read_query_infer read_query_infer program~read_query_infer->module~fiats_m program~train_and_write train_and_write program~train_and_write->module~fiats_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~fiats_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~fiats_m module~trainable_network_s trainable_network_s module~trainable_network_s->module~trainable_network_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface metadata_t private pure module function double_precision_from_json(lines) result(metadata) Implementation → Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: lines (:) Return Value type( metadata_t ) private pure module function from_components(modelName, modelAuthor, compilationDate, activationFunction, usingSkipConnections) result(metadata) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: modelName type(string_t), intent(in) :: modelAuthor type(string_t), intent(in) :: compilationDate type(string_t), intent(in) :: activationFunction type(string_t), intent(in) :: usingSkipConnections Return Value type( metadata_t ) private pure module function from_json(lines) result(metadata) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( metadata_t ) interface private pure module function activation_name(self) result(function_name) Implementation → Arguments Type Intent Optional Attributes Name class( metadata_t ), intent(in) :: self Return Value type(string_t) interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( metadata_t ), intent(in) :: lhs class( metadata_t ), intent(in) :: rhs Return Value logical interface private pure module function strings(self) result(components) Implementation → Arguments Type Intent Optional Attributes Name class( metadata_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) interface private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( metadata_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Derived Types type, public :: metadata_t Components Type Visibility Attributes Name Initial type(string_t), private :: activationFunction_ type(string_t), private :: compilationDate_ type(string_t), private :: modelAuthor_ type(string_t), private :: modelName_ type(string_t), private :: usingSkipConnections_ Constructor private\n\n                    pure, module\n                    function double_precision_from_json (lines) private\n\n                    pure, module\n                    function from_components (modelName, modelAuthor, compilationDate, activationFunction, usingSkipConnections) private\n\n                    pure, module\n                    function from_json (lines) Type-Bound Procedures procedure, public :: activation_name generic, public :: operator(==) => equals procedure, public :: strings procedure, public :: to_json procedure, private :: equals","tags":"","loc":"module/metadata_m.html"},{"title":"tensor_s – Fiats","text":"Uses Ancestors: tensor_m module~~tensor_s~~UsesGraph module~tensor_s tensor_s module~tensor_m tensor_m module~tensor_s->module~tensor_m module~kind_parameters_m kind_parameters_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_s.html construct_default_real pure module function construct_default_real(values) result(tensor) Arguments Type Intent Optional Attributes Name real, intent(in) :: values (:) Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_s.html construct_double_precision pure module function construct_double_precision(values) result(tensor) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: values (:) Return Value type( tensor_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_s.html default_real_num_components pure module function default_real_num_components(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_s.html default_real_values pure module function default_real_values(self) result(tensor_values) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real, allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_s.html double_precision_num_components pure module function double_precision_num_components(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t (double_precision)), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_s.html double_precision_values pure module function double_precision_values(self) result(tensor_values) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t (double_precision)), intent(in) :: self Return Value double precision, allocatable, (:)","tags":"","loc":"module/tensor_s.html"},{"title":"neural_network_s – Fiats","text":"Uses layer_m assert_m kind_parameters_m double_precision_string_m neuron_m Ancestors: neural_network_m module~~neural_network_s~~UsesGraph module~neural_network_s neural_network_s assert_m assert_m module~neural_network_s->assert_m module~double_precision_string_m double_precision_string_m module~neural_network_s->module~double_precision_string_m module~kind_parameters_m kind_parameters_m module~neural_network_s->module~kind_parameters_m module~layer_m layer_m module~neural_network_s->module~layer_m module~neural_network_m neural_network_m module~neural_network_s->module~neural_network_m module~neuron_m neuron_m module~neural_network_s->module~neuron_m julienne_m julienne_m module~double_precision_string_m->julienne_m module~layer_m->module~double_precision_string_m module~layer_m->module~kind_parameters_m module~layer_m->module~neural_network_m module~layer_m->module~neuron_m julienne_string_m julienne_string_m module~layer_m->julienne_string_m module~metadata_m metadata_m module~layer_m->module~metadata_m module~tensor_map_m tensor_map_m module~layer_m->module~tensor_map_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->julienne_m module~activation_m activation_m module~neural_network_m->module~activation_m module~double_precision_file_m double_precision_file_m module~neural_network_m->module~double_precision_file_m module~neural_network_m->module~metadata_m module~mini_batch_m mini_batch_m module~neural_network_m->module~mini_batch_m module~tensor_m tensor_m module~neural_network_m->module~tensor_m module~neural_network_m->module~tensor_map_m module~neuron_m->module~double_precision_string_m module~neuron_m->module~kind_parameters_m module~neuron_m->julienne_string_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding module~double_precision_file_m->module~double_precision_string_m module~double_precision_file_m->julienne_m module~metadata_m->module~double_precision_string_m module~metadata_m->julienne_string_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->julienne_m module~tensor_map_m->module~tensor_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: input_layer = 0 character(len=*), private, parameter :: minimum_acceptable_tag = \"0.15.0\" Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html default_real_activation_name elemental module function default_real_activation_name(self) result(activation_name) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value type(string_t) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html default_real_approximately_equal elemental module function default_real_approximately_equal(lhs, rhs) result(lhs_eq_rhs) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: lhs class( neural_network_t ), intent(in) :: rhs Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html default_real_assert_conformable_with elemental module subroutine default_real_assert_conformable_with(self, neural_network) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self type( neural_network_t ), intent(in) :: neural_network module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html default_real_consistency pure module subroutine default_real_consistency(self) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html default_real_construct_from_components module function default_real_construct_from_components(metadata, weights, biases, nodes, input_map, output_map) result(neural_network) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real, intent(in) :: weights (:,:,:) real, intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) type( tensor_map_t ), intent(in), optional :: input_map type( tensor_map_t ), intent(in), optional :: output_map Return Value type( neural_network_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html default_real_from_json impure elemental module function default_real_from_json(file_) result(neural_network) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( neural_network_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html default_real_infer elemental module function default_real_infer(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html default_real_learn pure module subroutine default_real_learn(self, mini_batches_arr, cost, adam, learning_rate, workspace) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches_arr (:) real, intent(out), optional, allocatable :: cost (:) logical, intent(in) :: adam real, intent(in) :: learning_rate type( workspace_t ), intent(inout) :: workspace module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html default_real_map_from_output_range elemental module function default_real_map_from_output_range(self, normalized_tensor) result(tensor) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self type( tensor_t ), intent(in) :: normalized_tensor Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html default_real_map_to_input_range elemental module function default_real_map_to_input_range(self, tensor) result(normalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html default_real_nodes_per_layer pure module function default_real_nodes_per_layer(self) result(node_count) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value integer, allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html default_real_num_hidden_layers elemental module function default_real_num_hidden_layers(self) result(hidden_layer_count) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html default_real_num_inputs elemental module function default_real_num_inputs(self) result(input_count) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html default_real_num_outputs elemental module function default_real_num_outputs(self) result(output_count) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html default_real_skip pure module function default_real_skip(self) result(use_skip_connections) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html default_real_to_json impure elemental module function default_real_to_json(self) result(json_file) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: self Return Value type(file_t) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html double_precision_activation_name elemental module function double_precision_activation_name(self) result(activation_name) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value type(string_t) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html double_precision_approximately_equal elemental module function double_precision_approximately_equal(lhs, rhs) result(lhs_eq_rhs) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: lhs class( neural_network_t (double_precision)), intent(in) :: rhs Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html double_precision_assert_conformable_with elemental module subroutine double_precision_assert_conformable_with(self, neural_network) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self type( neural_network_t (double_precision)), intent(in) :: neural_network module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html double_precision_consistency pure module subroutine double_precision_consistency(self) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html double_precision_construct_from_components module function double_precision_construct_from_components(metadata, weights, biases, nodes, input_map, output_map) result(neural_network) Arguments Type Intent Optional Attributes Name type( metadata_t ), intent(in) :: metadata double precision, intent(in) :: weights (:,:,:) double precision, intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) type( tensor_map_t (double_precision)), intent(in), optional :: input_map type( tensor_map_t (double_precision)), intent(in), optional :: output_map Return Value type( neural_network_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html double_precision_from_json impure elemental module function double_precision_from_json(file) result(neural_network) Arguments Type Intent Optional Attributes Name type( double_precision_file_t ), intent(in) :: file Return Value type( neural_network_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html double_precision_infer elemental module function double_precision_infer(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: inputs Return Value type( tensor_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html double_precision_map_from_output_range elemental module function double_precision_map_from_output_range(self, normalized_tensor) result(tensor) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: normalized_tensor Return Value type( tensor_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html double_precision_map_to_input_range elemental module function double_precision_map_to_input_range(self, tensor) result(normalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: tensor Return Value type( tensor_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html double_precision_nodes_per_layer pure module function double_precision_nodes_per_layer(self) result(node_count) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value integer, allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html double_precision_num_hidden_layers elemental module function double_precision_num_hidden_layers(self) result(hidden_layer_count) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html double_precision_num_inputs elemental module function double_precision_num_inputs(self) result(input_count) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html double_precision_num_outputs elemental module function double_precision_num_outputs(self) result(output_count) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html double_precision_skip pure module function double_precision_skip(self) result(use_skip_connections) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neural_network_s.html double_precision_to_json impure elemental module function double_precision_to_json(self) result(json_file) Interface → Arguments Type Intent Optional Attributes Name class( neural_network_t (double_precision)), intent(in) :: self Return Value type(file_t)","tags":"","loc":"module/neural_network_s.html"},{"title":"double_precision_string_s – Fiats","text":"Uses Ancestors: double_precision_string_m module~~double_precision_string_s~~UsesGraph module~double_precision_string_s double_precision_string_s module~double_precision_string_m double_precision_string_m module~double_precision_string_s->module~double_precision_string_m julienne_m julienne_m module~double_precision_string_m->julienne_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/double_precision_string_s.html construct_from_string elemental module function construct_from_string(string) result(double_precision_string) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: string Return Value type( double_precision_string_t )","tags":"","loc":"module/double_precision_string_s.html"},{"title":"double_precision_file_s – Fiats","text":"Uses Ancestors: double_precision_file_m module~~double_precision_file_s~~UsesGraph module~double_precision_file_s double_precision_file_s module~double_precision_file_m double_precision_file_m module~double_precision_file_s->module~double_precision_file_m julienne_m julienne_m module~double_precision_file_m->julienne_m module~double_precision_string_m double_precision_string_m module~double_precision_file_m->module~double_precision_string_m module~double_precision_string_m->julienne_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/double_precision_file_s.html construct_from_character impure elemental module function construct_from_character(file_name) result(double_precision_file) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value type( double_precision_file_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/double_precision_file_s.html construct_from_string impure elemental module function construct_from_string(file_name) result(double_precision_file) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: file_name Return Value type( double_precision_file_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/double_precision_file_s.html double_precision_lines pure module function double_precision_lines(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( double_precision_file_t ), intent(in) :: self Return Value type( double_precision_string_t ), allocatable, (:)","tags":"","loc":"module/double_precision_file_s.html"},{"title":"trainable_network_s – Fiats","text":"Uses Ancestors: trainable_network_m module~~trainable_network_s~~UsesGraph module~trainable_network_s trainable_network_s module~trainable_network_m trainable_network_m module~trainable_network_s->module~trainable_network_m julienne_m julienne_m module~trainable_network_m->julienne_m module~input_output_pair_m input_output_pair_m module~trainable_network_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~trainable_network_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~trainable_network_m->module~mini_batch_m module~neural_network_m neural_network_m module~trainable_network_m->module~neural_network_m module~tensor_map_m tensor_map_m module~trainable_network_m->module~tensor_map_m module~training_configuration_m training_configuration_m module~trainable_network_m->module~training_configuration_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~neural_network_m->julienne_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~mini_batch_m module~neural_network_m->module~tensor_map_m module~activation_m activation_m module~neural_network_m->module~activation_m module~double_precision_file_m double_precision_file_m module~neural_network_m->module~double_precision_file_m module~metadata_m metadata_m module~neural_network_m->module~metadata_m module~neural_network_m->module~tensor_m module~tensor_map_m->julienne_m module~tensor_map_m->module~kind_parameters_m module~double_precision_string_m double_precision_string_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~tensor_m module~training_configuration_m->module~kind_parameters_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m julienne_string_m julienne_string_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~activation_m module~training_configuration_m->module~double_precision_file_m module~hyperparameters_m hyperparameters_m module~training_configuration_m->module~hyperparameters_m module~network_configuration_m network_configuration_m module~training_configuration_m->module~network_configuration_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding module~double_precision_file_m->julienne_m module~double_precision_file_m->module~double_precision_string_m module~double_precision_string_m->julienne_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~hyperparameters_m->module~double_precision_string_m module~metadata_m->julienne_string_m module~metadata_m->module~double_precision_string_m module~network_configuration_m->julienne_string_m module~network_configuration_m->module~double_precision_string_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/trainable_network_s.html default_real_map_to_training_ranges elemental module function default_real_map_to_training_ranges(self, input_output_pair) result(normalized_input_output_pair) Interface → Arguments Type Intent Optional Attributes Name class( trainable_network_t ), intent(in) :: self type( input_output_pair_t ), intent(in) :: input_output_pair Return Value type( input_output_pair_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/trainable_network_s.html default_real_network pure module function default_real_network(neural_network) result(trainable_network) Arguments Type Intent Optional Attributes Name type( neural_network_t ), intent(in) :: neural_network Return Value type( trainable_network_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/trainable_network_s.html default_real_train pure module subroutine default_real_train(self, mini_batches_arr, cost, adam, learning_rate) Interface → Arguments Type Intent Optional Attributes Name class( trainable_network_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches_arr (:) real, intent(out), optional, allocatable :: cost (:) logical, intent(in) :: adam real, intent(in) :: learning_rate module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/trainable_network_s.html perturbed_identity_network module function perturbed_identity_network(training_configuration, perturbation_magnitude, metadata, input_map, output_map) result(trainable_network) Arguments Type Intent Optional Attributes Name type( training_configuration_t ), intent(in) :: training_configuration real, intent(in) :: perturbation_magnitude type(string_t), intent(in) :: metadata (:) type( tensor_map_t ) :: input_map type( tensor_map_t ) :: output_map Return Value type( trainable_network_t )","tags":"","loc":"module/trainable_network_s.html"},{"title":"tensor_map_s – Fiats","text":"Uses assert_m julienne_m kind_parameters_m Ancestors: tensor_map_m module~~tensor_map_s~~UsesGraph module~tensor_map_s tensor_map_s assert_m assert_m module~tensor_map_s->assert_m julienne_m julienne_m module~tensor_map_s->julienne_m module~kind_parameters_m kind_parameters_m module~tensor_map_s->module~kind_parameters_m module~tensor_map_m tensor_map_m module~tensor_map_s->module~tensor_map_m module~tensor_map_m->julienne_m module~tensor_map_m->module~kind_parameters_m module~double_precision_string_m double_precision_string_m module~tensor_map_m->module~double_precision_string_m module~tensor_m tensor_m module~tensor_map_m->module~tensor_m module~double_precision_string_m->julienne_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_map_s.html construct_default_real pure module function construct_default_real(layer, minima, maxima) result(tensor_map) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: layer real, intent(in), dimension(:) :: minima real, intent(in), dimension(:) :: maxima Return Value type( tensor_map_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_map_s.html construct_double_precision pure module function construct_double_precision(layer, minima, maxima) result(tensor_map) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: layer double precision, intent(in), dimension(:) :: minima double precision, intent(in), dimension(:) :: maxima Return Value type( tensor_map_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_map_s.html default_real_equals elemental module function default_real_equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( tensor_map_t ), intent(in) :: lhs class( tensor_map_t ), intent(in) :: rhs Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_map_s.html default_real_map_from_training_range elemental module function default_real_map_from_training_range(self, tensor) result(unnormalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( tensor_map_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_map_s.html default_real_map_to_training_range elemental module function default_real_map_to_training_range(self, tensor) result(normalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( tensor_map_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_map_s.html default_real_to_json pure module function default_real_to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( tensor_map_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_map_s.html double_precision_equals elemental module function double_precision_equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( tensor_map_t (double_precision)), intent(in) :: lhs class( tensor_map_t (double_precision)), intent(in) :: rhs Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_map_s.html double_precision_from_json module function double_precision_from_json(lines) result(tensor_map) Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: lines (:) Return Value type( tensor_map_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_map_s.html double_precision_map_from_training_range elemental module function double_precision_map_from_training_range(self, tensor) result(unnormalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( tensor_map_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: tensor Return Value type( tensor_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_map_s.html double_precision_map_to_training_range elemental module function double_precision_map_to_training_range(self, tensor) result(normalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( tensor_map_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: tensor Return Value type( tensor_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_map_s.html double_precision_to_json pure module function double_precision_to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( tensor_map_t (double_precision)), intent(in) :: self Return Value type(string_t), allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_map_s.html from_json module function from_json(lines) result(tensor_map) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( tensor_map_t )","tags":"","loc":"module/tensor_map_s.html"},{"title":"input_output_pair_s – Fiats","text":"Uses Ancestors: input_output_pair_m module~~input_output_pair_s~~UsesGraph module~input_output_pair_s input_output_pair_s module~input_output_pair_m input_output_pair_m module~input_output_pair_s->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/input_output_pair_s.html default_real_construct elemental module function default_real_construct(inputs, expected_outputs) result(input_output_pair) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/input_output_pair_s.html default_real_expected_outputs elemental module function default_real_expected_outputs(self) result(my_expected_outputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/input_output_pair_s.html default_real_inputs elemental module function default_real_inputs(self) result(my_inputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/input_output_pair_s.html default_real_shuffle module subroutine default_real_shuffle(pairs) Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(inout) :: pairs (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/input_output_pair_s.html default_real_write_to_stdout module subroutine default_real_write_to_stdout(input_output_pairs) Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/input_output_pair_s.html double_precision_construct elemental module function double_precision_construct(inputs, expected_outputs) result(input_output_pair) Arguments Type Intent Optional Attributes Name type( tensor_t (double_precision)), intent(in) :: inputs type( tensor_t (double_precision)), intent(in) :: expected_outputs Return Value type( input_output_pair_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/input_output_pair_s.html double_precision_expected_outputs elemental module function double_precision_expected_outputs(self) result(my_expected_outputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t (double_precision)), intent(in) :: self Return Value type( tensor_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/input_output_pair_s.html double_precision_inputs elemental module function double_precision_inputs(self) result(my_inputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t (double_precision)), intent(in) :: self Return Value type( tensor_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/input_output_pair_s.html double_precision_shuffle module subroutine double_precision_shuffle(pairs) Arguments Type Intent Optional Attributes Name type( input_output_pair_t (double_precision)), intent(inout) :: pairs (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/input_output_pair_s.html double_precision_write_to_stdout module subroutine double_precision_write_to_stdout(input_output_pairs) Arguments Type Intent Optional Attributes Name type( input_output_pair_t (double_precision)), intent(in) :: input_output_pairs (:)","tags":"","loc":"module/input_output_pair_s.html"},{"title":"unmapped_network_s – Fiats","text":"Uses Ancestors: neural_network_m module~~unmapped_network_s~~UsesGraph module~unmapped_network_s unmapped_network_s module~neural_network_m neural_network_m module~unmapped_network_s->module~neural_network_m julienne_m julienne_m module~neural_network_m->julienne_m module~activation_m activation_m module~neural_network_m->module~activation_m module~double_precision_file_m double_precision_file_m module~neural_network_m->module~double_precision_file_m module~kind_parameters_m kind_parameters_m module~neural_network_m->module~kind_parameters_m module~metadata_m metadata_m module~neural_network_m->module~metadata_m module~mini_batch_m mini_batch_m module~neural_network_m->module~mini_batch_m module~tensor_m tensor_m module~neural_network_m->module~tensor_m module~tensor_map_m tensor_map_m module~neural_network_m->module~tensor_map_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding module~double_precision_file_m->julienne_m module~double_precision_string_m double_precision_string_m module~double_precision_file_m->module~double_precision_string_m julienne_string_m julienne_string_m module~metadata_m->julienne_string_m module~metadata_m->module~double_precision_string_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->julienne_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->module~tensor_m module~tensor_map_m->module~double_precision_string_m module~double_precision_string_m->julienne_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: input_layer = 0 Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/unmapped_network_s.html default_real_infer_unmapped elemental module function default_real_infer_unmapped(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( unmapped_network_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/unmapped_network_s.html double_precision_infer_unmapped elemental module function double_precision_infer_unmapped(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( unmapped_network_t (double_precision)), intent(in) :: self type( tensor_t (double_precision)), intent(in) :: inputs Return Value type( tensor_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/unmapped_network_s.html double_precision_unmapped_from_json impure elemental module function double_precision_unmapped_from_json(file) result(unmapped_network) Arguments Type Intent Optional Attributes Name type( double_precision_file_t ), intent(in) :: file Return Value type( unmapped_network_t (double_precision))","tags":"","loc":"module/unmapped_network_s.html"},{"title":"layer_s – Fiats","text":"Uses assert_m Ancestors: layer_m module~~layer_s~~UsesGraph module~layer_s layer_s assert_m assert_m module~layer_s->assert_m module~layer_m layer_m module~layer_s->module~layer_m julienne_string_m julienne_string_m module~layer_m->julienne_string_m module~double_precision_string_m double_precision_string_m module~layer_m->module~double_precision_string_m module~kind_parameters_m kind_parameters_m module~layer_m->module~kind_parameters_m module~metadata_m metadata_m module~layer_m->module~metadata_m module~neural_network_m neural_network_m module~layer_m->module~neural_network_m module~neuron_m neuron_m module~layer_m->module~neuron_m module~tensor_map_m tensor_map_m module~layer_m->module~tensor_map_m julienne_m julienne_m module~double_precision_string_m->julienne_m module~metadata_m->julienne_string_m module~metadata_m->module~double_precision_string_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~metadata_m module~neural_network_m->module~tensor_map_m module~neural_network_m->julienne_m module~activation_m activation_m module~neural_network_m->module~activation_m module~double_precision_file_m double_precision_file_m module~neural_network_m->module~double_precision_file_m module~mini_batch_m mini_batch_m module~neural_network_m->module~mini_batch_m module~tensor_m tensor_m module~neural_network_m->module~tensor_m module~neuron_m->julienne_string_m module~neuron_m->module~double_precision_string_m module~neuron_m->module~kind_parameters_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->julienne_m module~tensor_map_m->module~tensor_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding module~double_precision_file_m->module~double_precision_string_m module~double_precision_file_m->julienne_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~tensor_m->module~kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html default_real_construct_layer recursive module function default_real_construct_layer(layer_lines, start) result(layer) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ), target module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html default_real_count_inputs module function default_real_count_inputs(layer) result(num_inputs) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html default_real_count_layers module function default_real_count_layers(layer) result(num_layers) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html default_real_count_neurons module function default_real_count_neurons(layer) result(neurons_per_layer_result) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer, allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html default_real_neural_network module function default_real_neural_network(hidden_layers, metadata, output_layer, input_map, output_map) result(neural_network_) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer type( tensor_map_t ), intent(in) :: input_map type( tensor_map_t ), intent(in) :: output_map Return Value type( neural_network_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html default_real_neurons_per_layer module function default_real_neurons_per_layer(self) result(num_neurons) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html default_real_next_allocated module function default_real_next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html default_real_next_pointer module function default_real_next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ), pointer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html double_precision_construct_layer recursive module function double_precision_construct_layer(layer_lines, start) result(layer) Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t (double_precision)), target module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html double_precision_count_inputs module function double_precision_count_inputs(layer) result(num_inputs) Interface → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in) :: layer Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html double_precision_count_layers module function double_precision_count_layers(layer) result(num_layers) Interface → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: layer Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html double_precision_count_neurons module function double_precision_count_neurons(layer) result(neurons_per_layer_result) Interface → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: layer Return Value integer, allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html double_precision_neural_network module function double_precision_neural_network(hidden_layers, metadata, output_layer, input_map, output_map) result(neural_network_) Interface → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: hidden_layers type( metadata_t ), intent(in) :: metadata type( layer_t (double_precision)), intent(in), target :: output_layer type( tensor_map_t (double_precision)), intent(in) :: input_map type( tensor_map_t (double_precision)), intent(in) :: output_map Return Value type( neural_network_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html double_precision_neurons_per_layer module function double_precision_neurons_per_layer(self) result(num_neurons) Interface → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html double_precision_next_allocated module function double_precision_next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in) :: self Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html double_precision_next_pointer module function double_precision_next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( layer_t (double_precision)), intent(in), target :: self Return Value type( layer_t (double_precision)), pointer","tags":"","loc":"module/layer_s.html"},{"title":"activation_s – Fiats","text":"Uses assert_m Ancestors: activation_m module~~activation_s~~UsesGraph module~activation_s activation_s assert_m assert_m module~activation_s->assert_m module~activation_m activation_m module~activation_s->module~activation_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding julienne_m julienne_m module~activation_m->julienne_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real, private, parameter :: pi = 3.141592653589793 double precision, private, parameter :: pi_dp = 3.141592653589793D0 Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/activation_s.html construct_from_component elemental module function construct_from_component(selection) result(activation) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: selection Return Value type( activation_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/activation_s.html construct_from_name elemental module function construct_from_name(name) result(activation) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value type( activation_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/activation_s.html default_real_differentiate elemental module function default_real_differentiate(self, x) result(dy_dx) Interface → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self real, intent(in) :: x Return Value real module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/activation_s.html default_real_evaluate elemental module function default_real_evaluate(self, x) result(y) Interface → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self real, intent(in) :: x Return Value real module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/activation_s.html double_precision_differentiate elemental module function double_precision_differentiate(self, x) result(dy_dx) Interface → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self double precision, intent(in) :: x Return Value double precision module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/activation_s.html double_precision_evaluate elemental module function double_precision_evaluate(self, x) result(y) Interface → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self double precision, intent(in) :: x Return Value double precision module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/activation_s.html equals elemental module function equals(self, rhs) result(self_eq_rhs) Interface → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self type( activation_t ), intent(in) :: rhs Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/activation_s.html function_name elemental module function function_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( activation_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"module/activation_s.html"},{"title":"hyperparameters_s – Fiats","text":"Uses assert_m Ancestors: hyperparameters_m module~~hyperparameters_s~~UsesGraph module~hyperparameters_s hyperparameters_s assert_m assert_m module~hyperparameters_s->assert_m module~hyperparameters_m hyperparameters_m module~hyperparameters_s->module~hyperparameters_m julienne_string_m julienne_string_m module~hyperparameters_m->julienne_string_m module~double_precision_string_m double_precision_string_m module~hyperparameters_m->module~double_precision_string_m module~kind_parameters_m kind_parameters_m module~hyperparameters_m->module~kind_parameters_m julienne_m julienne_m module~double_precision_string_m->julienne_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: learning_rate_key = \"learning rate\" character(len=*), private, parameter :: mini_batches_key = \"mini-batches\" character(len=*), private, parameter :: optimizer_key = \"optimizer\" Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html default_real_equals elemental module function default_real_equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: lhs class( hyperparameters_t ), intent(in) :: rhs Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html default_real_from_components pure module function default_real_from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches real, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html default_real_from_json pure module function default_real_from_json(lines) result(hyperparameters) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( hyperparameters_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html default_real_learning_rate elemental module function default_real_learning_rate(self) result(rate) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value real module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html default_real_mini_batches elemental module function default_real_mini_batches(self) result(num_mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html default_real_optimizer_name elemental module function default_real_optimizer_name(self) result(identifier) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html default_real_to_json pure module function default_real_to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html double_precision_equals elemental module function double_precision_equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: lhs class( hyperparameters_t (double_precision)), intent(in) :: rhs Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html double_precision_from_components pure module function double_precision_from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches double precision, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html double_precision_from_json pure module function double_precision_from_json(lines) result(hyperparameters) Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: lines (:) Return Value type( hyperparameters_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html double_precision_learning_rate elemental module function double_precision_learning_rate(self) result(rate) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: self Return Value double precision module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html double_precision_mini_batches elemental module function double_precision_mini_batches(self) result(num_mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html double_precision_optimizer_name elemental module function double_precision_optimizer_name(self) result(identifier) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: self Return Value type(string_t) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html double_precision_to_json pure module function double_precision_to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t (double_precision)), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"module/hyperparameters_s.html"},{"title":"metadata_s – Fiats","text":"Uses assert_m Ancestors: metadata_m module~~metadata_s~~UsesGraph module~metadata_s metadata_s assert_m assert_m module~metadata_s->assert_m module~metadata_m metadata_m module~metadata_s->module~metadata_m julienne_string_m julienne_string_m module~metadata_m->julienne_string_m module~double_precision_string_m double_precision_string_m module~metadata_m->module~double_precision_string_m julienne_m julienne_m module~double_precision_string_m->julienne_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/metadata_s.html activation_name pure module function activation_name(self) result(function_name) Interface → Arguments Type Intent Optional Attributes Name class( metadata_t ), intent(in) :: self Return Value type(string_t) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/metadata_s.html double_precision_from_json pure module function double_precision_from_json(lines) result(metadata) Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: lines (:) Return Value type( metadata_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/metadata_s.html equals elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( metadata_t ), intent(in) :: lhs class( metadata_t ), intent(in) :: rhs Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/metadata_s.html from_components pure module function from_components(modelName, modelAuthor, compilationDate, activationFunction, usingSkipConnections) result(metadata) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: modelName type(string_t), intent(in) :: modelAuthor type(string_t), intent(in) :: compilationDate type(string_t), intent(in) :: activationFunction type(string_t), intent(in) :: usingSkipConnections Return Value type( metadata_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/metadata_s.html from_json pure module function from_json(lines) result(metadata) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( metadata_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/metadata_s.html strings pure module function strings(self) result(components) Interface → Arguments Type Intent Optional Attributes Name class( metadata_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/metadata_s.html to_json pure module function to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( metadata_t ), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"module/metadata_s.html"},{"title":"training_configuration_s – Fiats","text":"Uses assert_m double_precision_string_m activation_m Ancestors: training_configuration_m module~~training_configuration_s~~UsesGraph module~training_configuration_s training_configuration_s assert_m assert_m module~training_configuration_s->assert_m module~activation_m activation_m module~training_configuration_s->module~activation_m module~double_precision_string_m double_precision_string_m module~training_configuration_s->module~double_precision_string_m module~training_configuration_m training_configuration_m module~training_configuration_s->module~training_configuration_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding julienne_m julienne_m module~activation_m->julienne_m module~double_precision_string_m->julienne_m module~training_configuration_m->module~activation_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m julienne_string_m julienne_string_m module~training_configuration_m->julienne_string_m module~double_precision_file_m double_precision_file_m module~training_configuration_m->module~double_precision_file_m module~hyperparameters_m hyperparameters_m module~training_configuration_m->module~hyperparameters_m module~kind_parameters_m kind_parameters_m module~training_configuration_m->module~kind_parameters_m module~network_configuration_m network_configuration_m module~training_configuration_m->module~network_configuration_m module~double_precision_file_m->module~double_precision_string_m module~double_precision_file_m->julienne_m module~hyperparameters_m->module~double_precision_string_m module~hyperparameters_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~network_configuration_m->module~double_precision_string_m module~network_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: footer = \"}\" character(len=*), private, parameter :: header = \"{\" character(len=*), private, parameter :: separator = \",\" Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html default_real_differentiable_activation module function default_real_differentiable_activation(self) result(activation) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type( activation_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html default_real_equals elemental module function default_real_equals(lhs, rhs) result(lhs_eq_rhs) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: lhs class( training_configuration_t ), intent(in) :: rhs Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html default_real_from_components module function default_real_from_components(hyperparameters, network_configuration) result(training_configuration) Arguments Type Intent Optional Attributes Name type( hyperparameters_t ), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html default_real_from_file module function default_real_from_file(file_object) result(training_configuration) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_object Return Value type( training_configuration_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html default_real_learning_rate elemental module function default_real_learning_rate(self) result(rate) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value real module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html default_real_mini_batches elemental module function default_real_mini_batches(self) result(num_mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html default_real_nodes_per_layer pure module function default_real_nodes_per_layer(self) result(nodes) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html default_real_optimizer_name elemental module function default_real_optimizer_name(self) result(identifier) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html default_real_skip_connections elemental module function default_real_skip_connections(self) result(using_skip) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html default_real_to_json pure module function default_real_to_json(self) result(json_lines) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html double_precision_differentiable_activation module function double_precision_differentiable_activation(self) result(activation) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value type( activation_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html double_precision_equals elemental module function double_precision_equals(lhs, rhs) result(lhs_eq_rhs) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: lhs class( training_configuration_t (double_precision)), intent(in) :: rhs Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html double_precision_from_components module function double_precision_from_components(hyperparameters, network_configuration) result(training_configuration) Arguments Type Intent Optional Attributes Name type( hyperparameters_t (double_precision)), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html double_precision_from_file module function double_precision_from_file(file_object) result(training_configuration) Arguments Type Intent Optional Attributes Name type( double_precision_file_t ), intent(in) :: file_object Return Value type( training_configuration_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html double_precision_learning_rate elemental module function double_precision_learning_rate(self) result(rate) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value double precision module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html double_precision_mini_batches elemental module function double_precision_mini_batches(self) result(num_mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html double_precision_nodes_per_layer pure module function double_precision_nodes_per_layer(self) result(nodes) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value integer, allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html double_precision_optimizer_name elemental module function double_precision_optimizer_name(self) result(identifier) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value type(string_t) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html double_precision_skip_connections elemental module function double_precision_skip_connections(self) result(using_skip) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html double_precision_to_json pure module function double_precision_to_json(self) result(json_lines) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t (double_precision)), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"module/training_configuration_s.html"},{"title":"workspace_s – Fiats","text":"Uses assert_m Ancestors: neural_network_m module~~workspace_s~~UsesGraph module~workspace_s workspace_s assert_m assert_m module~workspace_s->assert_m module~neural_network_m neural_network_m module~workspace_s->module~neural_network_m julienne_m julienne_m module~neural_network_m->julienne_m module~activation_m activation_m module~neural_network_m->module~activation_m module~double_precision_file_m double_precision_file_m module~neural_network_m->module~double_precision_file_m module~kind_parameters_m kind_parameters_m module~neural_network_m->module~kind_parameters_m module~metadata_m metadata_m module~neural_network_m->module~metadata_m module~mini_batch_m mini_batch_m module~neural_network_m->module~mini_batch_m module~tensor_m tensor_m module~neural_network_m->module~tensor_m module~tensor_map_m tensor_map_m module~neural_network_m->module~tensor_map_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding module~double_precision_file_m->julienne_m module~double_precision_string_m double_precision_string_m module~double_precision_file_m->module~double_precision_string_m julienne_string_m julienne_string_m module~metadata_m->julienne_string_m module~metadata_m->module~double_precision_string_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->julienne_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->module~tensor_m module~tensor_map_m->module~double_precision_string_m module~double_precision_string_m->julienne_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: input_layer = 0 Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/workspace_s.html default_real_allocate module subroutine default_real_allocate(self, neural_network) Interface → Arguments Type Intent Optional Attributes Name class( workspace_t ), intent(inout) :: self type( neural_network_t ), intent(in) :: neural_network module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/workspace_s.html default_real_allocated pure module function default_real_allocated(self) result(all_allocated) Interface → Arguments Type Intent Optional Attributes Name class( workspace_t ), intent(in) :: self Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/workspace_s.html default_real_workspace pure module function default_real_workspace(neural_network) result(workspace) Arguments Type Intent Optional Attributes Name type( neural_network_t ), intent(in) :: neural_network Return Value type( workspace_t )","tags":"","loc":"module/workspace_s.html"},{"title":"network_configuration_s – Fiats","text":"Uses assert_m julienne_formats_m Ancestors: network_configuration_m module~~network_configuration_s~~UsesGraph module~network_configuration_s network_configuration_s assert_m assert_m module~network_configuration_s->assert_m julienne_formats_m julienne_formats_m module~network_configuration_s->julienne_formats_m module~network_configuration_m network_configuration_m module~network_configuration_s->module~network_configuration_m julienne_string_m julienne_string_m module~network_configuration_m->julienne_string_m module~double_precision_string_m double_precision_string_m module~network_configuration_m->module~double_precision_string_m julienne_m julienne_m module~double_precision_string_m->julienne_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: activation_name_key = \"activation function\" character(len=*), private, parameter :: nodes_per_layer_key = \"nodes per layer\" character(len=*), private, parameter :: skip_connections_key = \"skip connections\" Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html activation_name elemental module function activation_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html equals elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: lhs class( network_configuration_t ), intent(in) :: rhs Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html from_components pure module function from_components(skip_connections, nodes_per_layer, activation_name) result(network_configuration) Arguments Type Intent Optional Attributes Name logical, intent(in) :: skip_connections integer, intent(in) :: nodes_per_layer (:) character(len=*), intent(in) :: activation_name Return Value type( network_configuration_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html from_double_precision_string_json pure module function from_double_precision_string_json(lines) result(network_configuration) Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: lines (:) Return Value type( network_configuration_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html from_json pure module function from_json(lines) result(network_configuration) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( network_configuration_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html nodes_per_layer pure module function nodes_per_layer(self) result(nodes) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html skip_connections elemental module function skip_connections(self) result(using_skip) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html to_json pure module function to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"module/network_configuration_s.html"},{"title":"mini_batch_s – Fiats","text":"Uses Ancestors: mini_batch_m module~~mini_batch_s~~UsesGraph module~mini_batch_s mini_batch_s module~mini_batch_m mini_batch_m module~mini_batch_s->module~mini_batch_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/mini_batch_s.html default_real_construct pure module function default_real_construct(input_output_pairs) result(mini_batch) Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/mini_batch_s.html default_real_input_output_pairs pure module function default_real_input_output_pairs(self) result(my_input_output_pairs) Interface → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ), allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/mini_batch_s.html double_precision_construct pure module function double_precision_construct(input_output_pairs) result(mini_batch) Arguments Type Intent Optional Attributes Name type( input_output_pair_t (double_precision)), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/mini_batch_s.html double_precision_input_output_pairs pure module function double_precision_input_output_pairs(self) result(my_input_output_pairs) Interface → Arguments Type Intent Optional Attributes Name class( mini_batch_t (double_precision)), intent(in) :: self Return Value type( input_output_pair_t (double_precision)), allocatable, (:)","tags":"","loc":"module/mini_batch_s.html"},{"title":"neuron_s – Fiats","text":"Uses assert_m julienne_formats_m Ancestors: neuron_m module~~neuron_s~~UsesGraph module~neuron_s neuron_s assert_m assert_m module~neuron_s->assert_m julienne_formats_m julienne_formats_m module~neuron_s->julienne_formats_m module~neuron_m neuron_m module~neuron_s->module~neuron_m julienne_string_m julienne_string_m module~neuron_m->julienne_string_m module~double_precision_string_m double_precision_string_m module~neuron_m->module~double_precision_string_m module~kind_parameters_m kind_parameters_m module~neuron_m->module~kind_parameters_m julienne_m julienne_m module~double_precision_string_m->julienne_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html default_real_bias module function default_real_bias(self) result(my_bias) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html default_real_from_components pure module function default_real_from_components(weights, bias) result(neuron) Arguments Type Intent Optional Attributes Name real, intent(in) :: weights (:) real, intent(in) :: bias Return Value type( neuron_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html default_real_next_allocated module function default_real_next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html default_real_next_pointer module function default_real_next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ), pointer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html default_real_num_inputs pure module function default_real_num_inputs(self) result(size_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html default_real_to_json pure module function default_real_to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html default_real_weights module function default_real_weights(self) result(my_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real, allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html double_precision_bias module function double_precision_bias(self) result(my_bias) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value double precision module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html double_precision_from_components pure module function double_precision_from_components(weights, bias) result(neuron) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: weights (:) double precision, intent(in) :: bias Return Value type( neuron_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html double_precision_from_json pure recursive module function double_precision_from_json(neuron_lines, start) result(neuron) Arguments Type Intent Optional Attributes Name type( double_precision_string_t ), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t (double_precision)) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html double_precision_next_allocated module function double_precision_next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html double_precision_next_pointer module function double_precision_next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in), target :: self Return Value type( neuron_t (double_precision)), pointer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html double_precision_num_inputs pure module function double_precision_num_inputs(self) result(size_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html double_precision_to_json pure module function double_precision_to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value type(string_t), allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html double_precision_weights module function double_precision_weights(self) result(my_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t (double_precision)), intent(in) :: self Return Value double precision, allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html from_json pure recursive module function from_json(neuron_lines, start) result(neuron) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t )","tags":"","loc":"module/neuron_s.html"},{"title":"write_read_infer – Fiats","text":"Uses fiats_m julienne_m program~~write_read_infer~~UsesGraph program~write_read_infer write_read_infer julienne_m julienne_m program~write_read_infer->julienne_m module~fiats_m fiats_m program~write_read_infer->module~fiats_m module~double_precision_file_m double_precision_file_m module~fiats_m->module~double_precision_file_m module~double_precision_string_m double_precision_string_m module~fiats_m->module~double_precision_string_m module~hyperparameters_m hyperparameters_m module~fiats_m->module~hyperparameters_m module~input_output_pair_m input_output_pair_m module~fiats_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~fiats_m->module~kind_parameters_m module~metadata_m metadata_m module~fiats_m->module~metadata_m module~mini_batch_m mini_batch_m module~fiats_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~fiats_m->module~network_configuration_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~tensor_m tensor_m module~fiats_m->module~tensor_m module~tensor_map_m tensor_map_m module~fiats_m->module~tensor_map_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~ubounds_m ubounds_m module~fiats_m->module~ubounds_m module~double_precision_file_m->julienne_m module~double_precision_file_m->module~double_precision_string_m module~double_precision_string_m->julienne_m module~hyperparameters_m->module~double_precision_string_m module~hyperparameters_m->module~kind_parameters_m julienne_string_m julienne_string_m module~hyperparameters_m->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~metadata_m->module~double_precision_string_m module~metadata_m->julienne_string_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->module~double_precision_string_m module~network_configuration_m->julienne_string_m module~neural_network_m->julienne_m module~neural_network_m->module~double_precision_file_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~metadata_m module~neural_network_m->module~mini_batch_m module~neural_network_m->module~tensor_m module~neural_network_m->module~tensor_map_m module~activation_m activation_m module~neural_network_m->module~activation_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->julienne_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->module~tensor_m module~trainable_network_m->julienne_m module~trainable_network_m->module~input_output_pair_m module~trainable_network_m->module~kind_parameters_m module~trainable_network_m->module~mini_batch_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~tensor_map_m module~trainable_network_m->module~training_configuration_m module~training_configuration_m->module~double_precision_file_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~activation_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates how to write a neural network to a JSON file,\nread the same network from the written file, query the network object for\nsome of its properties, print those properties, and use the network to\nperform inference.  The network performs an identity mapping from any\nnon-negative inputs to the corresponding outputs using a RELU activation\nfunction. Calls program~~write_read_infer~~CallsGraph program~write_read_infer write_read_infer flag_value flag_value program~write_read_infer->flag_value proc~write_read_query_infer write_read_query_infer program~write_read_infer->proc~write_read_query_infer string string program~write_read_infer->string string_t string_t program~write_read_infer->string_t proc~write_read_query_infer->string file_t file_t proc~write_read_query_infer->file_t none~activation_function_name neural_network_t%activation_function_name proc~write_read_query_infer->none~activation_function_name none~infer neural_network_t%infer proc~write_read_query_infer->none~infer none~nodes_per_layer~5 neural_network_t%nodes_per_layer proc~write_read_query_infer->none~nodes_per_layer~5 none~num_inputs~6 neural_network_t%num_inputs proc~write_read_query_infer->none~num_inputs~6 none~num_outputs neural_network_t%num_outputs proc~write_read_query_infer->none~num_outputs none~to_json~5 neural_network_t%to_json proc~write_read_query_infer->none~to_json~5 none~values tensor_t%values proc~write_read_query_infer->none~values proc~identity_network identity_network proc~write_read_query_infer->proc~identity_network write_lines write_lines proc~write_read_query_infer->write_lines interface~default_real_activation_name neural_network_t%default_real_activation_name none~activation_function_name->interface~default_real_activation_name interface~double_precision_activation_name neural_network_t%double_precision_activation_name none~activation_function_name->interface~double_precision_activation_name interface~default_real_infer neural_network_t%default_real_infer none~infer->interface~default_real_infer interface~double_precision_infer neural_network_t%double_precision_infer none~infer->interface~double_precision_infer interface~default_real_nodes_per_layer~2 neural_network_t%default_real_nodes_per_layer none~nodes_per_layer~5->interface~default_real_nodes_per_layer~2 interface~double_precision_nodes_per_layer~2 neural_network_t%double_precision_nodes_per_layer none~nodes_per_layer~5->interface~double_precision_nodes_per_layer~2 interface~default_real_num_inputs~2 neural_network_t%default_real_num_inputs none~num_inputs~6->interface~default_real_num_inputs~2 interface~double_precision_num_inputs~2 neural_network_t%double_precision_num_inputs none~num_inputs~6->interface~double_precision_num_inputs~2 interface~default_real_num_outputs neural_network_t%default_real_num_outputs none~num_outputs->interface~default_real_num_outputs interface~double_precision_num_outputs neural_network_t%double_precision_num_outputs none~num_outputs->interface~double_precision_num_outputs interface~default_real_to_json~4 neural_network_t%default_real_to_json none~to_json~5->interface~default_real_to_json~4 interface~double_precision_to_json~4 neural_network_t%double_precision_to_json none~to_json~5->interface~double_precision_to_json~4 interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values proc~identity_network->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: file_name Functions function identity_network () result(neural_network) Arguments None Return Value type( neural_network_t ) Subroutines subroutine write_read_query_infer (output_file_name) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: output_file_name","tags":"","loc":"program/write_read_infer.html"},{"title":"concurrent_inferences – Fiats","text":"Uses assert_m fiats_m julienne_m iso_fortran_env program~~concurrent_inferences~~UsesGraph program~concurrent_inferences concurrent_inferences assert_m assert_m program~concurrent_inferences->assert_m iso_fortran_env iso_fortran_env program~concurrent_inferences->iso_fortran_env julienne_m julienne_m program~concurrent_inferences->julienne_m module~fiats_m fiats_m program~concurrent_inferences->module~fiats_m module~double_precision_file_m double_precision_file_m module~fiats_m->module~double_precision_file_m module~double_precision_string_m double_precision_string_m module~fiats_m->module~double_precision_string_m module~hyperparameters_m hyperparameters_m module~fiats_m->module~hyperparameters_m module~input_output_pair_m input_output_pair_m module~fiats_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~fiats_m->module~kind_parameters_m module~metadata_m metadata_m module~fiats_m->module~metadata_m module~mini_batch_m mini_batch_m module~fiats_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~fiats_m->module~network_configuration_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~tensor_m tensor_m module~fiats_m->module~tensor_m module~tensor_map_m tensor_map_m module~fiats_m->module~tensor_map_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~ubounds_m ubounds_m module~fiats_m->module~ubounds_m module~double_precision_file_m->julienne_m module~double_precision_file_m->module~double_precision_string_m module~double_precision_string_m->julienne_m module~hyperparameters_m->module~double_precision_string_m module~hyperparameters_m->module~kind_parameters_m julienne_string_m julienne_string_m module~hyperparameters_m->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~metadata_m->module~double_precision_string_m module~metadata_m->julienne_string_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->module~double_precision_string_m module~network_configuration_m->julienne_string_m module~neural_network_m->julienne_m module~neural_network_m->module~double_precision_file_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~metadata_m module~neural_network_m->module~mini_batch_m module~neural_network_m->module~tensor_m module~neural_network_m->module~tensor_map_m module~activation_m activation_m module~neural_network_m->module~activation_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->julienne_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->module~tensor_m module~trainable_network_m->julienne_m module~trainable_network_m->module~input_output_pair_m module~trainable_network_m->module~kind_parameters_m module~trainable_network_m->module~mini_batch_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~tensor_map_m module~trainable_network_m->module~training_configuration_m module~training_configuration_m->module~double_precision_file_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~activation_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates how to read a neural network from a JSON file\nand use the network to perform concurrent inferences. Calls program~~concurrent_inferences~~CallsGraph program~concurrent_inferences concurrent_inferences file_t file_t program~concurrent_inferences->file_t flag_value flag_value program~concurrent_inferences->flag_value infer infer program~concurrent_inferences->infer input_components input_components program~concurrent_inferences->input_components inputs inputs program~concurrent_inferences->inputs num_inputs num_inputs program~concurrent_inferences->num_inputs outputs outputs program~concurrent_inferences->outputs string string program~concurrent_inferences->string string_t string_t program~concurrent_inferences->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: network_file_name","tags":"","loc":"program/concurrent_inferences.html"},{"title":"learn_multiplication – Fiats","text":"Uses assert_m fiats_m julienne_m multiply_inputs program~~learn_multiplication~~UsesGraph program~learn_multiplication learn_multiplication assert_m assert_m program~learn_multiplication->assert_m julienne_m julienne_m program~learn_multiplication->julienne_m module~fiats_m fiats_m program~learn_multiplication->module~fiats_m module~multiply_inputs multiply_inputs program~learn_multiplication->module~multiply_inputs module~double_precision_file_m double_precision_file_m module~fiats_m->module~double_precision_file_m module~double_precision_string_m double_precision_string_m module~fiats_m->module~double_precision_string_m module~hyperparameters_m hyperparameters_m module~fiats_m->module~hyperparameters_m module~input_output_pair_m input_output_pair_m module~fiats_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~fiats_m->module~kind_parameters_m module~metadata_m metadata_m module~fiats_m->module~metadata_m module~mini_batch_m mini_batch_m module~fiats_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~fiats_m->module~network_configuration_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~tensor_m tensor_m module~fiats_m->module~tensor_m module~tensor_map_m tensor_map_m module~fiats_m->module~tensor_map_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~ubounds_m ubounds_m module~fiats_m->module~ubounds_m module~multiply_inputs->assert_m module~multiply_inputs->module~fiats_m module~double_precision_file_m->julienne_m module~double_precision_file_m->module~double_precision_string_m module~double_precision_string_m->julienne_m module~hyperparameters_m->module~double_precision_string_m module~hyperparameters_m->module~kind_parameters_m julienne_string_m julienne_string_m module~hyperparameters_m->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~metadata_m->module~double_precision_string_m module~metadata_m->julienne_string_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->module~double_precision_string_m module~network_configuration_m->julienne_string_m module~neural_network_m->julienne_m module~neural_network_m->module~double_precision_file_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~metadata_m module~neural_network_m->module~mini_batch_m module~neural_network_m->module~tensor_m module~neural_network_m->module~tensor_map_m module~activation_m activation_m module~neural_network_m->module~activation_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->julienne_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->module~tensor_m module~trainable_network_m->julienne_m module~trainable_network_m->module~input_output_pair_m module~trainable_network_m->module~kind_parameters_m module~trainable_network_m->module~mini_batch_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~tensor_map_m module~trainable_network_m->module~training_configuration_m module~training_configuration_m->module~double_precision_file_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~activation_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This trains a neural network to learn the following six polynomial functions of its eight inputs. Calls program~~learn_multiplication~~CallsGraph program~learn_multiplication learn_multiplication assert assert program~learn_multiplication->assert bin_t bin_t program~learn_multiplication->bin_t bins bins program~learn_multiplication->bins cost cost program~learn_multiplication->cost desired_outputs desired_outputs program~learn_multiplication->desired_outputs first first program~learn_multiplication->first flag_value flag_value program~learn_multiplication->flag_value infer infer program~learn_multiplication->infer input_output_pairs input_output_pairs program~learn_multiplication->input_output_pairs inputs inputs program~learn_multiplication->inputs interface~shuffle shuffle program~learn_multiplication->interface~shuffle intrinsic_array_t intrinsic_array_t program~learn_multiplication->intrinsic_array_t last last program~learn_multiplication->last mini_batches mini_batches program~learn_multiplication->mini_batches network_outputs network_outputs program~learn_multiplication->network_outputs num_inputs num_inputs program~learn_multiplication->num_inputs num_outputs num_outputs program~learn_multiplication->num_outputs output_sizes output_sizes program~learn_multiplication->output_sizes proc~output output program~learn_multiplication->proc~output proc~perturbed_identity_network perturbed_identity_network program~learn_multiplication->proc~perturbed_identity_network proc~y y program~learn_multiplication->proc~y random_init random_init program~learn_multiplication->random_init random_numbers random_numbers program~learn_multiplication->random_numbers string string program~learn_multiplication->string string_t string_t program~learn_multiplication->string_t train train program~learn_multiplication->train values values program~learn_multiplication->values none~to_json~5 neural_network_t%to_json proc~output->none~to_json~5 write_lines write_lines proc~output->write_lines proc~perturbed_identity_network->string_t proc~e e proc~perturbed_identity_network->proc~e proc~y->assert none~values tensor_t%values proc~y->none~values interface~default_real_to_json~4 neural_network_t%default_real_to_json none~to_json~5->interface~default_real_to_json~4 interface~double_precision_to_json~4 neural_network_t%double_precision_to_json none~to_json~5->interface~double_precision_to_json~4 interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) function perturbed_identity_network (perturbation_magnitude) result(trainable_network) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_network_t ) Subroutines subroutine output (neural_network, file_name) Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: neural_network type(string_t), intent(in) :: file_name","tags":"","loc":"program/learn_multiplication.html"},{"title":"learn_addition – Fiats","text":"Uses assert_m fiats_m julienne_m addition_m program~~learn_addition~~UsesGraph program~learn_addition learn_addition assert_m assert_m program~learn_addition->assert_m julienne_m julienne_m program~learn_addition->julienne_m module~addition_m addition_m program~learn_addition->module~addition_m module~fiats_m fiats_m program~learn_addition->module~fiats_m module~addition_m->assert_m module~addition_m->module~fiats_m module~double_precision_file_m double_precision_file_m module~fiats_m->module~double_precision_file_m module~double_precision_string_m double_precision_string_m module~fiats_m->module~double_precision_string_m module~hyperparameters_m hyperparameters_m module~fiats_m->module~hyperparameters_m module~input_output_pair_m input_output_pair_m module~fiats_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~fiats_m->module~kind_parameters_m module~metadata_m metadata_m module~fiats_m->module~metadata_m module~mini_batch_m mini_batch_m module~fiats_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~fiats_m->module~network_configuration_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~tensor_m tensor_m module~fiats_m->module~tensor_m module~tensor_map_m tensor_map_m module~fiats_m->module~tensor_map_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~ubounds_m ubounds_m module~fiats_m->module~ubounds_m module~double_precision_file_m->julienne_m module~double_precision_file_m->module~double_precision_string_m module~double_precision_string_m->julienne_m module~hyperparameters_m->module~double_precision_string_m module~hyperparameters_m->module~kind_parameters_m julienne_string_m julienne_string_m module~hyperparameters_m->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~metadata_m->module~double_precision_string_m module~metadata_m->julienne_string_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->module~double_precision_string_m module~network_configuration_m->julienne_string_m module~neural_network_m->julienne_m module~neural_network_m->module~double_precision_file_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~metadata_m module~neural_network_m->module~mini_batch_m module~neural_network_m->module~tensor_m module~neural_network_m->module~tensor_map_m module~activation_m activation_m module~neural_network_m->module~activation_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->julienne_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->module~tensor_m module~trainable_network_m->julienne_m module~trainable_network_m->module~input_output_pair_m module~trainable_network_m->module~kind_parameters_m module~trainable_network_m->module~mini_batch_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~tensor_map_m module~trainable_network_m->module~training_configuration_m module~training_configuration_m->module~double_precision_file_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~activation_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This trains a neural network to learn the following six polynomial functions of its eight inputs. Calls program~~learn_addition~~CallsGraph program~learn_addition learn_addition assert assert program~learn_addition->assert bin_t bin_t program~learn_addition->bin_t bins bins program~learn_addition->bins cost cost program~learn_addition->cost desired_outputs desired_outputs program~learn_addition->desired_outputs first first program~learn_addition->first flag_value flag_value program~learn_addition->flag_value infer infer program~learn_addition->infer input_output_pairs input_output_pairs program~learn_addition->input_output_pairs inputs inputs program~learn_addition->inputs interface~shuffle shuffle program~learn_addition->interface~shuffle intrinsic_array_t intrinsic_array_t program~learn_addition->intrinsic_array_t last last program~learn_addition->last mini_batches mini_batches program~learn_addition->mini_batches network_outputs network_outputs program~learn_addition->network_outputs num_inputs num_inputs program~learn_addition->num_inputs num_outputs num_outputs program~learn_addition->num_outputs output_sizes output_sizes program~learn_addition->output_sizes proc~output~2 output program~learn_addition->proc~output~2 proc~perturbed_identity_network~2 perturbed_identity_network program~learn_addition->proc~perturbed_identity_network~2 proc~y~2 y program~learn_addition->proc~y~2 random_init random_init program~learn_addition->random_init random_numbers random_numbers program~learn_addition->random_numbers string string program~learn_addition->string string_t string_t program~learn_addition->string_t train train program~learn_addition->train values values program~learn_addition->values none~to_json~5 neural_network_t%to_json proc~output~2->none~to_json~5 write_lines write_lines proc~output~2->write_lines proc~perturbed_identity_network~2->string_t proc~e~2 e proc~perturbed_identity_network~2->proc~e~2 proc~y~2->assert none~values tensor_t%values proc~y~2->none~values interface~default_real_to_json~4 neural_network_t%default_real_to_json none~to_json~5->interface~default_real_to_json~4 interface~double_precision_to_json~4 neural_network_t%double_precision_to_json none~to_json~5->interface~double_precision_to_json~4 interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) function perturbed_identity_network (perturbation_magnitude) result(trainable_network) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_network_t ) Subroutines subroutine output (neural_network, file_name) Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: neural_network type(string_t), intent(in) :: file_name","tags":"","loc":"program/learn_addition.html"},{"title":"learn_power_series – Fiats","text":"Uses assert_m fiats_m julienne_m power_series program~~learn_power_series~~UsesGraph program~learn_power_series learn_power_series assert_m assert_m program~learn_power_series->assert_m julienne_m julienne_m program~learn_power_series->julienne_m module~fiats_m fiats_m program~learn_power_series->module~fiats_m module~power_series power_series program~learn_power_series->module~power_series module~double_precision_file_m double_precision_file_m module~fiats_m->module~double_precision_file_m module~double_precision_string_m double_precision_string_m module~fiats_m->module~double_precision_string_m module~hyperparameters_m hyperparameters_m module~fiats_m->module~hyperparameters_m module~input_output_pair_m input_output_pair_m module~fiats_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~fiats_m->module~kind_parameters_m module~metadata_m metadata_m module~fiats_m->module~metadata_m module~mini_batch_m mini_batch_m module~fiats_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~fiats_m->module~network_configuration_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~tensor_m tensor_m module~fiats_m->module~tensor_m module~tensor_map_m tensor_map_m module~fiats_m->module~tensor_map_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~ubounds_m ubounds_m module~fiats_m->module~ubounds_m module~power_series->assert_m module~power_series->module~fiats_m module~double_precision_file_m->julienne_m module~double_precision_file_m->module~double_precision_string_m module~double_precision_string_m->julienne_m module~hyperparameters_m->module~double_precision_string_m module~hyperparameters_m->module~kind_parameters_m julienne_string_m julienne_string_m module~hyperparameters_m->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~metadata_m->module~double_precision_string_m module~metadata_m->julienne_string_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->module~double_precision_string_m module~network_configuration_m->julienne_string_m module~neural_network_m->julienne_m module~neural_network_m->module~double_precision_file_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~metadata_m module~neural_network_m->module~mini_batch_m module~neural_network_m->module~tensor_m module~neural_network_m->module~tensor_map_m module~activation_m activation_m module~neural_network_m->module~activation_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->julienne_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->module~tensor_m module~trainable_network_m->julienne_m module~trainable_network_m->module~input_output_pair_m module~trainable_network_m->module~kind_parameters_m module~trainable_network_m->module~mini_batch_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~tensor_map_m module~trainable_network_m->module~training_configuration_m module~training_configuration_m->module~double_precision_file_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~activation_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This trains a neural network to learn the following six polynomial functions of its eight inputs. Calls program~~learn_power_series~~CallsGraph program~learn_power_series learn_power_series assert assert program~learn_power_series->assert bin_t bin_t program~learn_power_series->bin_t bins bins program~learn_power_series->bins cost cost program~learn_power_series->cost desired_outputs desired_outputs program~learn_power_series->desired_outputs first first program~learn_power_series->first flag_value flag_value program~learn_power_series->flag_value infer infer program~learn_power_series->infer input_output_pairs input_output_pairs program~learn_power_series->input_output_pairs inputs inputs program~learn_power_series->inputs interface~shuffle shuffle program~learn_power_series->interface~shuffle intrinsic_array_t intrinsic_array_t program~learn_power_series->intrinsic_array_t last last program~learn_power_series->last mini_batches mini_batches program~learn_power_series->mini_batches network_outputs network_outputs program~learn_power_series->network_outputs num_inputs num_inputs program~learn_power_series->num_inputs num_outputs num_outputs program~learn_power_series->num_outputs output_sizes output_sizes program~learn_power_series->output_sizes proc~output~3 output program~learn_power_series->proc~output~3 proc~perturbed_identity_network~3 perturbed_identity_network program~learn_power_series->proc~perturbed_identity_network~3 proc~y~3 y program~learn_power_series->proc~y~3 random_init random_init program~learn_power_series->random_init random_numbers random_numbers program~learn_power_series->random_numbers string string program~learn_power_series->string string_t string_t program~learn_power_series->string_t train train program~learn_power_series->train values values program~learn_power_series->values white_noise white_noise program~learn_power_series->white_noise none~to_json~5 neural_network_t%to_json proc~output~3->none~to_json~5 write_lines write_lines proc~output~3->write_lines proc~perturbed_identity_network~3->string_t proc~e~3 e proc~perturbed_identity_network~3->proc~e~3 proc~y~3->assert none~values tensor_t%values proc~y~3->none~values interface~default_real_to_json~4 neural_network_t%default_real_to_json none~to_json~5->interface~default_real_to_json~4 interface~double_precision_to_json~4 neural_network_t%double_precision_to_json none~to_json~5->interface~double_precision_to_json~4 interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) function perturbed_identity_network (perturbation_magnitude) result(trainable_network) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_network_t ) Subroutines subroutine output (neural_network, file_name) Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: neural_network type(string_t), intent(in) :: file_name","tags":"","loc":"program/learn_power_series.html"},{"title":"train_saturated_mixture_ratio – Fiats","text":"Uses iso_fortran_env assert_m fiats_m julienne_m saturated_mixing_ratio_m program~~train_saturated_mixture_ratio~~UsesGraph program~train_saturated_mixture_ratio train_saturated_mixture_ratio assert_m assert_m program~train_saturated_mixture_ratio->assert_m iso_fortran_env iso_fortran_env program~train_saturated_mixture_ratio->iso_fortran_env julienne_m julienne_m program~train_saturated_mixture_ratio->julienne_m module~fiats_m fiats_m program~train_saturated_mixture_ratio->module~fiats_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m module~double_precision_file_m double_precision_file_m module~fiats_m->module~double_precision_file_m module~double_precision_string_m double_precision_string_m module~fiats_m->module~double_precision_string_m module~hyperparameters_m hyperparameters_m module~fiats_m->module~hyperparameters_m module~input_output_pair_m input_output_pair_m module~fiats_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~fiats_m->module~kind_parameters_m module~metadata_m metadata_m module~fiats_m->module~metadata_m module~mini_batch_m mini_batch_m module~fiats_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~fiats_m->module~network_configuration_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~tensor_m tensor_m module~fiats_m->module~tensor_m module~tensor_map_m tensor_map_m module~fiats_m->module~tensor_map_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~ubounds_m ubounds_m module~fiats_m->module~ubounds_m module~saturated_mixing_ratio_m->assert_m module~saturated_mixing_ratio_m->module~fiats_m module~double_precision_file_m->julienne_m module~double_precision_file_m->module~double_precision_string_m module~double_precision_string_m->julienne_m module~hyperparameters_m->module~double_precision_string_m module~hyperparameters_m->module~kind_parameters_m julienne_string_m julienne_string_m module~hyperparameters_m->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~metadata_m->module~double_precision_string_m module~metadata_m->julienne_string_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->module~double_precision_string_m module~network_configuration_m->julienne_string_m module~neural_network_m->julienne_m module~neural_network_m->module~double_precision_file_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~metadata_m module~neural_network_m->module~mini_batch_m module~neural_network_m->module~tensor_m module~neural_network_m->module~tensor_map_m module~activation_m activation_m module~neural_network_m->module~activation_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->julienne_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->module~tensor_m module~trainable_network_m->julienne_m module~trainable_network_m->module~input_output_pair_m module~trainable_network_m->module~kind_parameters_m module~trainable_network_m->module~mini_batch_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~tensor_map_m module~trainable_network_m->module~training_configuration_m module~training_configuration_m->module~double_precision_file_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~activation_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program trains a neural network to learn the saturated mixing ratio function of ICAR. Calls program~~train_saturated_mixture_ratio~~CallsGraph program~train_saturated_mixture_ratio train_saturated_mixture_ratio assert assert program~train_saturated_mixture_ratio->assert bin_t bin_t program~train_saturated_mixture_ratio->bin_t bins bins program~train_saturated_mixture_ratio->bins cost cost program~train_saturated_mixture_ratio->cost desired_outputs desired_outputs program~train_saturated_mixture_ratio->desired_outputs file_t file_t program~train_saturated_mixture_ratio->file_t first first program~train_saturated_mixture_ratio->first flag_value flag_value program~train_saturated_mixture_ratio->flag_value infer infer program~train_saturated_mixture_ratio->infer input_output_pairs input_output_pairs program~train_saturated_mixture_ratio->input_output_pairs inputs inputs program~train_saturated_mixture_ratio->inputs interface~shuffle shuffle program~train_saturated_mixture_ratio->interface~shuffle intrinsic_array_t intrinsic_array_t program~train_saturated_mixture_ratio->intrinsic_array_t last last program~train_saturated_mixture_ratio->last mini_batches mini_batches program~train_saturated_mixture_ratio->mini_batches network_outputs network_outputs program~train_saturated_mixture_ratio->network_outputs nodes_per_layer nodes_per_layer program~train_saturated_mixture_ratio->nodes_per_layer num_inputs num_inputs program~train_saturated_mixture_ratio->num_inputs num_outputs num_outputs program~train_saturated_mixture_ratio->num_outputs output_sizes output_sizes program~train_saturated_mixture_ratio->output_sizes proc~open_plot_file_for_appending open_plot_file_for_appending program~train_saturated_mixture_ratio->proc~open_plot_file_for_appending proc~output~4 output program~train_saturated_mixture_ratio->proc~output~4 proc~perturbed_identity_network~4 perturbed_identity_network program~train_saturated_mixture_ratio->proc~perturbed_identity_network~4 proc~print_diagnostics print_diagnostics program~train_saturated_mixture_ratio->proc~print_diagnostics proc~y~4 y program~train_saturated_mixture_ratio->proc~y~4 random_init random_init program~train_saturated_mixture_ratio->random_init random_numbers random_numbers program~train_saturated_mixture_ratio->random_numbers string string program~train_saturated_mixture_ratio->string string_t string_t program~train_saturated_mixture_ratio->string_t train train program~train_saturated_mixture_ratio->train values values program~train_saturated_mixture_ratio->values proc~open_plot_file_for_appending->file_t proc~open_plot_file_for_appending->string proc~open_plot_file_for_appending->string_t lines lines proc~open_plot_file_for_appending->lines none~to_json~5 neural_network_t%to_json proc~output~4->none~to_json~5 write_lines write_lines proc~output~4->write_lines proc~perturbed_identity_network~4->string_t proc~e~4 e proc~perturbed_identity_network~4->proc~e~4 proc~y~4->assert none~values tensor_t%values proc~y~4->none~values proc~saturated_mixing_ratio saturated_mixing_ratio proc~y~4->proc~saturated_mixing_ratio interface~default_real_to_json~4 neural_network_t%default_real_to_json none~to_json~5->interface~default_real_to_json~4 interface~double_precision_to_json~4 neural_network_t%double_precision_to_json none~to_json~5->interface~double_precision_to_json~4 interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer(kind=int64) :: clock_rate type(command_line_t) :: command_line integer(kind=int64) :: counter_end integer(kind=int64) :: counter_start type(string_t) :: network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) function perturbed_identity_network (perturbation_magnitude, n) result(trainable_network) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude integer, intent(in) :: n (:) Return Value type( trainable_network_t ) Subroutines subroutine open_plot_file_for_appending (plot_file_name, plot_unit, previous_epoch, previous_clock) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: plot_file_name integer, intent(out) :: plot_unit integer, intent(out) :: previous_epoch real, intent(out) :: previous_clock subroutine output (neural_network, file_name) Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: neural_network type(string_t), intent(in) :: file_name subroutine print_diagnostics (plot_file_unit, epoch, cost, clock, nodes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: plot_file_unit integer, intent(in) :: epoch real, intent(in) :: cost real, intent(in) :: clock integer, intent(in) :: nodes (:)","tags":"","loc":"program/train_saturated_mixture_ratio.html"},{"title":"read_query_infer – Fiats","text":"Uses fiats_m julienne_m program~~read_query_infer~~UsesGraph program~read_query_infer read_query_infer julienne_m julienne_m program~read_query_infer->julienne_m module~fiats_m fiats_m program~read_query_infer->module~fiats_m module~double_precision_file_m double_precision_file_m module~fiats_m->module~double_precision_file_m module~double_precision_string_m double_precision_string_m module~fiats_m->module~double_precision_string_m module~hyperparameters_m hyperparameters_m module~fiats_m->module~hyperparameters_m module~input_output_pair_m input_output_pair_m module~fiats_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~fiats_m->module~kind_parameters_m module~metadata_m metadata_m module~fiats_m->module~metadata_m module~mini_batch_m mini_batch_m module~fiats_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~fiats_m->module~network_configuration_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~tensor_m tensor_m module~fiats_m->module~tensor_m module~tensor_map_m tensor_map_m module~fiats_m->module~tensor_map_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~ubounds_m ubounds_m module~fiats_m->module~ubounds_m module~double_precision_file_m->julienne_m module~double_precision_file_m->module~double_precision_string_m module~double_precision_string_m->julienne_m module~hyperparameters_m->module~double_precision_string_m module~hyperparameters_m->module~kind_parameters_m julienne_string_m julienne_string_m module~hyperparameters_m->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~metadata_m->module~double_precision_string_m module~metadata_m->julienne_string_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->module~double_precision_string_m module~network_configuration_m->julienne_string_m module~neural_network_m->julienne_m module~neural_network_m->module~double_precision_file_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~metadata_m module~neural_network_m->module~mini_batch_m module~neural_network_m->module~tensor_m module~neural_network_m->module~tensor_map_m module~activation_m activation_m module~neural_network_m->module~activation_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->julienne_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->module~tensor_m module~trainable_network_m->julienne_m module~trainable_network_m->module~input_output_pair_m module~trainable_network_m->module~kind_parameters_m module~trainable_network_m->module~mini_batch_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~tensor_map_m module~trainable_network_m->module~training_configuration_m module~training_configuration_m->module~double_precision_file_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~activation_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates how to read a neural network from a JSON file,\nquery the network object for some of its properties, print those properties,\nand use the network to perform inference. Calls program~~read_query_infer~~CallsGraph program~read_query_infer read_query_infer file_t file_t program~read_query_infer->file_t flag_value flag_value program~read_query_infer->flag_value harvest harvest program~read_query_infer->harvest none~activation_function_name neural_network_t%activation_function_name program~read_query_infer->none~activation_function_name none~infer neural_network_t%infer program~read_query_infer->none~infer none~nodes_per_layer~5 neural_network_t%nodes_per_layer program~read_query_infer->none~nodes_per_layer~5 none~num_inputs~6 neural_network_t%num_inputs program~read_query_infer->none~num_inputs~6 none~num_outputs neural_network_t%num_outputs program~read_query_infer->none~num_outputs none~values tensor_t%values program~read_query_infer->none~values random_init random_init program~read_query_infer->random_init string string program~read_query_infer->string string_t string_t program~read_query_infer->string_t interface~default_real_activation_name neural_network_t%default_real_activation_name none~activation_function_name->interface~default_real_activation_name interface~double_precision_activation_name neural_network_t%double_precision_activation_name none~activation_function_name->interface~double_precision_activation_name interface~default_real_infer neural_network_t%default_real_infer none~infer->interface~default_real_infer interface~double_precision_infer neural_network_t%double_precision_infer none~infer->interface~double_precision_infer interface~default_real_nodes_per_layer~2 neural_network_t%default_real_nodes_per_layer none~nodes_per_layer~5->interface~default_real_nodes_per_layer~2 interface~double_precision_nodes_per_layer~2 neural_network_t%double_precision_nodes_per_layer none~nodes_per_layer~5->interface~double_precision_nodes_per_layer~2 interface~default_real_num_inputs~2 neural_network_t%default_real_num_inputs none~num_inputs~6->interface~default_real_num_inputs~2 interface~double_precision_num_inputs~2 neural_network_t%double_precision_num_inputs none~num_inputs~6->interface~double_precision_num_inputs~2 interface~default_real_num_outputs neural_network_t%default_real_num_outputs none~num_outputs->interface~default_real_num_outputs interface~double_precision_num_outputs neural_network_t%double_precision_num_outputs none~num_outputs->interface~double_precision_num_outputs interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line","tags":"","loc":"program/read_query_infer.html"},{"title":"print_training_configuration – Fiats","text":"Uses fiats_m julienne_m program~~print_training_configuration~~UsesGraph program~print_training_configuration print_training_configuration julienne_m julienne_m program~print_training_configuration->julienne_m module~fiats_m fiats_m program~print_training_configuration->module~fiats_m module~double_precision_file_m double_precision_file_m module~fiats_m->module~double_precision_file_m module~double_precision_string_m double_precision_string_m module~fiats_m->module~double_precision_string_m module~hyperparameters_m hyperparameters_m module~fiats_m->module~hyperparameters_m module~input_output_pair_m input_output_pair_m module~fiats_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~fiats_m->module~kind_parameters_m module~metadata_m metadata_m module~fiats_m->module~metadata_m module~mini_batch_m mini_batch_m module~fiats_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~fiats_m->module~network_configuration_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~tensor_m tensor_m module~fiats_m->module~tensor_m module~tensor_map_m tensor_map_m module~fiats_m->module~tensor_map_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~ubounds_m ubounds_m module~fiats_m->module~ubounds_m module~double_precision_file_m->julienne_m module~double_precision_file_m->module~double_precision_string_m module~double_precision_string_m->julienne_m module~hyperparameters_m->module~double_precision_string_m module~hyperparameters_m->module~kind_parameters_m julienne_string_m julienne_string_m module~hyperparameters_m->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~metadata_m->module~double_precision_string_m module~metadata_m->julienne_string_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->module~double_precision_string_m module~network_configuration_m->julienne_string_m module~neural_network_m->julienne_m module~neural_network_m->module~double_precision_file_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~metadata_m module~neural_network_m->module~mini_batch_m module~neural_network_m->module~tensor_m module~neural_network_m->module~tensor_map_m module~activation_m activation_m module~neural_network_m->module~activation_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->julienne_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->module~tensor_m module~trainable_network_m->julienne_m module~trainable_network_m->module~input_output_pair_m module~trainable_network_m->module~kind_parameters_m module~trainable_network_m->module~mini_batch_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~tensor_map_m module~trainable_network_m->module~training_configuration_m module~training_configuration_m->module~double_precision_file_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~activation_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Demonstrate how to construct and print a training_configuration_t object Calls program~~print_training_configuration~~CallsGraph program~print_training_configuration print_training_configuration file_t file_t program~print_training_configuration->file_t none~to_json training_configuration_t%to_json program~print_training_configuration->none~to_json write_lines write_lines program~print_training_configuration->write_lines interface~default_real_to_json training_configuration_t%default_real_to_json none~to_json->interface~default_real_to_json interface~double_precision_to_json training_configuration_t%double_precision_to_json none~to_json->interface~double_precision_to_json Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"program/print_training_configuration.html"},{"title":"learn_exponentiation – Fiats","text":"Uses assert_m fiats_m julienne_m exponentiation_m program~~learn_exponentiation~~UsesGraph program~learn_exponentiation learn_exponentiation assert_m assert_m program~learn_exponentiation->assert_m julienne_m julienne_m program~learn_exponentiation->julienne_m module~exponentiation_m exponentiation_m program~learn_exponentiation->module~exponentiation_m module~fiats_m fiats_m program~learn_exponentiation->module~fiats_m module~exponentiation_m->assert_m module~exponentiation_m->module~fiats_m module~double_precision_file_m double_precision_file_m module~fiats_m->module~double_precision_file_m module~double_precision_string_m double_precision_string_m module~fiats_m->module~double_precision_string_m module~hyperparameters_m hyperparameters_m module~fiats_m->module~hyperparameters_m module~input_output_pair_m input_output_pair_m module~fiats_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~fiats_m->module~kind_parameters_m module~metadata_m metadata_m module~fiats_m->module~metadata_m module~mini_batch_m mini_batch_m module~fiats_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~fiats_m->module~network_configuration_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~tensor_m tensor_m module~fiats_m->module~tensor_m module~tensor_map_m tensor_map_m module~fiats_m->module~tensor_map_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~ubounds_m ubounds_m module~fiats_m->module~ubounds_m module~double_precision_file_m->julienne_m module~double_precision_file_m->module~double_precision_string_m module~double_precision_string_m->julienne_m module~hyperparameters_m->module~double_precision_string_m module~hyperparameters_m->module~kind_parameters_m julienne_string_m julienne_string_m module~hyperparameters_m->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~metadata_m->module~double_precision_string_m module~metadata_m->julienne_string_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->module~double_precision_string_m module~network_configuration_m->julienne_string_m module~neural_network_m->julienne_m module~neural_network_m->module~double_precision_file_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~metadata_m module~neural_network_m->module~mini_batch_m module~neural_network_m->module~tensor_m module~neural_network_m->module~tensor_map_m module~activation_m activation_m module~neural_network_m->module~activation_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->julienne_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->module~tensor_m module~trainable_network_m->julienne_m module~trainable_network_m->module~input_output_pair_m module~trainable_network_m->module~kind_parameters_m module~trainable_network_m->module~mini_batch_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~tensor_map_m module~trainable_network_m->module~training_configuration_m module~training_configuration_m->module~double_precision_file_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~activation_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This trains a neural network to learn the following six polynomial functions of its eight inputs. Calls program~~learn_exponentiation~~CallsGraph program~learn_exponentiation learn_exponentiation assert assert program~learn_exponentiation->assert bin_t bin_t program~learn_exponentiation->bin_t bins bins program~learn_exponentiation->bins cost cost program~learn_exponentiation->cost desired_outputs desired_outputs program~learn_exponentiation->desired_outputs first first program~learn_exponentiation->first flag_value flag_value program~learn_exponentiation->flag_value infer infer program~learn_exponentiation->infer input_output_pairs input_output_pairs program~learn_exponentiation->input_output_pairs inputs inputs program~learn_exponentiation->inputs interface~shuffle shuffle program~learn_exponentiation->interface~shuffle intrinsic_array_t intrinsic_array_t program~learn_exponentiation->intrinsic_array_t last last program~learn_exponentiation->last mini_batches mini_batches program~learn_exponentiation->mini_batches network_outputs network_outputs program~learn_exponentiation->network_outputs num_inputs num_inputs program~learn_exponentiation->num_inputs num_outputs num_outputs program~learn_exponentiation->num_outputs output_sizes output_sizes program~learn_exponentiation->output_sizes proc~output~5 output program~learn_exponentiation->proc~output~5 proc~perturbed_identity_network~6 perturbed_identity_network program~learn_exponentiation->proc~perturbed_identity_network~6 proc~y~5 y program~learn_exponentiation->proc~y~5 random_init random_init program~learn_exponentiation->random_init random_numbers random_numbers program~learn_exponentiation->random_numbers string string program~learn_exponentiation->string string_t string_t program~learn_exponentiation->string_t train train program~learn_exponentiation->train values values program~learn_exponentiation->values none~to_json~5 neural_network_t%to_json proc~output~5->none~to_json~5 write_lines write_lines proc~output~5->write_lines proc~perturbed_identity_network~6->string_t proc~e~5 e proc~perturbed_identity_network~6->proc~e~5 proc~y~5->assert none~values tensor_t%values proc~y~5->none~values interface~default_real_to_json~4 neural_network_t%default_real_to_json none~to_json~5->interface~default_real_to_json~4 interface~double_precision_to_json~4 neural_network_t%double_precision_to_json none~to_json~5->interface~double_precision_to_json~4 interface~default_real_values tensor_t%default_real_values none~values->interface~default_real_values interface~double_precision_values tensor_t%double_precision_values none~values->interface~double_precision_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) function perturbed_identity_network (perturbation_magnitude) result(trainable_network) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_network_t ) Subroutines subroutine output (neural_network, file_name) Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: neural_network type(string_t), intent(in) :: file_name","tags":"","loc":"program/learn_exponentiation.html"},{"title":"train_and_write – Fiats","text":"Uses assert_m fiats_m julienne_m program~~train_and_write~~UsesGraph program~train_and_write train_and_write assert_m assert_m program~train_and_write->assert_m julienne_m julienne_m program~train_and_write->julienne_m module~fiats_m fiats_m program~train_and_write->module~fiats_m module~double_precision_file_m double_precision_file_m module~fiats_m->module~double_precision_file_m module~double_precision_string_m double_precision_string_m module~fiats_m->module~double_precision_string_m module~hyperparameters_m hyperparameters_m module~fiats_m->module~hyperparameters_m module~input_output_pair_m input_output_pair_m module~fiats_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~fiats_m->module~kind_parameters_m module~metadata_m metadata_m module~fiats_m->module~metadata_m module~mini_batch_m mini_batch_m module~fiats_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~fiats_m->module~network_configuration_m module~neural_network_m neural_network_m module~fiats_m->module~neural_network_m module~tensor_m tensor_m module~fiats_m->module~tensor_m module~tensor_map_m tensor_map_m module~fiats_m->module~tensor_map_m module~trainable_network_m trainable_network_m module~fiats_m->module~trainable_network_m module~training_configuration_m training_configuration_m module~fiats_m->module~training_configuration_m module~ubounds_m ubounds_m module~fiats_m->module~ubounds_m module~double_precision_file_m->julienne_m module~double_precision_file_m->module~double_precision_string_m module~double_precision_string_m->julienne_m module~hyperparameters_m->module~double_precision_string_m module~hyperparameters_m->module~kind_parameters_m julienne_string_m julienne_string_m module~hyperparameters_m->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~metadata_m->module~double_precision_string_m module~metadata_m->julienne_string_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->module~double_precision_string_m module~network_configuration_m->julienne_string_m module~neural_network_m->julienne_m module~neural_network_m->module~double_precision_file_m module~neural_network_m->module~kind_parameters_m module~neural_network_m->module~metadata_m module~neural_network_m->module~mini_batch_m module~neural_network_m->module~tensor_m module~neural_network_m->module~tensor_map_m module~activation_m activation_m module~neural_network_m->module~activation_m module~tensor_m->module~kind_parameters_m module~tensor_map_m->julienne_m module~tensor_map_m->module~double_precision_string_m module~tensor_map_m->module~kind_parameters_m module~tensor_map_m->module~tensor_m module~trainable_network_m->julienne_m module~trainable_network_m->module~input_output_pair_m module~trainable_network_m->module~kind_parameters_m module~trainable_network_m->module~mini_batch_m module~trainable_network_m->module~neural_network_m module~trainable_network_m->module~tensor_map_m module~trainable_network_m->module~training_configuration_m module~training_configuration_m->module~double_precision_file_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~activation_m module~activation_m->julienne_m iso_c_binding iso_c_binding module~activation_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates how to train a simple neural network starting from a randomized initial condition and \nhow to write the initial network and the trained network to separate JSON files.  The network has two hiden layers.\nThe input, hidden, and output layers are all two nodes wide.  The training data has outputs that identically match\nthe corresponding inputs.  Hence, the desired network represents an identity mapping.  With RELU activation functions,\nthe desired network therefore contains weights corresponding to identity matrices and biases that vanish everywhere.\nThe initial condition corresponds to the desired network with all weights and biases perturbed by a random variable\nthat is uniformly distributed on the range [0,0.1]. Calls program~~train_and_write~~CallsGraph program~train_and_write train_and_write assert assert program~train_and_write->assert bin_t bin_t program~train_and_write->bin_t bins bins program~train_and_write->bins cost cost program~train_and_write->cost first first program~train_and_write->first flag_value flag_value program~train_and_write->flag_value infer infer program~train_and_write->infer input_output_pairs input_output_pairs program~train_and_write->input_output_pairs inputs inputs program~train_and_write->inputs interface~shuffle shuffle program~train_and_write->interface~shuffle intrinsic_array_t intrinsic_array_t program~train_and_write->intrinsic_array_t last last program~train_and_write->last mini_batches mini_batches program~train_and_write->mini_batches network_outputs network_outputs program~train_and_write->network_outputs num_inputs num_inputs program~train_and_write->num_inputs num_outputs num_outputs program~train_and_write->num_outputs proc~output~6 output program~train_and_write->proc~output~6 proc~perturbed_identity_network~7 perturbed_identity_network program~train_and_write->proc~perturbed_identity_network~7 random_init random_init program~train_and_write->random_init random_numbers random_numbers program~train_and_write->random_numbers string string program~train_and_write->string string_t string_t program~train_and_write->string_t train train program~train_and_write->train values values program~train_and_write->values none~to_json~5 neural_network_t%to_json proc~output~6->none~to_json~5 write_lines write_lines proc~output~6->write_lines proc~perturbed_identity_network~7->string_t proc~e~6 e proc~perturbed_identity_network~7->proc~e~6 interface~default_real_to_json~4 neural_network_t%default_real_to_json none~to_json~5->interface~default_real_to_json~4 interface~double_precision_to_json~4 neural_network_t%double_precision_to_json none~to_json~5->interface~double_precision_to_json~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file Functions pure function e (m, n) result(e_mn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n Return Value real function perturbed_identity_network (perturbation_magnitude) result(trainable_network) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_network_t ) Subroutines subroutine output (neural_network, file_name) Arguments Type Intent Optional Attributes Name class( neural_network_t ), intent(in) :: neural_network type(string_t), intent(in) :: file_name","tags":"","loc":"program/train_and_write.html"},{"title":"write-read-infer.F90 – Fiats","text":"This file depends on sourcefile~~write-read-infer.f90~~EfferentGraph sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~write-read-infer.f90->sourcefile~fiats_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~fiats_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~fiats_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~fiats_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~fiats_m.f90->sourcefile~metadata_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~fiats_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~network_configuration_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~fiats_m.f90->sourcefile~ubounds_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_network_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~activation_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program write_read_infer !! This program demonstrates how to write a neural network to a JSON file, !! read the same network from the written file, query the network object for !! some of its properties, print those properties, and use the network to !! perform inference.  The network performs an identity mapping from any !! non-negative inputs to the corresponding outputs using a RELU activation !! function. use fiats_m , only : neural_network_t , tensor_t use julienne_m , only : string_t , command_line_t , file_t implicit none type ( string_t ) file_name type ( command_line_t ) command_line file_name = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( file_name % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example write-read-infer --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if call write_read_query_infer ( file_name ) contains function identity_network () result ( neural_network ) type ( neural_network_t ) neural_network integer , parameter :: nodes_per_layer ( * ) = [ 2 , 2 , 2 ] integer , parameter :: max_n = maxval ( nodes_per_layer ), layers = size ( nodes_per_layer ) #ifdef _CRAYFTN real , allocatable :: weights (:,:,:) weights = reshape ([ real :: [ 1 , 0 , 0 , 1 ], [ 1 , 0 , 0 , 1 ]], [ max_n , max_n , layers - 1 ]) neural_network = neural_network_t ( & metadata = [ string_t ( \"Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-18\" ), string_t ( \"relu\" ), string_t ( \"false\" )], & weights = weights , & biases = reshape ([ real :: [ 0 , 0 ], [ 0 , 0 ]], [ max_n , layers - 1 ]), & nodes = nodes_per_layer & ) #else neural_network = neural_network_t ( & metadata = [ string_t ( \"Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-18\" ), string_t ( \"relu\" ), string_t ( \"false\" )], & weights = reshape ([ real :: [ 1 , 0 , 0 , 1 ], [ 1 , 0 , 0 , 1 ]], [ max_n , max_n , layers - 1 ]), & biases = reshape ([ real :: [ 0 , 0 ], [ 0 , 0 ]], [ max_n , layers - 1 ]), & nodes = nodes_per_layer & ) #endif end function subroutine write_read_query_infer ( output_file_name ) type ( string_t ), intent ( in ) :: output_file_name type ( string_t ) activation_name integer i , j integer , parameter :: num_neurons = 3 , num_hidden_layers = 2 type ( neural_network_t ) network , neural_network type ( file_t ) json_output_file , json_input_file type ( tensor_t ) inputs , outputs print * , \"Constructing an neural_network_t neural-network object from scratch.\" network = identity_network () print * , \"Converting an neural_network_t object to a file_t object.\" json_output_file = network % to_json () print * , \"Writing an neural_network_t object to the file '\" // output_file_name % string () // \"' in JSON format.\" call json_output_file % write_lines ( output_file_name ) print * , \"Reading an neural_network_t object from the same JSON file '\" // output_file_name % string () // \"'.\" json_input_file = file_t ( output_file_name ) print * , \"Constructing a new neural_network_t object from the parameters read.\" neural_network = neural_network_t ( json_input_file ) print * , \"Querying the new neural_network_t object for several properties:\" print * , \"Number of outputs:\" , neural_network % num_outputs () print * , \"Number of inputs:\" , neural_network % num_inputs () print * , \"Nodes per layer:\" , neural_network % nodes_per_layer () activation_name = neural_network % activation_function_name () print * , \"Activation function: \" , activation_name % string () print * , \"Performing inference:\" inputs = tensor_t ([ 2. , 3. ]) print * , \"Inputs: \" , inputs % values () outputs = neural_network % infer ( inputs ) print * , \"Actual outputs: \" , outputs % values () print * , \"Correct outputs:  \" , inputs % values () end subroutine write_read_query_infer end program","tags":"","loc":"sourcefile/write-read-infer.f90.html"},{"title":"concurrent-inferences.f90 – Fiats","text":"This file depends on sourcefile~~concurrent-inferences.f90~~EfferentGraph sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~concurrent-inferences.f90->sourcefile~fiats_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~fiats_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~fiats_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~fiats_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~fiats_m.f90->sourcefile~metadata_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~fiats_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~network_configuration_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~fiats_m.f90->sourcefile~ubounds_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_network_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~activation_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program concurrent_inferences !! This program demonstrates how to read a neural network from a JSON file !! and use the network to perform concurrent inferences. use fiats_m , only : neural_network_t , tensor_t , double_precision , double_precision_string_t , double_precision_file_t use julienne_m , only : string_t , command_line_t , file_t use assert_m , only : assert use iso_fortran_env , only : int64 , real64 implicit none type ( string_t ) network_file_name type ( command_line_t ) command_line network_file_name = string_t ( command_line % flag_value ( \"--network\" )) if ( len ( network_file_name % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example concurrent-inferences --profile release --flag \"-fopenmp\" -- --network \"<file-name>\"' end if block integer , parameter :: lat = 263 , lon = 317 , lev = 15 ! latitudes, longitudes, levels (elevations) integer i , j , k single_precision_inference : & block integer ( int64 ) t_start , t_finish , clock_rate type ( neural_network_t ) neural_network type ( tensor_t ), allocatable :: inputs (:,:,:), outputs (:,:,:) real , allocatable :: input_components (:,:,:,:) print * , \"Constructing a new neural_network_t object from the file \" // network_file_name % string () neural_network = neural_network_t ( file_t ( network_file_name )) print * , \"Defining an array of tensor_t input objects with random normalized components\" allocate ( outputs ( lat , lon , lev )) allocate ( inputs ( lat , lon , lev )) allocate ( input_components ( lat , lon , lev , neural_network % num_inputs ())) call random_number ( input_components ) do concurrent ( i = 1 : lat , j = 1 : lon , k = 1 : lev ) inputs ( i , j , k ) = tensor_t ( input_components ( i , j , k ,:)) end do print * , \"Performing concurrent inference\" call system_clock ( t_start , clock_rate ) do concurrent ( i = 1 : lat , j = 1 : lon , k = 1 : lev ) outputs ( i , j , k ) = neural_network % infer ( inputs ( i , j , k )) end do call system_clock ( t_finish ) print * , \"Concurrent inference time: \" , real ( t_finish - t_start , real64 ) / real ( clock_rate , real64 ) print * , \"Performing loop-based inference\" call system_clock ( t_start ) do k = 1 , lev do j = 1 , lon do i = 1 , lat outputs ( i , j , k ) = neural_network % infer ( inputs ( i , j , k )) end do end do end do call system_clock ( t_finish ) print * , \"Looping inference time: \" , real ( t_finish - t_start , real64 ) / real ( clock_rate , real64 ) print * , \"Performing elemental inferences\" call system_clock ( t_start , clock_rate ) outputs = neural_network % infer ( inputs ) ! implicit (re)allocation of outputs array only if shape(inputs) /= shape(outputs) call system_clock ( t_finish ) print * , \"Elemental inference time: \" , real ( t_finish - t_start , real64 ) / real ( clock_rate , real64 ) end block single_precision_inference double_precision_inference : & block integer ( int64 ) t_start , t_finish , clock_rate type ( neural_network_t ( double_precision )) neural_network type ( tensor_t ( double_precision )), allocatable :: inputs (:,:,:), outputs (:,:,:) double precision , allocatable :: input_components (:,:,:,:) print * , \"Constructing a new neural_network_t object from the file \" // network_file_name % string () neural_network = neural_network_t ( double_precision_file_t ( network_file_name )) print * , \"Defining an array of tensor_t input objects with random normalized components\" allocate ( outputs ( lat , lon , lev )) allocate ( inputs ( lat , lon , lev )) allocate ( input_components ( lat , lon , lev , neural_network % num_inputs ())) call random_number ( input_components ) do concurrent ( i = 1 : lat , j = 1 : lon , k = 1 : lev ) inputs ( i , j , k ) = tensor_t ( input_components ( i , j , k ,:)) end do print * , \"Performing double-precision concurrent inference\" call system_clock ( t_start , clock_rate ) do concurrent ( i = 1 : lat , j = 1 : lon , k = 1 : lev ) outputs ( i , j , k ) = neural_network % infer ( inputs ( i , j , k )) end do call system_clock ( t_finish ) print * , \"Double-precision concurrent inference time: \" , real ( t_finish - t_start , real64 ) / real ( clock_rate , real64 ) end block double_precision_inference end block end program","tags":"","loc":"sourcefile/concurrent-inferences.f90.html"},{"title":"trainable_network_m.f90 – Fiats","text":"This file depends on sourcefile~~trainable_network_m.f90~~EfferentGraph sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~trainable_network_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~trainable_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~trainable_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~trainable_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~activation_m.f90 sourcefile~training_configuration_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~network_configuration_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~trainable_network_m.f90~~AfferentGraph sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~trainable_network_s.f90 trainable_network_s.f90 sourcefile~trainable_network_s.f90->sourcefile~trainable_network_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~fiats_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~fiats_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~fiats_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~fiats_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~fiats_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~fiats_m.f90 sourcefile~read-query-infer.f90 read-query-infer.f90 sourcefile~read-query-infer.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~fiats_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~fiats_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~fiats_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module trainable_network_m use neural_network_m , only : neural_network_t , workspace_t use input_output_pair_m , only : input_output_pair_t use julienne_m , only : string_t use kind_parameters_m , only : default_real use mini_batch_m , only : mini_batch_t use training_configuration_m , only : training_configuration_t use tensor_map_m , only : tensor_map_t implicit none private public :: trainable_network_t type , extends ( neural_network_t ) :: trainable_network_t ( k ) integer , kind :: k = default_real private type ( workspace_t ), private :: workspace_ contains generic :: train => default_real_train procedure , private , non_overridable :: default_real_train generic :: map_to_training_ranges => default_real_map_to_training_ranges procedure , private , non_overridable :: default_real_map_to_training_ranges end type interface trainable_network_t pure module function default_real_network ( neural_network ) result ( trainable_network ) implicit none type ( neural_network_t ), intent ( in ) :: neural_network type ( trainable_network_t ) trainable_network end function module function perturbed_identity_network ( training_configuration , perturbation_magnitude , metadata , input_map , output_map ) & result ( trainable_network ) implicit none type ( training_configuration_t ), intent ( in ) :: training_configuration type ( string_t ), intent ( in ) :: metadata (:) real , intent ( in ) :: perturbation_magnitude type ( tensor_map_t ) input_map , output_map type ( trainable_network_t ) trainable_network end function end interface interface pure module subroutine default_real_train ( self , mini_batches_arr , cost , adam , learning_rate ) implicit none class ( trainable_network_t ), intent ( inout ) :: self type ( mini_batch_t ), intent ( in ) :: mini_batches_arr (:) real , intent ( out ), allocatable , optional :: cost (:) logical , intent ( in ) :: adam real , intent ( in ) :: learning_rate end subroutine elemental module function default_real_map_to_training_ranges ( self , input_output_pair ) result ( normalized_input_output_pair ) implicit none class ( trainable_network_t ), intent ( in ) :: self type ( input_output_pair_t ), intent ( in ) :: input_output_pair type ( input_output_pair_t ) normalized_input_output_pair end function end interface end module trainable_network_m","tags":"","loc":"sourcefile/trainable_network_m.f90.html"},{"title":"training_configuration_m.f90 – Fiats","text":"This file depends on sourcefile~~training_configuration_m.f90~~EfferentGraph sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~training_configuration_m.f90->sourcefile~activation_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~training_configuration_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~network_configuration_m.f90->sourcefile~double_precision_string_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~training_configuration_m.f90~~AfferentGraph sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~fiats_m.f90->sourcefile~training_configuration_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~fiats_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~fiats_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~fiats_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~fiats_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~fiats_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~fiats_m.f90 sourcefile~read-query-infer.f90 read-query-infer.f90 sourcefile~read-query-infer.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~fiats_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~fiats_m.f90 sourcefile~trainable_network_s.f90 trainable_network_s.f90 sourcefile~trainable_network_s.f90->sourcefile~trainable_network_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~fiats_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module training_configuration_m use activation_m , only : activation_t use julienne_string_m , only : string_t use julienne_file_m , only : file_t use hyperparameters_m , only : hyperparameters_t use network_configuration_m , only : network_configuration_t use kind_parameters_m , only : default_real , double_precision use double_precision_file_m , only : double_precision_file_t implicit none private public :: training_configuration_t type , extends ( double_precision_file_t ) :: training_configuration_t ( k ) integer , kind :: k = default_real type ( hyperparameters_t ( k )), private :: hyperparameters_ type ( network_configuration_t ), private :: network_configuration_ contains generic :: operator ( == ) => default_real_equals , double_precision_equals procedure , private :: default_real_equals , double_precision_equals generic :: to_json => default_real_to_json , double_precision_to_json procedure , private :: default_real_to_json , double_precision_to_json generic :: mini_batches => default_real_mini_batches , double_precision_mini_batches procedure , private :: default_real_mini_batches , double_precision_mini_batches generic :: optimizer_name => default_real_optimizer_name , double_precision_optimizer_name procedure , private :: default_real_optimizer_name , double_precision_optimizer_name generic :: learning_rate => default_real_learning_rate , double_precision_learning_rate procedure , private :: default_real_learning_rate , double_precision_learning_rate generic :: differentiable_activation => default_real_differentiable_activation , double_precision_differentiable_activation procedure , private :: default_real_differentiable_activation , double_precision_differentiable_activation generic :: nodes_per_layer => default_real_nodes_per_layer , double_precision_nodes_per_layer procedure , private :: default_real_nodes_per_layer , double_precision_nodes_per_layer generic :: skip_connections => default_real_skip_connections , double_precision_skip_connections procedure , private :: default_real_skip_connections , double_precision_skip_connections end type interface training_configuration_t module function default_real_from_components ( hyperparameters , network_configuration ) result ( training_configuration ) implicit none type ( hyperparameters_t ), intent ( in ) :: hyperparameters type ( network_configuration_t ), intent ( in ) :: network_configuration type ( training_configuration_t ) training_configuration end function module function double_precision_from_components ( hyperparameters , network_configuration ) result ( training_configuration ) implicit none type ( hyperparameters_t ( double_precision )), intent ( in ) :: hyperparameters type ( network_configuration_t ), intent ( in ) :: network_configuration type ( training_configuration_t ( double_precision )) training_configuration end function module function default_real_from_file ( file_object ) result ( training_configuration ) implicit none type ( file_t ), intent ( in ) :: file_object type ( training_configuration_t ) training_configuration end function module function double_precision_from_file ( file_object ) result ( training_configuration ) implicit none type ( double_precision_file_t ), intent ( in ) :: file_object type ( training_configuration_t ( double_precision )) training_configuration end function end interface interface pure module function default_real_to_json ( self ) result ( json_lines ) implicit none class ( training_configuration_t ), intent ( in ) :: self type ( string_t ), allocatable :: json_lines (:) end function pure module function double_precision_to_json ( self ) result ( json_lines ) implicit none class ( training_configuration_t ( double_precision )), intent ( in ) :: self type ( string_t ), allocatable :: json_lines (:) end function elemental module function default_real_equals ( lhs , rhs ) result ( lhs_eq_rhs ) implicit none class ( training_configuration_t ), intent ( in ) :: lhs , rhs logical lhs_eq_rhs end function elemental module function double_precision_equals ( lhs , rhs ) result ( lhs_eq_rhs ) implicit none class ( training_configuration_t ( double_precision )), intent ( in ) :: lhs , rhs logical lhs_eq_rhs end function elemental module function default_real_mini_batches ( self ) result ( num_mini_batches ) implicit none class ( training_configuration_t ), intent ( in ) :: self integer num_mini_batches end function elemental module function double_precision_mini_batches ( self ) result ( num_mini_batches ) implicit none class ( training_configuration_t ( double_precision )), intent ( in ) :: self integer num_mini_batches end function elemental module function default_real_optimizer_name ( self ) result ( identifier ) implicit none class ( training_configuration_t ), intent ( in ) :: self type ( string_t ) identifier end function elemental module function double_precision_optimizer_name ( self ) result ( identifier ) implicit none class ( training_configuration_t ( double_precision )), intent ( in ) :: self type ( string_t ) identifier end function elemental module function default_real_learning_rate ( self ) result ( rate ) implicit none class ( training_configuration_t ), intent ( in ) :: self real rate end function elemental module function double_precision_learning_rate ( self ) result ( rate ) implicit none class ( training_configuration_t ( double_precision )), intent ( in ) :: self double precision rate end function module function default_real_differentiable_activation ( self ) result ( activation ) implicit none class ( training_configuration_t ), intent ( in ) :: self type ( activation_t ) activation end function module function double_precision_differentiable_activation ( self ) result ( activation ) implicit none class ( training_configuration_t ( double_precision )), intent ( in ) :: self type ( activation_t ) activation end function pure module function default_real_nodes_per_layer ( self ) result ( nodes ) implicit none class ( training_configuration_t ), intent ( in ) :: self integer , allocatable :: nodes (:) end function pure module function double_precision_nodes_per_layer ( self ) result ( nodes ) implicit none class ( training_configuration_t ( double_precision )), intent ( in ) :: self integer , allocatable :: nodes (:) end function elemental module function default_real_skip_connections ( self ) result ( using_skip ) implicit none class ( training_configuration_t ), intent ( in ) :: self logical using_skip end function elemental module function double_precision_skip_connections ( self ) result ( using_skip ) implicit none class ( training_configuration_t ( double_precision )), intent ( in ) :: self logical using_skip end function end interface end module","tags":"","loc":"sourcefile/training_configuration_m.f90.html"},{"title":"network_configuration_m.f90 – Fiats","text":"This file depends on sourcefile~~network_configuration_m.f90~~EfferentGraph sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~network_configuration_m.f90->sourcefile~double_precision_string_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~network_configuration_m.f90~~AfferentGraph sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~fiats_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~training_configuration_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~network_configuration_s.f90 network_configuration_s.F90 sourcefile~network_configuration_s.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~fiats_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~fiats_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~fiats_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~fiats_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~fiats_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~fiats_m.f90 sourcefile~read-query-infer.f90 read-query-infer.f90 sourcefile~read-query-infer.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~fiats_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~fiats_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~fiats_m.f90 sourcefile~trainable_network_s.f90 trainable_network_s.f90 sourcefile~trainable_network_s.f90->sourcefile~trainable_network_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module network_configuration_m use julienne_string_m , only : string_t use double_precision_string_m , only : double_precision_string_t implicit none private public :: network_configuration_t type network_configuration_t private logical :: skip_connections_ = . false . integer , allocatable :: nodes_per_layer_ (:) character ( len = :), allocatable :: activation_name_ contains procedure :: to_json procedure :: equals generic :: operator ( == ) => equals procedure :: activation_name procedure :: nodes_per_layer procedure :: skip_connections end type interface network_configuration_t pure module function from_json ( lines ) result ( network_configuration ) implicit none type ( string_t ), intent ( in ) :: lines (:) type ( network_configuration_t ) network_configuration end function pure module function from_double_precision_string_json ( lines ) result ( network_configuration ) implicit none type ( double_precision_string_t ), intent ( in ) :: lines (:) type ( network_configuration_t ) network_configuration end function pure module function from_components ( skip_connections , nodes_per_layer , activation_name ) result ( network_configuration ) implicit none logical , intent ( in ) :: skip_connections integer , intent ( in ) :: nodes_per_layer (:) character ( len =* ), intent ( in ) :: activation_name type ( network_configuration_t ) network_configuration end function end interface interface pure module function to_json ( self ) result ( lines ) implicit none class ( network_configuration_t ), intent ( in ) :: self type ( string_t ), allocatable :: lines (:) end function elemental module function equals ( lhs , rhs ) result ( lhs_equals_rhs ) implicit none class ( network_configuration_t ), intent ( in ) :: lhs , rhs logical lhs_equals_rhs end function elemental module function activation_name ( self ) result ( string ) implicit none class ( network_configuration_t ), intent ( in ) :: self type ( string_t ) string end function pure module function nodes_per_layer ( self ) result ( nodes ) implicit none class ( network_configuration_t ), intent ( in ) :: self integer , allocatable :: nodes (:) end function elemental module function skip_connections ( self ) result ( using_skip ) implicit none class ( network_configuration_t ), intent ( in ) :: self logical using_skip end function end interface end module","tags":"","loc":"sourcefile/network_configuration_m.f90.html"},{"title":"tensor_s.f90 – Fiats","text":"This file depends on sourcefile~~tensor_s.f90~~EfferentGraph sourcefile~tensor_s.f90 tensor_s.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~tensor_s.f90->sourcefile~tensor_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( tensor_m ) tensor_s implicit none contains module procedure construct_default_real tensor % values_ = values end procedure module procedure construct_double_precision tensor % values_ = values end procedure module procedure default_real_values tensor_values = self % values_ end procedure module procedure double_precision_values tensor_values = self % values_ end procedure module procedure default_real_num_components n = size ( self % values_ ) end procedure module procedure double_precision_num_components n = size ( self % values_ ) end procedure end submodule tensor_s","tags":"","loc":"sourcefile/tensor_s.f90.html"},{"title":"learn-multiplication.F90 – Fiats","text":"This file depends on sourcefile~~learn-multiplication.f90~~EfferentGraph sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~learn-multiplication.f90->sourcefile~fiats_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~fiats_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~fiats_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~fiats_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~fiats_m.f90->sourcefile~metadata_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~fiats_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~network_configuration_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~fiats_m.f90->sourcefile~ubounds_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_network_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~activation_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module multiply_inputs !! Define a function that produces the desired network output for a given network input use fiats_m , only : tensor_t use assert_m , only : assert implicit none contains elemental function y ( x_tensor ) result ( a_tensor ) type ( tensor_t ), intent ( in ) :: x_tensor type ( tensor_t ) a_tensor associate ( x => x_tensor % values ()) call assert ( ubound ( x , 1 ) >= 7 . and . lbound ( x , 1 ) <= 2 , \"y(x) :: sufficient input\" ) a_tensor = tensor_t ([ x ( 1 ) * x ( 2 ), x ( 2 ) * x ( 3 ), x ( 3 ) * x ( 4 ), x ( 4 ) * x ( 5 ), x ( 5 ) * x ( 6 ), x ( 6 ) * x ( 8 )]) end associate end function end module program learn_multiplication !! This trains a neural network to learn the following six polynomial functions of its eight inputs. use fiats_m , only : neural_network_t , trainable_network_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle use julienne_m , only : string_t , file_t , command_line_t , bin_t use assert_m , only : assert , intrinsic_array_t use multiply_inputs , only : y implicit none type ( string_t ) final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example learn-multiplication --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 10 , num_epochs = 200000 , num_mini_batches = 2 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_network_t ) trainable_network type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) call random_init ( image_distinct = . true ., repeatable = . true .) trainable_network = perturbed_identity_network ( perturbation_magnitude = 0.05 ) call output ( trainable_network , string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_network % num_inputs (), num_outputs => trainable_network % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) inputs = [( tensor_t ( real ([( j * i , j = 1 , num_inputs )]) / ( num_inputs * num_pairs )), i = 1 , num_pairs )] desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_network % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block integer p #if defined _CRAYFTN || __GFORTRAN__ type ( tensor_t ), allocatable :: network_outputs (:) network_outputs = trainable_network % infer ( inputs ) #else associate ( network_outputs => trainable_network % infer ( inputs )) #endif print \"(a,69x,a)\" , \"  Outputs\" , \"| Desired outputs\" do p = 1 , num_pairs print \"(6G13.5, a1, 6G13.5)\" , network_outputs ( p )% values (), \"|\" , desired_outputs ( p )% values () end do #if defined _CRAYFTN || __GFORTRAN__ #else end associate #endif end block end associate call output ( trainable_network , final_network_file ) end block contains subroutine output ( neural_network , file_name ) class ( neural_network_t ), intent ( in ) :: neural_network type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = neural_network % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_network ) type ( trainable_network_t ) trainable_network real , intent ( in ) :: perturbation_magnitude integer , parameter :: n ( * ) = [ 8 , 64 , 64 , 64 , 6 ] integer , parameter :: n_max = maxval ( n ), layers = size ( n ) integer k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_network = trainable_network_t ( neural_network_t ( & nodes = n , weights = w , biases = b , metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & )) end associate end function end program","tags":"","loc":"sourcefile/learn-multiplication.f90.html"},{"title":"activation_m.f90 – Fiats","text":"Files dependent on this one sourcefile~~activation_m.f90~~AfferentGraph sourcefile~activation_m.f90 activation_m.f90 sourcefile~activation_s.f90 activation_s.f90 sourcefile~activation_s.f90->sourcefile~activation_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~activation_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~activation_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~training_configuration_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~neural_network_m.f90 sourcefile~neural_network_s.f90 neural_network_s.F90 sourcefile~neural_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~neural_network_s.f90->sourcefile~layer_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~unmapped_network_s.f90 unmapped_network_s.f90 sourcefile~unmapped_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~workspace_s.f90 workspace_s.f90 sourcefile~workspace_s.f90->sourcefile~neural_network_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~fiats_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~fiats_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~fiats_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~fiats_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~fiats_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~fiats_m.f90 sourcefile~read-query-infer.f90 read-query-infer.f90 sourcefile~read-query-infer.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~fiats_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~fiats_m.f90 sourcefile~trainable_network_s.f90 trainable_network_s.f90 sourcefile~trainable_network_s.f90->sourcefile~trainable_network_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~fiats_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module activation_m use iso_c_binding , only : c_int use julienne_m , only : string_t implicit none private public :: activation_t public :: gelu , relu , sigmoid , step , swish enum , bind ( C ) enumerator :: gelu = 1 , relu , sigmoid , step , swish end enum character ( len =* ), parameter :: activation_name ( * ) = [ character ( len ( \"sigmoid\" )) :: \"gelu\" , \"relu\" , \"sigmoid\" , \"step\" , \"swish\" ] type activation_t private integer ( c_int ) :: selection_ = sigmoid contains procedure , non_overridable :: function_name generic :: operator ( == ) => equals procedure , private :: equals generic :: evaluate => default_real_evaluate , double_precision_evaluate procedure , non_overridable , private :: default_real_evaluate , double_precision_evaluate generic :: differentiate => default_real_differentiate , double_precision_differentiate procedure , non_overridable , private :: default_real_differentiate , double_precision_differentiate end type interface activation_t elemental module function construct_from_component ( selection ) result ( activation ) implicit none integer ( c_int ), intent ( in ) :: selection type ( activation_t ) activation end function elemental module function construct_from_name ( name ) result ( activation ) implicit none character ( len =* ), intent ( in ) :: name type ( activation_t ) activation end function end interface interface elemental module function equals ( self , rhs ) result ( self_eq_rhs ) implicit none class ( activation_t ), intent ( in ) :: self type ( activation_t ), intent ( in ) :: rhs logical self_eq_rhs end function elemental module function default_real_evaluate ( self , x ) result ( y ) implicit none class ( activation_t ), intent ( in ) :: self real , intent ( in ) :: x real y end function elemental module function double_precision_evaluate ( self , x ) result ( y ) implicit none class ( activation_t ), intent ( in ) :: self double precision , intent ( in ) :: x double precision y end function elemental module function default_real_differentiate ( self , x ) result ( dy_dx ) implicit none class ( activation_t ), intent ( in ) :: self real , intent ( in ) :: x real dy_dx end function elemental module function double_precision_differentiate ( self , x ) result ( dy_dx ) implicit none class ( activation_t ), intent ( in ) :: self double precision , intent ( in ) :: x double precision dy_dx end function elemental module function function_name ( self ) result ( string ) implicit none class ( activation_t ), intent ( in ) :: self type ( string_t ) string end function end interface end module activation_m","tags":"","loc":"sourcefile/activation_m.f90.html"},{"title":"neural_network_s.F90 – Fiats","text":"This file depends on sourcefile~~neural_network_s.f90~~EfferentGraph sourcefile~neural_network_s.f90 neural_network_s.F90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~neural_network_s.f90->sourcefile~double_precision_string_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neural_network_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~neural_network_s.f90->sourcefile~layer_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~neural_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~neural_network_s.f90->sourcefile~neuron_m.f90 sourcefile~layer_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~neural_network_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~layer_m.f90->sourcefile~metadata_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~layer_m.f90->sourcefile~tensor_map_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~neuron_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( neural_network_m ) neural_network_s use assert_m , only : assert , intrinsic_array_t use double_precision_string_m , only : double_precision_string_t use kind_parameters_m , only : double_precision use layer_m , only : layer_t use neuron_m , only : neuron_t implicit none character ( len =* ), parameter :: minimum_acceptable_tag = \"0.15.0\" ! git tag capable of reading the current json file format integer , parameter :: input_layer = 0 contains module procedure default_real_map_to_input_range normalized_tensor = self % input_map_ % map_to_training_range ( tensor ) end procedure module procedure double_precision_map_to_input_range normalized_tensor = self % input_map_ % map_to_training_range ( tensor ) end procedure module procedure default_real_map_from_output_range tensor = self % output_map_ % map_from_training_range ( normalized_tensor ) end procedure module procedure double_precision_map_from_output_range tensor = self % output_map_ % map_from_training_range ( normalized_tensor ) end procedure module procedure default_real_infer real , allocatable :: a (:,:) integer l call self % assert_consistency () associate ( w => self % weights_ , b => self % biases_ , n => self % nodes_ , output_layer => ubound ( self % nodes_ , 1 )) allocate ( a ( maxval ( n ), input_layer : output_layer )) #ifndef _CRAYFTN associate ( normalized_inputs => self % input_map_ % map_to_training_range ( inputs )) a ( 1 : n ( input_layer ), input_layer ) = normalized_inputs % values () end associate #else block type ( tensor_t ) normalized_inputs normalized_inputs = self % input_map_ % map_to_training_range ( inputs ) a ( 1 : n ( input_layer ), input_layer ) = normalized_inputs % values () end block #endif feed_forward : & do l = input_layer + 1 , output_layer associate ( z => matmul ( w ( 1 : n ( l ), 1 : n ( l - 1 ), l ), a ( 1 : n ( l - 1 ), l - 1 )) + b ( 1 : n ( l ), l )) a ( 1 : n ( l ), l ) = self % activation_ % evaluate ( z ) end associate end do feed_forward #ifndef _CRAYFTN associate ( normalized_outputs => tensor_t ( a ( 1 : n ( output_layer ), output_layer ))) outputs = self % output_map_ % map_from_training_range ( normalized_outputs ) end associate #else block type ( tensor_t ) :: normalized_outputs normalized_outputs = tensor_t ( a ( 1 : n ( output_layer ), output_layer )) outputs = self % output_map_ % map_from_training_range ( normalized_outputs ) end block #endif end associate end procedure module procedure double_precision_infer double precision , allocatable :: a (:,:) integer l call self % assert_consistency () associate ( w => self % weights_ , b => self % biases_ , n => self % nodes_ , output_layer => ubound ( self % nodes_ , 1 )) allocate ( a ( maxval ( n ), input_layer : output_layer )) #ifndef _CRAYFTN associate ( normalized_inputs => self % input_map_ % map_to_training_range ( inputs )) a ( 1 : n ( input_layer ), input_layer ) = normalized_inputs % values () end associate #else block type ( tensor_t ) normalized_inputs normalized_inputs = self % input_map_ % map_to_training_range ( inputs ) a ( 1 : n ( input_layer ), input_layer ) = normalized_inputs % values () end block #endif feed_forward : & do l = input_layer + 1 , output_layer associate ( z => matmul ( w ( 1 : n ( l ), 1 : n ( l - 1 ), l ), a ( 1 : n ( l - 1 ), l - 1 )) + b ( 1 : n ( l ), l )) a ( 1 : n ( l ), l ) = self % activation_ % evaluate ( z ) end associate end do feed_forward #ifdef _CRAYFTN block type ( tensor_t ) :: normalized_outputs normalized_outputs = tensor_t ( a ( 1 : n ( output_layer ), output_layer )) #else associate ( normalized_outputs => tensor_t ( a ( 1 : n ( output_layer ), output_layer ))) #endif outputs = self % output_map_ % map_from_training_range ( normalized_outputs ) #ifdef _CRAYFTN end block #else end associate #endif end associate end procedure module procedure default_real_consistency associate ( & all_allocated => [ allocated ( self % weights_ ), allocated ( self % biases_ ), allocated ( self % nodes_ )]& ) call assert ( all ( all_allocated ), \"neural_network_s(default_real_consistency): fully_allocated\" , & intrinsic_array_t ( all_allocated )) end associate associate ( max_width => maxval ( self % nodes_ ), component_dims => [ size ( self % biases_ , 1 ), size ( self % weights_ , 1 ), size ( self % weights_ , 2 )]) call assert ( all ( component_dims == max_width ), \"neural_network_s(default_real_consistency): conformable arrays\" , & intrinsic_array_t ([ max_width , component_dims ])) end associate associate ( input_subscript => lbound ( self % nodes_ , 1 )) call assert ( input_subscript == input_layer , \"neural_network_s(default_real_consistency): n base subsscript\" , & input_subscript ) end associate end procedure module procedure double_precision_consistency associate ( & all_allocated => [ allocated ( self % weights_ ), allocated ( self % biases_ ), allocated ( self % nodes_ )]& ) call assert ( all ( all_allocated ), \"neural_network_s(default_real_consistency): fully_allocated\" , & intrinsic_array_t ( all_allocated )) end associate associate ( max_width => maxval ( self % nodes_ ), component_dims => [ size ( self % biases_ , 1 ), size ( self % weights_ , 1 ), size ( self % weights_ , 2 )]) call assert ( all ( component_dims == max_width ), \"neural_network_s(default_real_consistency): conformable arrays\" , & intrinsic_array_t ([ max_width , component_dims ])) end associate associate ( input_subscript => lbound ( self % nodes_ , 1 )) call assert ( input_subscript == input_layer , \"neural_network_s(default_real_consistency): n base subsscript\" , & input_subscript ) end associate end procedure module procedure default_real_construct_from_components neural_network % metadata_ = metadata_t ( metadata ( 1 ), metadata ( 2 ), metadata ( 3 ), metadata ( 4 ), metadata ( 5 )) neural_network % weights_ = weights neural_network % biases_ = biases neural_network % nodes_ = nodes block integer i if ( present ( input_map )) then neural_network % input_map_ = input_map else associate ( num_inputs => nodes ( lbound ( nodes , 1 ))) associate ( default_minima => [( 0. , i = 1 , num_inputs )], default_maxima => [( 1. , i = 1 , num_inputs )]) neural_network % input_map_ = tensor_map_t ( \"inputs\" , default_minima , default_maxima ) end associate end associate end if if ( present ( output_map )) then neural_network % output_map_ = output_map else associate ( num_outputs => nodes ( ubound ( nodes , 1 ))) associate ( default_minima => [( 0. , i = 1 , num_outputs )], default_maxima => [( 1. , i = 1 , num_outputs )]) neural_network % output_map_ = tensor_map_t ( \"outputs\" , default_minima , default_maxima ) end associate end associate end if end block neural_network % activation_ = activation_t ( metadata ( 4 )% string ()) call neural_network % assert_consistency () end procedure default_real_construct_from_components module procedure double_precision_construct_from_components neural_network % metadata_ = metadata neural_network % weights_ = weights neural_network % biases_ = biases neural_network % nodes_ = nodes block integer i if ( present ( input_map )) then neural_network % input_map_ = input_map else associate ( num_inputs => nodes ( lbound ( nodes , 1 ))) associate ( default_intercept => [( 0 D0 , i = 1 , num_inputs )], default_slope => [( 1 D0 , i = 1 , num_inputs )]) neural_network % input_map_ = tensor_map_t ( \"inputs\" , default_intercept , default_slope ) end associate end associate end if if ( present ( output_map )) then neural_network % output_map_ = output_map else associate ( num_outputs => nodes ( ubound ( nodes , 1 ))) associate ( default_intercept => [( 0 D0 , i = 1 , num_outputs )], default_slope => [( 1 D0 , i = 1 , num_outputs )]) neural_network % output_map_ = tensor_map_t ( \"outputs\" , default_intercept , default_slope ) end associate end associate end if end block associate ( function_name => metadata % activation_name ()) neural_network % activation_ = activation_t ( function_name % string ()) end associate call neural_network % assert_consistency () end procedure double_precision_construct_from_components module procedure default_real_to_json #ifdef _CRAYFTN type ( tensor_map_t ) proto_map type ( metadata_t ) proto_meta type ( neuron_t ) proto_neuron proto_map = tensor_map_t ( \"\" ,[ 0. ],[ 1. ]) proto_meta = metadata_t ( string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" )) proto_neuron = neuron_t ([ 0. ], 1. ) #endif call self % assert_consistency () associate ( & num_hidden_layers => self % num_hidden_layers () & , num_outputs => self % num_outputs () & , num_inputs => self % num_inputs () & , first_hidden => lbound ( self % nodes_ , 1 ) + 1 & , last_hidden => ubound ( self % nodes_ , 1 ) - 1 & #ifndef _CRAYFTN , proto_map => tensor_map_t ( \"\" ,[ 0. ],[ 1. ]) & , proto_meta => metadata_t ( string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" )) & , proto_neuron => neuron_t ([ 0. ], 0. ) & #endif ) associate ( & metadata_lines => size ( proto_meta % to_json ()), & tensor_map_lines => size ( proto_map % to_json ()), & neuron_lines => size ( proto_neuron % to_json ()) & ) block type ( string_t ), allocatable :: lines (:) integer layer , n , line integer , parameter :: & brace = 1 , bracket_hidden_layers_array = 1 , bracket_layer = 1 , bracket_output_layer = 1 , file_version_lines = 1 associate ( json_lines => & brace + & ! { file_version_lines + & !   \"minimum_acceptable_tag\": ... metadata_lines + & !   \"metadata\": ... tensor_map_lines + & !   \"inputs_tensor_map\": ... tensor_map_lines + & !   \"outputs_tensor_map\": ... bracket_hidden_layers_array + & !   \"hidden_layers\": [ bracket_layer * num_hidden_layers + & !      [ neuron_lines * sum ( self % nodes_ ( first_hidden : last_hidden )) + & !        neuron ... bracket_layer * num_hidden_layers + & !      ] ... bracket_hidden_layers_array + & !   ], bracket_output_layer + & !   \"output_layer\": [ neuron_lines * num_outputs + & !        neurons bracket_output_layer + & !    ] brace & ! } ) allocate ( lines ( json_lines )) lines ( brace ) = string_t ( '{' ) lines ( brace + 1 : brace + file_version_lines ) = string_t ( '    \"minimum_acceptable_tag\": \"' ) // minimum_acceptable_tag // '\",' associate ( meta_start => brace + file_version_lines + 1 ) associate ( meta_end => meta_start + metadata_lines - 1 ) lines ( meta_start : meta_end ) = self % metadata_ % to_json () lines ( meta_end ) = lines ( meta_end ) // \",\" associate ( input_map_start => meta_end + 1 , input_map_end => meta_end + tensor_map_lines ) lines ( input_map_start : input_map_end ) = self % input_map_ % to_json () lines ( input_map_end ) = lines ( input_map_end ) // \",\" associate ( output_map_start => input_map_end + 1 , output_map_end => input_map_end + tensor_map_lines ) lines ( output_map_start : output_map_end ) = self % output_map_ % to_json () lines ( output_map_end ) = lines ( output_map_end ) // \",\" lines ( output_map_end + 1 ) = string_t ( '     \"hidden_layers\": [' ) line = output_map_end + 1 end associate end associate end associate end associate do layer = first_hidden , last_hidden line = line + 1 lines ( line ) = string_t ( '         [' ) do n = 1 , self % nodes_ ( layer ) associate ( & neuron => neuron_t ( weights = self % weights_ ( n , 1 : self % nodes_ ( layer - 1 ), layer ), bias = self % biases_ ( n , layer )), & neuron_start => line + 1 , & neuron_end => line + neuron_lines & ) lines ( neuron_start : neuron_end ) = neuron % to_json () lines ( neuron_end ) = lines ( neuron_end ) // trim ( merge ( \" \" , \",\" , n == self % nodes_ ( layer ))) end associate line = line + neuron_lines end do line = line + 1 lines ( line ) = string_t ( '         ]' ) // trim ( merge ( \" \" , \",\" , layer == last_hidden )) end do line = line + 1 lines ( line ) = string_t ( '    ],' ) line = line + 1 lines ( line ) = string_t ( '     \"output_layer\": [' ) layer = last_hidden + 1 do n = 1 , self % nodes_ ( layer ) associate ( & neuron => neuron_t ( weights = self % weights_ ( n , 1 : self % nodes_ ( layer - 1 ), layer ), bias = self % biases_ ( n , layer )), & neuron_start => line + 1 , & neuron_end => line + neuron_lines & ) lines ( neuron_start : neuron_end ) = neuron % to_json () lines ( neuron_end ) = lines ( neuron_end ) // trim ( merge ( \" \" , \",\" , n == self % nodes_ ( layer ))) end associate line = line + neuron_lines end do line = line + 1 lines ( line ) = string_t ( '         ]' ) line = line + 1 lines ( line ) = string_t ( '}' ) call assert ( line == json_lines , \"neural_network_t%to_json: all lines defined\" , intrinsic_array_t ([ json_lines , line ])) end associate json_file = file_t ( lines ) end block end associate end associate end procedure default_real_to_json module procedure double_precision_to_json #ifdef _CRAYFTN type ( tensor_map_t ) proto_map type ( metadata_t ) proto_meta type ( neuron_t ) proto_neuron proto_map = tensor_map_t ( \"\" ,[ 0 D0 ],[ 1 D0 ]) proto_meta = metadata_t ( string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" )) proto_neuron = neuron_t ([ 0 D0 ], 1 D0 ) #endif call self % assert_consistency () associate ( & num_hidden_layers => self % num_hidden_layers () & , num_outputs => self % num_outputs () & , num_inputs => self % num_inputs () & , first_hidden => lbound ( self % nodes_ , 1 ) + 1 & , last_hidden => ubound ( self % nodes_ , 1 ) - 1 & #ifndef _CRAYFTN , proto_map => tensor_map_t ( \"\" ,[ 0 D0 ],[ 0 D0 ]) & , proto_meta => metadata_t ( string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" )) & , proto_neuron => neuron_t ([ 0 D0 ], 0 D0 ) & #endif ) associate ( & metadata_lines => size ( proto_meta % to_json ()), & tensor_map_lines => size ( proto_map % to_json ()), & neuron_lines => size ( proto_neuron % to_json ()) & ) block type ( string_t ), allocatable :: lines (:) integer layer , n , line integer , parameter :: & brace = 1 , bracket_hidden_layers_array = 1 , bracket_layer = 1 , bracket_output_layer = 1 , file_version_lines = 1 associate ( json_lines => & brace + & ! { file_version_lines + & !   \"minimum_acceptable_tag\": ... metadata_lines + & !   \"metadata\": ... tensor_map_lines + & !   \"inputs_tensor_map\": ... tensor_map_lines + & !   \"outputs_tensor_map\": ... bracket_hidden_layers_array + & !   \"hidden_layers\": [ bracket_layer * num_hidden_layers + & !      [ neuron_lines * sum ( self % nodes_ ( first_hidden : last_hidden )) + & !        neuron ... bracket_layer * num_hidden_layers + & !      ] ... bracket_hidden_layers_array + & !   ], bracket_output_layer + & !   \"output_layer\": [ neuron_lines * num_outputs + & !        neurons bracket_output_layer + & !    ] brace & ! } ) allocate ( lines ( json_lines )) lines ( brace ) = string_t ( '{' ) lines ( brace + 1 : brace + file_version_lines ) = string_t ( '    \"minimum_acceptable_tag\": \"' ) // minimum_acceptable_tag // '\",' associate ( meta_start => brace + file_version_lines + 1 ) associate ( meta_end => meta_start + metadata_lines - 1 ) lines ( meta_start : meta_end ) = self % metadata_ % to_json () lines ( meta_end ) = lines ( meta_end ) // \",\" associate ( input_map_start => meta_end + 1 , input_map_end => meta_end + tensor_map_lines ) lines ( input_map_start : input_map_end ) = self % input_map_ % to_json () lines ( input_map_end ) = lines ( input_map_end ) // \",\" associate ( output_map_start => input_map_end + 1 , output_map_end => input_map_end + tensor_map_lines ) lines ( output_map_start : output_map_end ) = self % output_map_ % to_json () lines ( output_map_end ) = lines ( output_map_end ) // \",\" lines ( output_map_end + 1 ) = string_t ( '     \"hidden_layers\": [' ) line = output_map_end + 1 end associate end associate end associate end associate do layer = first_hidden , last_hidden line = line + 1 lines ( line ) = string_t ( '         [' ) do n = 1 , self % nodes_ ( layer ) associate ( & neuron => neuron_t ( weights = self % weights_ ( n , 1 : self % nodes_ ( layer - 1 ), layer ), bias = self % biases_ ( n , layer )), & neuron_start => line + 1 , & neuron_end => line + neuron_lines & ) lines ( neuron_start : neuron_end ) = neuron % to_json () lines ( neuron_end ) = lines ( neuron_end ) // trim ( merge ( \" \" , \",\" , n == self % nodes_ ( layer ))) end associate line = line + neuron_lines end do line = line + 1 lines ( line ) = string_t ( '         ]' ) // trim ( merge ( \" \" , \",\" , layer == last_hidden )) end do line = line + 1 lines ( line ) = string_t ( '    ],' ) line = line + 1 lines ( line ) = string_t ( '     \"output_layer\": [' ) layer = last_hidden + 1 do n = 1 , self % nodes_ ( layer ) associate ( & neuron => neuron_t ( weights = self % weights_ ( n , 1 : self % nodes_ ( layer - 1 ), layer ), bias = self % biases_ ( n , layer )), & neuron_start => line + 1 , & neuron_end => line + neuron_lines & ) lines ( neuron_start : neuron_end ) = neuron % to_json () lines ( neuron_end ) = lines ( neuron_end ) // trim ( merge ( \" \" , \",\" , n == self % nodes_ ( layer ))) end associate line = line + neuron_lines end do line = line + 1 lines ( line ) = string_t ( '         ]' ) line = line + 1 lines ( line ) = string_t ( '}' ) call assert ( line == json_lines , \"neural_network_t%to_json: all lines defined\" , intrinsic_array_t ([ json_lines , line ])) end associate json_file = file_t ( lines ) end block end associate end associate end procedure double_precision_to_json module procedure default_real_from_json character ( len = :), allocatable :: justified_line integer l , num_file_lines type ( string_t ), allocatable :: lines (:) type ( tensor_map_t ) input_map , output_map type ( layer_t ) hidden_layers , output_layer lines = file_ % lines () call assert ( adjustl ( lines ( 1 )% string ()) == \"{\" , \"neural_network_s(default_real_from_json): expected outermost object '{'\" ) check_git_tag : & block character ( len = :), allocatable :: tag tag = lines ( 2 )% get_json_value ( \"minimum_acceptable_tag\" , mold = \"\" ) call assert ( & tag == minimum_acceptable_tag & , \"neural_network_s(default_real_from_json): minimum_acceptable_tag\" & , tag // \"(expected \" // minimum_acceptable_tag // \")\" & ) end block check_git_tag num_file_lines = size ( lines ) read_tensor_maps : & associate ( proto_map => tensor_map_t ( \"\" ,[ 0. ],[ 1. ])) associate ( num_map_lines => size ( proto_map % to_json ())) find_inputs_map : & do l = 1 , num_file_lines justified_line = adjustl ( lines ( l )% string ()) if ( justified_line == '\"inputs_map\": {' ) exit end do find_inputs_map call assert ( justified_line == '\"inputs_map\": {' , 'default_real_from_json: expecting \"inputs_map\": {' , justified_line ) input_map = tensor_map_t ( lines ( l : l + num_map_lines - 1 )) find_outputs_map : & do l = 1 , num_file_lines justified_line = adjustl ( lines ( l )% string ()) if ( justified_line == '\"outputs_map\": {' ) exit end do find_outputs_map call assert ( justified_line == '\"outputs_map\": {' , 'default_real_from_json: expecting \"outputs_map\": {' , justified_line ) output_map = tensor_map_t ( lines ( l : l + num_map_lines - 1 )) end associate end associate read_tensor_maps find_hidden_layers : & do l = 1 , num_file_lines justified_line = adjustl ( lines ( l )% string ()) if ( justified_line == '\"hidden_layers\": [' ) exit end do find_hidden_layers call assert ( justified_line == '\"hidden_layers\": [' , 'default_real_from_json: expecting \"hidden_layers\": [' , justified_line ) read_hidden_layers : & block integer , parameter :: bracket_lines_per_layer = 2 character ( len = :), allocatable :: output_layer_line hidden_layers = layer_t ( lines , start = l + 1 ) read_layers_of_neurons : & associate ( proto_neuron => neuron_t ( weights = [ 0. ], bias = 0. )) associate ( output_layer_line_number => l + 1 + size ( proto_neuron % to_json ()) * sum ( hidden_layers % count_neurons ()) & + bracket_lines_per_layer * hidden_layers % count_layers () + 1 ) output_layer_line = lines ( output_layer_line_number )% string () call assert ( adjustl ( output_layer_line ) == '\"output_layer\": [' , 'default_real_from_json: expecting \"output_layer\": [' , & lines ( output_layer_line_number )% string ()) output_layer = layer_t ( lines , start = output_layer_line_number ) end associate end associate read_layers_of_neurons end block read_hidden_layers find_metadata : & do l = 1 , num_file_lines justified_line = adjustl ( lines ( l )% string ()) if ( justified_line == '\"metadata\": {' ) exit end do find_metadata call assert ( justified_line == '\"metadata\": {' , 'default_real_from_json: expecting \"metadata\": {' , justified_line ) read_metadata : & associate ( proto_meta => metadata_t ( string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ))) associate ( metadata => metadata_t ( lines ( l : l + size ( proto_meta % to_json ()) - 1 ))) associate ( metadata_strings => metadata % strings ()) neural_network = hidden_layers % neural_network ( metadata_strings , output_layer , input_map , output_map ) associate ( function_name => metadata % activation_name ()) neural_network % activation_ = activation_t ( function_name % string ()) end associate end associate end associate end associate read_metadata call neural_network % assert_consistency () end procedure default_real_from_json module procedure double_precision_from_json character ( len = :), allocatable :: justified_line integer l , num_file_lines type ( double_precision_string_t ), allocatable :: lines (:) type ( tensor_map_t ( double_precision )) input_map , output_map type ( layer_t ( double_precision )) hidden_layers , output_layer lines = file % double_precision_lines () call assert ( adjustl ( lines ( 1 )% string ()) == \"{\" , \"neural_network_s(double_precision_from_json): expected outermost object '{'\" ) check_git_tag : & block character ( len = :), allocatable :: tag tag = lines ( 2 )% get_json_value ( \"minimum_acceptable_tag\" , mold = \"\" ) call assert ( & tag == minimum_acceptable_tag & , \"neural_network_s(double_precision_from_json): minimum_acceptable_tag\" & , tag // \"(expected \" // minimum_acceptable_tag // \")\" & ) end block check_git_tag num_file_lines = size ( lines ) read_tensor_maps : & associate ( proto_map => tensor_map_t ( \"\" ,[ 0 D0 ],[ 1 D0 ])) associate ( num_map_lines => size ( proto_map % to_json ())) find_inputs_map : & do l = 1 , num_file_lines justified_line = adjustl ( lines ( l )% string ()) if ( justified_line == '\"inputs_map\": {' ) exit end do find_inputs_map call assert ( justified_line == '\"inputs_map\": {' , 'double_precision_from_json: expecting \"inputs_map\": {' , justified_line ) input_map = tensor_map_t ( lines ( l : l + num_map_lines - 1 )) find_outputs_map : & do l = 1 , num_file_lines justified_line = adjustl ( lines ( l )% string ()) if ( justified_line == '\"outputs_map\": {' ) exit end do find_outputs_map call assert ( justified_line == '\"outputs_map\": {' , 'double_precision_from_json: expecting \"outputs_map\": {' , justified_line ) output_map = tensor_map_t ( lines ( l : l + num_map_lines - 1 )) end associate end associate read_tensor_maps find_hidden_layers : & do l = 1 , num_file_lines justified_line = adjustl ( lines ( l )% string ()) if ( justified_line == '\"hidden_layers\": [' ) exit end do find_hidden_layers call assert ( justified_line == '\"hidden_layers\": [' , 'double_precision_from_json: expecting \"hidden_layers\": [' , justified_line ) read_hidden_layers : & block integer , parameter :: bracket_lines_per_layer = 2 character ( len = :), allocatable :: output_layer_line hidden_layers = layer_t ( lines , start = l + 1 ) read_layers_of_neurons : & associate ( proto_neuron => neuron_t ( weights = [ 0 D0 ], bias = 0 D0 )) associate ( output_layer_line_number => l + 1 + size ( proto_neuron % to_json ()) * sum ( hidden_layers % count_neurons ()) & + bracket_lines_per_layer * hidden_layers % count_layers () + 1 ) output_layer_line = lines ( output_layer_line_number )% string () call assert ( adjustl ( output_layer_line ) == '\"output_layer\": [' , 'double_precision_from_json: expecting \"output_layer\": [' , & lines ( output_layer_line_number )% string ()) output_layer = layer_t ( lines , start = output_layer_line_number ) end associate end associate read_layers_of_neurons end block read_hidden_layers find_metadata : & do l = 1 , num_file_lines justified_line = adjustl ( lines ( l )% string ()) if ( justified_line == '\"metadata\": {' ) exit end do find_metadata call assert ( justified_line == '\"metadata\": {' , 'double_precision_from_json: expecting \"metadata\": {' , justified_line ) read_metadata : & associate ( proto_meta => metadata_t ( string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ))) associate ( metadata => metadata_t ( lines ( l : l + size ( proto_meta % to_json ()) - 1 ))) neural_network = hidden_layers % neural_network ( metadata , output_layer , input_map , output_map ) associate ( function_name => metadata % activation_name ()) neural_network % activation_ = activation_t ( function_name % string ()) end associate end associate end associate read_metadata call neural_network % assert_consistency () end procedure double_precision_from_json module procedure default_real_assert_conformable_with call self % assert_consistency () associate ( equal_shapes => [ & shape ( self % weights_ ) == shape ( neural_network % weights_ ), & shape ( self % biases_ ) == shape ( neural_network % biases_ ), & shape ( self % nodes_ ) == shape ( neural_network % nodes_ ) & ]) call assert ( all ( equal_shapes ), \"assert_conformable_with: all(equal_shapes)\" , intrinsic_array_t ( equal_shapes )) end associate call assert ( self % activation_ == neural_network % activation_ , \"assert_conformable_with: activation_\" ) end procedure module procedure double_precision_assert_conformable_with call self % assert_consistency () associate ( equal_shapes => [ & shape ( self % weights_ ) == shape ( neural_network % weights_ ), & shape ( self % biases_ ) == shape ( neural_network % biases_ ), & shape ( self % nodes_ ) == shape ( neural_network % nodes_ ) & ]) call assert ( all ( equal_shapes ), \"assert_conformable_with: all(equal_shapes)\" , intrinsic_array_t ( equal_shapes )) end associate call assert ( self % activation_ == neural_network % activation_ , \"assert_conformable_with: activation_\" ) end procedure module procedure default_real_approximately_equal logical nodes_eq nodes_eq = all ( lhs % nodes_ == rhs % nodes_ ) call lhs % assert_consistency () call rhs % assert_consistency () call lhs % assert_conformable_with ( rhs ) block integer l logical layer_eq ( ubound ( lhs % nodes_ , 1 )) real , parameter :: tolerance = 1.E-06 associate ( n => lhs % nodes_ ) #ifndef __INTEL_COMPILER do concurrent ( l = 1 : ubound ( n , 1 )) layer_eq ( l ) = all ( abs ( lhs % weights_ ( 1 : n ( l ), 1 : n ( l - 1 ), l ) - rhs % weights_ ( 1 : n ( l ), 1 : n ( l - 1 ), l )) < tolerance ) . and . & all ( abs ( lhs % biases_ ( 1 : n ( l ), l ) - rhs % biases_ ( 1 : n ( l ), l )) < tolerance ) end do #else block integer j , k do l = 1 , ubound ( n , 1 ) do j = 1 , n ( l ) do k = 1 , n ( l - 1 ) layer_eq ( l ) = all ( abs ( lhs % weights_ ( j , k , l ) - rhs % weights_ ( j , k , l )) < tolerance ) . and . & all ( abs ( lhs % biases_ ( j , l ) - rhs % biases_ ( j , l )) < tolerance ) end do end do end do end block #endif end associate lhs_eq_rhs = nodes_eq . and . all ( layer_eq ) end block end procedure module procedure double_precision_approximately_equal logical nodes_eq nodes_eq = all ( lhs % nodes_ == rhs % nodes_ ) call lhs % assert_consistency () call rhs % assert_consistency () call lhs % assert_conformable_with ( rhs ) block integer l logical layer_eq ( ubound ( lhs % nodes_ , 1 )) real , parameter :: tolerance = 1.D-12 associate ( n => lhs % nodes_ ) #ifndef __INTEL_COMPILER do concurrent ( l = 1 : ubound ( n , 1 )) layer_eq ( l ) = all ( abs ( lhs % weights_ ( 1 : n ( l ), 1 : n ( l - 1 ), l ) - rhs % weights_ ( 1 : n ( l ), 1 : n ( l - 1 ), l )) < tolerance ) . and . & all ( abs ( lhs % biases_ ( 1 : n ( l ), l ) - rhs % biases_ ( 1 : n ( l ), l )) < tolerance ) end do #else block integer j , k do l = 1 , ubound ( n , 1 ) do j = 1 , n ( l ) do k = 1 , n ( l - 1 ) layer_eq ( l ) = all ( abs ( lhs % weights_ ( j , k , l ) - rhs % weights_ ( j , k , l )) < tolerance ) . and . & all ( abs ( lhs % biases_ ( j , l ) - rhs % biases_ ( j , l )) < tolerance ) end do end do end do end block #endif end associate lhs_eq_rhs = nodes_eq . and . all ( layer_eq ) end block end procedure module procedure default_real_num_outputs call self % assert_consistency () output_count = self % nodes_ ( ubound ( self % nodes_ , 1 )) end procedure module procedure double_precision_num_outputs call self % assert_consistency () output_count = self % nodes_ ( ubound ( self % nodes_ , 1 )) end procedure module procedure default_real_num_hidden_layers integer , parameter :: num_non_hidden_layers = 2 call self % assert_consistency () associate ( num_layers => size ( self % nodes_ )) hidden_layer_count = num_layers - num_non_hidden_layers end associate end procedure module procedure double_precision_num_hidden_layers integer , parameter :: num_non_hidden_layers = 2 call self % assert_consistency () associate ( num_layers => size ( self % nodes_ )) hidden_layer_count = num_layers - num_non_hidden_layers end associate end procedure module procedure default_real_num_inputs call self % assert_consistency () input_count = self % nodes_ ( lbound ( self % nodes_ , 1 )) end procedure module procedure double_precision_num_inputs call self % assert_consistency () input_count = self % nodes_ ( lbound ( self % nodes_ , 1 )) end procedure module procedure default_real_nodes_per_layer call self % assert_consistency () node_count = self % nodes_ end procedure module procedure double_precision_nodes_per_layer call self % assert_consistency () node_count = self % nodes_ end procedure module procedure default_real_skip associate ( strings => self % metadata_ % strings ()) use_skip_connections = merge (. true ., . false ., strings ( 5 ) == \"true\" ) end associate end procedure module procedure double_precision_skip associate ( strings => self % metadata_ % strings ()) use_skip_connections = merge (. true ., . false ., strings ( 5 ) == \"true\" ) end associate end procedure module procedure default_real_activation_name associate ( strings => self % metadata_ % strings ()) activation_name = strings ( 4 ) end associate end procedure module procedure double_precision_activation_name associate ( strings => self % metadata_ % strings ()) activation_name = strings ( 4 ) end associate end procedure module procedure default_real_learn integer l , batch , mini_batch_size , pair type ( tensor_t ), allocatable :: inputs (:), expected_outputs (:) call self % assert_consistency () call assert ( workspace % fully_allocated (), \"neural_network_s(default_real_learn): workspace%fully_allocated()\" ) associate ( output_layer => ubound ( self % nodes_ , 1 )) associate ( & dcdw => workspace % dcdw , vdw => workspace % vdw , sdw => workspace % sdw , vdwc => workspace % vdwc , sdwc => workspace % sdwc & , dcdb => workspace % dcdb , vdb => workspace % vdb , sdb => workspace % sdb , vdbc => workspace % vdbc , sdbc => workspace % sdbc & , a => workspace % a , z => workspace % z , delta => workspace % delta & ) vdw = 0. ; sdw = 1. ; vdb = 0. ; sdb = 1. associate ( w => self % weights_ , b => self % biases_ , n => self % nodes_ , num_mini_batches => size ( mini_batches_arr )) if ( present ( cost )) allocate ( cost ( num_mini_batches )) iterate_across_batches : & do batch = 1 , num_mini_batches dcdw = 0. ; dcdb = 0. #ifndef _CRAYFTN associate ( input_output_pairs => mini_batches_arr ( batch )% input_output_pairs ()) #else block type ( input_output_pair_t ), allocatable :: input_output_pairs (:) input_output_pairs = mini_batches_arr ( batch )% input_output_pairs () #endif inputs = input_output_pairs % inputs () expected_outputs = input_output_pairs % expected_outputs () mini_batch_size = size ( input_output_pairs ) #ifndef _CRAYFTN end associate #else end block #endif sum_cost : & block real , allocatable :: pair_cost (:) if ( present ( cost )) allocate ( pair_cost ( mini_batch_size )) #if F2023_LOCALITY iterate_through_batch : & do concurrent ( pair = 1 : mini_batch_size ) local ( a , z , delta ) reduce ( + : dcdb , dcdw ) #elif F2018_LOCALITY reduce_gradients : & block real reduce_dcdb ( size ( dcdb , 1 ), size ( dcdb , 2 ), mini_batch_size ) real reduce_dcdw ( size ( dcdw , 1 ), size ( dcdw , 2 ), size ( dcdw , 3 ), mini_batch_size ) reduce_dcdb = 0. reduce_dcdw = 0. iterate_through_batch : & do concurrent ( pair = 1 : mini_batch_size ) local ( a , z , delta ) #else reduce_gradients : & block real reduce_dcdb ( size ( dcdb , 1 ), size ( dcdb , 2 ), mini_batch_size ) real reduce_dcdw ( size ( dcdw , 1 ), size ( dcdw , 2 ), size ( dcdw , 3 ), mini_batch_size ) reduce_dcdb = 0. reduce_dcdw = 0. iterate_through_batch : & do concurrent ( pair = 1 : mini_batch_size ) iteration : & block real a ( maxval ( self % nodes_ ), input_layer : output_layer ) ! Activations real z ( size ( b , 1 ), size ( b , 2 )), delta ( size ( b , 1 ), size ( b , 2 )) #endif a ( 1 : self % num_inputs (), input_layer ) = inputs ( pair )% values () feed_forward : & do l = 1 , output_layer z ( 1 : n ( l ), l ) = matmul ( w ( 1 : n ( l ), 1 : n ( l - 1 ), l ), a ( 1 : n ( l - 1 ), l - 1 )) + b ( 1 : n ( l ), l ) ! z_j&#94;l =  sum_k(w_jk&#94;{l} a_k&#94;{l-1}) + b_j&#94;l a ( 1 : n ( l ), l ) = self % activation_ % evaluate ( z ( 1 : n ( l ), l )) end do feed_forward associate ( y => expected_outputs ( pair )% values ()) if ( present ( cost )) pair_cost ( pair ) = sum (( y ( 1 : n ( output_layer )) - a ( 1 : n ( output_layer ), output_layer )) ** 2 ) delta ( 1 : n ( output_layer ), output_layer ) = ( a ( 1 : n ( output_layer ), output_layer ) - y ( 1 : n ( output_layer ))) & * self % activation_ % differentiate ( z ( 1 : n ( output_layer ), output_layer )) end associate associate ( n_hidden => self % num_hidden_layers ()) back_propagate_error : & do l = n_hidden , 1 , - 1 delta ( 1 : n ( l ), l ) = matmul ( transpose ( w ( 1 : n ( l + 1 ), 1 : n ( l ), l + 1 )), delta ( 1 : n ( l + 1 ), l + 1 )) & * self % activation_ % differentiate ( z ( 1 : n ( l ), l )) end do back_propagate_error end associate block integer j sum_gradients : & do l = 1 , output_layer #if F2023_LOCALITY dcdb ( 1 : n ( l ), l ) = dcdb ( 1 : n ( l ), l ) + delta ( 1 : n ( l ), l ) do concurrent ( j = 1 : n ( l )) reduce ( + : dcdw ) dcdw ( j , 1 : n ( l - 1 ), l ) = dcdw ( j , 1 : n ( l - 1 ), l ) + a ( 1 : n ( l - 1 ), l - 1 ) * delta ( j , l ) end do #else reduce_dcdb ( 1 : n ( l ), l , pair ) = reduce_dcdb ( 1 : n ( l ), l , pair ) + delta ( 1 : n ( l ), l ) do j = 1 , n ( l ) reduce_dcdw ( j , 1 : n ( l - 1 ), l , pair ) = reduce_dcdw ( j , 1 : n ( l - 1 ), l , pair ) + a ( 1 : n ( l - 1 ), l - 1 ) * delta ( j , l ) end do #endif end do sum_gradients end block #if F2023_LOCALITY end do iterate_through_batch #elif F2018_LOCALITY end do iterate_through_batch dcdb = sum ( reduce_dcdb , dim = 3 ) dcdw = sum ( reduce_dcdw , dim = 4 ) end block reduce_gradients #else end block iteration end do iterate_through_batch dcdb = sum ( reduce_dcdb , dim = 3 ) dcdw = sum ( reduce_dcdw , dim = 4 ) end block reduce_gradients #endif if ( present ( cost )) cost ( batch ) = sum ( pair_cost ) / ( 2 * mini_batch_size ) end block sum_cost if ( adam ) then adam : & block ! Adam parameters real , parameter :: beta ( * ) = [. 9 , . 999 ] real , parameter :: obeta ( * ) = [ 1. - beta ( 1 ), 1. - beta ( 2 )] real , parameter :: epsilon = 1.E-08 associate ( alpha => learning_rate ) adam_adjust_weights_and_biases : & do concurrent ( l = 1 : output_layer ) dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / ( mini_batch_size ) vdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = beta ( 1 ) * vdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) + obeta ( 1 ) * dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) sdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = beta ( 2 ) * sdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) + obeta ( 2 ) * ( dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) ** 2 ) vdwc ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = vdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / ( 1. - beta ( 1 ) ** num_mini_batches ) sdwc ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = sdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / ( 1. - beta ( 2 ) ** num_mini_batches ) w ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = w ( 1 : n ( l ), 1 : n ( l - 1 ), l ) & - alpha * vdwc ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / ( sqrt ( sdwc ( 1 : n ( l ), 1 : n ( l - 1 ), l )) + epsilon ) ! Adjust weights dcdb ( 1 : n ( l ), l ) = dcdb ( 1 : n ( l ), l ) / mini_batch_size vdb ( 1 : n ( l ), l ) = beta ( 1 ) * vdb ( 1 : n ( l ), l ) + obeta ( 1 ) * dcdb ( 1 : n ( l ), l ) sdb ( 1 : n ( l ), l ) = beta ( 2 ) * sdb ( 1 : n ( l ), l ) + obeta ( 2 ) * ( dcdb ( 1 : n ( l ), l ) ** 2 ) vdbc ( 1 : n ( l ), l ) = vdb ( 1 : n ( l ), l ) / ( 1. - beta ( 1 ) ** num_mini_batches ) sdbc ( 1 : n ( l ), l ) = sdb ( 1 : n ( l ), l ) / ( 1. - beta ( 2 ) ** num_mini_batches ) b ( 1 : n ( l ), l ) = b ( 1 : n ( l ), l ) - alpha * vdbc ( 1 : n ( l ), l ) / ( sqrt ( sdbc ( 1 : n ( l ), l )) + epsilon ) ! Adjust weights end do adam_adjust_weights_and_biases end associate end block adam else associate ( eta => learning_rate ) adjust_weights_and_biases : & do concurrent ( l = 1 : output_layer ) dcdb ( 1 : n ( l ), l ) = dcdb ( 1 : n ( l ), l ) / mini_batch_size b ( 1 : n ( l ), l ) = b ( 1 : n ( l ), l ) - eta * dcdb ( 1 : n ( l ), l ) ! Adjust biases dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / mini_batch_size w ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = w ( 1 : n ( l ), 1 : n ( l - 1 ), l ) - eta * dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) ! Adjust weights end do adjust_weights_and_biases end associate end if end do iterate_across_batches end associate end associate end associate end procedure default_real_learn end submodule neural_network_s","tags":"","loc":"sourcefile/neural_network_s.f90.html"},{"title":"double_precision_string_m.f90 – Fiats","text":"Files dependent on this one sourcefile~~double_precision_string_m.f90~~AfferentGraph sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~double_precision_string_s.f90 double_precision_string_s.f90 sourcefile~double_precision_string_s.f90->sourcefile~double_precision_string_m.f90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~fiats_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~fiats_m.f90->sourcefile~metadata_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~network_configuration_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_map_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~training_configuration_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~layer_m.f90->sourcefile~metadata_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~layer_m.f90->sourcefile~tensor_map_m.f90 sourcefile~layer_m.f90->sourcefile~neural_network_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~network_configuration_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~neural_network_s.f90 neural_network_s.F90 sourcefile~neural_network_s.f90->sourcefile~double_precision_string_m.f90 sourcefile~neural_network_s.f90->sourcefile~layer_m.f90 sourcefile~neural_network_s.f90->sourcefile~neuron_m.f90 sourcefile~neural_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~neuron_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~double_precision_string_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~fiats_m.f90 sourcefile~double_precision_file_s.f90 double_precision_file_s.f90 sourcefile~double_precision_file_s.f90->sourcefile~double_precision_file_m.f90 sourcefile~hyperparameters_s.f90 hyperparameters_s.f90 sourcefile~hyperparameters_s.f90->sourcefile~hyperparameters_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~fiats_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~fiats_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~fiats_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~fiats_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~metadata_s.f90 metadata_s.f90 sourcefile~metadata_s.f90->sourcefile~metadata_m.f90 sourcefile~network_configuration_s.f90 network_configuration_s.F90 sourcefile~network_configuration_s.f90->sourcefile~network_configuration_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~fiats_m.f90 sourcefile~read-query-infer.f90 read-query-infer.f90 sourcefile~read-query-infer.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~fiats_m.f90 sourcefile~tensor_map_s.f90 tensor_map_s.f90 sourcefile~tensor_map_s.f90->sourcefile~tensor_map_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~fiats_m.f90 sourcefile~trainable_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~fiats_m.f90 sourcefile~trainable_network_s.f90 trainable_network_s.f90 sourcefile~trainable_network_s.f90->sourcefile~trainable_network_m.f90 sourcefile~unmapped_network_s.f90 unmapped_network_s.f90 sourcefile~unmapped_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~workspace_s.f90 workspace_s.f90 sourcefile~workspace_s.f90->sourcefile~neural_network_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module double_precision_string_m use julienne_m , only : string_t implicit none type , extends ( string_t ) :: double_precision_string_t end type interface double_precision_string_t elemental module function construct_from_string ( string ) result ( double_precision_string ) implicit none type ( string_t ), intent ( in ) :: string type ( double_precision_string_t ) double_precision_string end function end interface end module double_precision_string_m","tags":"","loc":"sourcefile/double_precision_string_m.f90.html"},{"title":"learn-addition.F90 – Fiats","text":"This file depends on sourcefile~~learn-addition.f90~~EfferentGraph sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~learn-addition.f90->sourcefile~fiats_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~fiats_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~fiats_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~fiats_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~fiats_m.f90->sourcefile~metadata_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~fiats_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~network_configuration_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~fiats_m.f90->sourcefile~ubounds_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_network_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~activation_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module addition_m !! Define a function that produces the desired network output for a given network input use fiats_m , only : tensor_t use assert_m , only : assert implicit none contains elemental function y ( x_tensor ) result ( a_tensor ) type ( tensor_t ), intent ( in ) :: x_tensor type ( tensor_t ) a_tensor associate ( x => x_tensor % values ()) call assert ( ubound ( x , 1 ) >= 7 . and . lbound ( x , 1 ) <= 2 , \"y(x) :: sufficient input\" ) a_tensor = tensor_t ([ x ( 1 ) + x ( 2 ), x ( 2 ) + x ( 3 ), x ( 3 ) + x ( 4 ), x ( 4 ) + x ( 5 ), x ( 5 ) + x ( 6 ), x ( 6 ) + x ( 8 )]) end associate end function end module program learn_addition !! This trains a neural network to learn the following six polynomial functions of its eight inputs. use fiats_m , only : & neural_network_t , trainable_network_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle use julienne_m , only : string_t , file_t , command_line_t , bin_t use assert_m , only : assert , intrinsic_array_t use addition_m , only : y implicit none type ( string_t ) final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example learn-addition --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 10 , num_epochs = 200000 , num_mini_batches = 2 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_network_t ) trainable_network type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) call random_init ( image_distinct = . true ., repeatable = . true .) trainable_network = perturbed_identity_network ( perturbation_magnitude = 0.05 ) call output ( trainable_network , string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_network % num_inputs (), num_outputs => trainable_network % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) inputs = [( tensor_t ( real ([( j * i , j = 1 , num_inputs )]) / ( num_inputs * num_pairs )), i = 1 , num_pairs )] desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_network % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block integer p #if defined _CRAYFTN || __GFORTRAN__ type ( tensor_t ), allocatable :: network_outputs (:) network_outputs = trainable_network % infer ( inputs ) #else associate ( network_outputs => trainable_network % infer ( inputs )) #endif print \"(a,69x,a)\" , \"  Outputs\" , \"| Desired outputs\" do p = 1 , num_pairs print \"(6G13.5, a1, 6G13.5)\" , network_outputs ( p )% values (), \"|\" , desired_outputs ( p )% values () end do #if defined _CRAYFTN || __GFORTRAN__ #else end associate #endif end block end associate call output ( trainable_network , final_network_file ) end block contains subroutine output ( neural_network , file_name ) class ( neural_network_t ), intent ( in ) :: neural_network type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = neural_network % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_network ) type ( trainable_network_t ) trainable_network real , intent ( in ) :: perturbation_magnitude integer , parameter :: n ( * ) = [ 8 , 64 , 64 , 64 , 6 ] integer , parameter :: n_max = maxval ( n ), layers = size ( n ) integer k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_network = trainable_network_t ( neural_network_t ( & nodes = n , weights = w , biases = b , metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & )) end associate end function end program","tags":"","loc":"sourcefile/learn-addition.f90.html"},{"title":"input_output_pair_m.f90 – Fiats","text":"This file depends on sourcefile~~input_output_pair_m.f90~~EfferentGraph sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~input_output_pair_m.f90~~AfferentGraph sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~fiats_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~fiats_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_network_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~fiats_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~fiats_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~fiats_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~fiats_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~fiats_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~fiats_m.f90 sourcefile~read-query-infer.f90 read-query-infer.f90 sourcefile~read-query-infer.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~fiats_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~fiats_m.f90 sourcefile~trainable_network_s.f90 trainable_network_s.f90 sourcefile~trainable_network_s.f90->sourcefile~trainable_network_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~fiats_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~neural_network_m.f90 sourcefile~neural_network_s.f90 neural_network_s.F90 sourcefile~neural_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~neural_network_s.f90->sourcefile~layer_m.f90 sourcefile~unmapped_network_s.f90 unmapped_network_s.f90 sourcefile~unmapped_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~workspace_s.f90 workspace_s.f90 sourcefile~workspace_s.f90->sourcefile~neural_network_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module input_output_pair_m use tensor_m , only : tensor_t use kind_parameters_m , only : default_real , double_precision implicit none private public :: input_output_pair_t public :: shuffle public :: write_to_stdout type input_output_pair_t ( k ) integer , kind :: k = default_real type ( tensor_t ( k )), private :: inputs_ , expected_outputs_ contains generic :: inputs => default_real_inputs , double_precision_inputs procedure , private , non_overridable :: default_real_inputs , double_precision_inputs generic :: expected_outputs => default_real_expected_outputs , double_precision_expected_outputs procedure , private , non_overridable :: default_real_expected_outputs , double_precision_expected_outputs end type interface input_output_pair_t elemental module function default_real_construct ( inputs , expected_outputs ) result ( input_output_pair ) implicit none type ( tensor_t ), intent ( in ) :: inputs , expected_outputs type ( input_output_pair_t ) input_output_pair end function elemental module function double_precision_construct ( inputs , expected_outputs ) result ( input_output_pair ) implicit none type ( tensor_t ( double_precision )), intent ( in ) :: inputs , expected_outputs type ( input_output_pair_t ( double_precision )) input_output_pair end function end interface interface elemental module function default_real_inputs ( self ) result ( my_inputs ) implicit none class ( input_output_pair_t ), intent ( in ) :: self type ( tensor_t ) :: my_inputs end function elemental module function double_precision_inputs ( self ) result ( my_inputs ) implicit none class ( input_output_pair_t ( double_precision )), intent ( in ) :: self type ( tensor_t ( double_precision )) :: my_inputs end function elemental module function default_real_expected_outputs ( self ) result ( my_expected_outputs ) implicit none class ( input_output_pair_t ), intent ( in ) :: self type ( tensor_t ) :: my_expected_outputs end function elemental module function double_precision_expected_outputs ( self ) result ( my_expected_outputs ) implicit none class ( input_output_pair_t ( double_precision )), intent ( in ) :: self type ( tensor_t ( double_precision )) :: my_expected_outputs end function end interface interface shuffle module subroutine default_real_shuffle ( pairs ) implicit none type ( input_output_pair_t ), intent ( inout ) :: pairs (:) end subroutine module subroutine double_precision_shuffle ( pairs ) implicit none type ( input_output_pair_t ( double_precision )), intent ( inout ) :: pairs (:) end subroutine end interface interface write_to_stdout module subroutine default_real_write_to_stdout ( input_output_pairs ) implicit none type ( input_output_pair_t ), intent ( in ) :: input_output_pairs (:) end subroutine module subroutine double_precision_write_to_stdout ( input_output_pairs ) implicit none type ( input_output_pair_t ( double_precision )), intent ( in ) :: input_output_pairs (:) end subroutine end interface end module input_output_pair_m","tags":"","loc":"sourcefile/input_output_pair_m.f90.html"},{"title":"double_precision_file_m.f90 – Fiats","text":"This file depends on sourcefile~~double_precision_file_m.f90~~EfferentGraph sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~double_precision_file_m.f90~~AfferentGraph sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~double_precision_file_s.f90 double_precision_file_s.f90 sourcefile~double_precision_file_s.f90->sourcefile~double_precision_file_m.f90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~training_configuration_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~training_configuration_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~fiats_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~neural_network_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~fiats_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~fiats_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~fiats_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~fiats_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~neural_network_s.f90 neural_network_s.F90 sourcefile~neural_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~neural_network_s.f90->sourcefile~layer_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~fiats_m.f90 sourcefile~read-query-infer.f90 read-query-infer.f90 sourcefile~read-query-infer.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~fiats_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~fiats_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~unmapped_network_s.f90 unmapped_network_s.f90 sourcefile~unmapped_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~workspace_s.f90 workspace_s.f90 sourcefile~workspace_s.f90->sourcefile~neural_network_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~fiats_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~trainable_network_s.f90 trainable_network_s.f90 sourcefile~trainable_network_s.f90->sourcefile~trainable_network_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module double_precision_file_m use julienne_m , only : file_t , string_t use double_precision_string_m , only : double_precision_string_t implicit none type , extends ( file_t ) :: double_precision_file_t contains procedure double_precision_lines end type interface double_precision_file_t impure elemental module function construct_from_string ( file_name ) result ( double_precision_file ) implicit none type ( string_t ), intent ( in ) :: file_name type ( double_precision_file_t ) double_precision_file end function impure elemental module function construct_from_character ( file_name ) result ( double_precision_file ) implicit none character ( len =* ), intent ( in ) :: file_name type ( double_precision_file_t ) double_precision_file end function end interface interface pure module function double_precision_lines ( self ) result ( lines ) implicit none class ( double_precision_file_t ), intent ( in ) :: self type ( double_precision_string_t ), allocatable :: lines (:) end function end interface end module double_precision_file_m","tags":"","loc":"sourcefile/double_precision_file_m.f90.html"},{"title":"learn-power-series.F90 – Fiats","text":"This file depends on sourcefile~~learn-power-series.f90~~EfferentGraph sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~learn-power-series.f90->sourcefile~fiats_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~fiats_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~fiats_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~fiats_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~fiats_m.f90->sourcefile~metadata_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~fiats_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~network_configuration_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~fiats_m.f90->sourcefile~ubounds_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_network_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~activation_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module power_series !! Define a function that produces the desired network output for a given network input use fiats_m , only : tensor_t use assert_m , only : assert implicit none contains elemental function y ( x_in ) result ( a ) type ( tensor_t ), intent ( in ) :: x_in type ( tensor_t ) a associate ( x => x_in % values ()) call assert ( ubound ( x , 1 ) >= 7 . and . lbound ( x , 1 ) <= 2 , \"y(x) :: sufficient input\" ) a = tensor_t ([ 1 + x ( 1 ) + ( x ( 1 ) ** 2 ) / 2 + ( x ( 1 ) ** 3 ) / 6 , x ( 2 ), x ( 3 ), x ( 4 ), x ( 5 ), x ( 6 )]) end associate end function end module program learn_power_series !! This trains a neural network to learn the following six polynomial functions of its eight inputs. use fiats_m , only : neural_network_t , trainable_network_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle use julienne_m , only : string_t , file_t , command_line_t , bin_t use assert_m , only : assert , intrinsic_array_t use power_series , only : y implicit none type ( string_t ) final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example learn-power-series --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 10 , num_epochs = 10000 , num_mini_batches = 2 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_network_t ) trainable_network type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) call random_init ( image_distinct = . true ., repeatable = . true .) trainable_network = perturbed_identity_network ( perturbation_magnitude = 0.05 ) call output ( trainable_network , string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_network % num_inputs (), num_outputs => trainable_network % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) real white_noise ( 1 : num_inputs , 1 : num_pairs ) call random_number ( white_noise ) inputs = [( tensor_t ( real ([( white_noise ( j , i ), j = 1 , num_inputs )])), i = 1 , num_pairs )] desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_network % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block integer p #if defined _CRAYFTN || __GFORTRAN__ type ( tensor_t ), allocatable :: network_outputs (:) network_outputs = trainable_network % infer ( inputs ) #else associate ( network_outputs => trainable_network % infer ( inputs )) #endif print \"(a,69x,a)\" , \"  Outputs\" , \"| Desired outputs\" do p = 1 , num_pairs print \"(6G13.5, a1, 6G13.5)\" , network_outputs ( p )% values (), \"|\" , desired_outputs ( p )% values () end do #if defined _CRAYFTN || __GFORTRAN__ #else end associate #endif end block end associate call output ( trainable_network , final_network_file ) end block contains subroutine output ( neural_network , file_name ) class ( neural_network_t ), intent ( in ) :: neural_network type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = neural_network % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_network ) type ( trainable_network_t ) trainable_network real , intent ( in ) :: perturbation_magnitude integer , parameter :: n ( * ) = [ 8 , 196 , 196 , 196 , 196 , 6 ] integer , parameter :: n_max = maxval ( n ), layers = size ( n ) integer k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_network = trainable_network_t ( neural_network_t ( & nodes = n , weights = w , biases = b , metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & )) end associate end function end program","tags":"","loc":"sourcefile/learn-power-series.f90.html"},{"title":"ubounds_m.f90 – Fiats","text":"Files dependent on this one sourcefile~~ubounds_m.f90~~AfferentGraph sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~fiats_m.f90->sourcefile~ubounds_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~fiats_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~fiats_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~fiats_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~fiats_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~fiats_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~fiats_m.f90 sourcefile~read-query-infer.f90 read-query-infer.f90 sourcefile~read-query-infer.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~fiats_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~fiats_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~fiats_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module ubounds_m !! This module serves only to support array bounds checking in the main program below implicit none type ubounds_t integer , allocatable :: ubounds_ (:) contains procedure equals generic :: operator ( == ) => equals end type contains elemental function equals ( lhs , rhs ) result ( lhs_equals_rhs ) class ( ubounds_t ), intent ( in ) :: lhs , rhs logical lhs_equals_rhs lhs_equals_rhs = all ( lhs % ubounds_ == rhs % ubounds_ ) end function end module","tags":"","loc":"sourcefile/ubounds_m.f90.html"},{"title":"kind_parameters_m.f90 – Fiats","text":"Files dependent on this one sourcefile~~kind_parameters_m.f90~~AfferentGraph sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~fiats_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~fiats_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~fiats_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~fiats_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~training_configuration_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~neural_network_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~layer_m.f90->sourcefile~tensor_map_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~neural_network_s.f90 neural_network_s.F90 sourcefile~neural_network_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~neural_network_s.f90->sourcefile~layer_m.f90 sourcefile~neural_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~neural_network_s.f90->sourcefile~neuron_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_s.f90 tensor_map_s.f90 sourcefile~tensor_map_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_s.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_network_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~fiats_m.f90 sourcefile~hyperparameters_s.f90 hyperparameters_s.f90 sourcefile~hyperparameters_s.f90->sourcefile~hyperparameters_m.f90 sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~fiats_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~fiats_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~fiats_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~fiats_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~fiats_m.f90 sourcefile~read-query-infer.f90 read-query-infer.f90 sourcefile~read-query-infer.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~fiats_m.f90 sourcefile~tensor_s.f90 tensor_s.f90 sourcefile~tensor_s.f90->sourcefile~tensor_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~fiats_m.f90 sourcefile~trainable_network_s.f90 trainable_network_s.f90 sourcefile~trainable_network_s.f90->sourcefile~trainable_network_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~unmapped_network_s.f90 unmapped_network_s.f90 sourcefile~unmapped_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~workspace_s.f90 workspace_s.f90 sourcefile~workspace_s.f90->sourcefile~neural_network_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~fiats_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module kind_parameters_m implicit none private public :: default_real public :: double_precision integer , parameter :: default_real = kind ( 1. ) integer , parameter :: double_precision = kind ( 1 D0 ) end module kind_parameters_m","tags":"","loc":"sourcefile/kind_parameters_m.f90.html"},{"title":"hyperparameters_m.f90 – Fiats","text":"This file depends on sourcefile~~hyperparameters_m.f90~~EfferentGraph sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~hyperparameters_m.f90~~AfferentGraph sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~fiats_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~training_configuration_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~hyperparameters_s.f90 hyperparameters_s.f90 sourcefile~hyperparameters_s.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~fiats_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~fiats_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~fiats_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~fiats_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~fiats_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~fiats_m.f90 sourcefile~read-query-infer.f90 read-query-infer.f90 sourcefile~read-query-infer.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~fiats_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~fiats_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~fiats_m.f90 sourcefile~trainable_network_s.f90 trainable_network_s.f90 sourcefile~trainable_network_s.f90->sourcefile~trainable_network_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module hyperparameters_m use julienne_string_m , only : string_t use kind_parameters_m , only : default_real , double_precision use double_precision_string_m , only : double_precision_string_t implicit none private public :: hyperparameters_t type hyperparameters_t ( k ) integer , kind :: k = default_real integer , private :: mini_batches_ = 10 real ( k ), private :: learning_rate_ = real ( 1.5 , k ) character ( len = :), allocatable :: optimizer_ contains generic :: to_json => default_real_to_json , double_precision_to_json procedure , private :: default_real_to_json , double_precision_to_json generic :: operator ( == ) => default_real_equals , double_precision_equals procedure , private :: default_real_equals , double_precision_equals generic :: mini_batches => default_real_mini_batches , double_precision_mini_batches procedure , private :: default_real_mini_batches , double_precision_mini_batches generic :: optimizer_name => default_real_optimizer_name , double_precision_optimizer_name procedure , private :: default_real_optimizer_name , double_precision_optimizer_name generic :: learning_rate => default_real_learning_rate , double_precision_learning_rate procedure , private :: default_real_learning_rate , double_precision_learning_rate end type interface hyperparameters_t pure module function default_real_from_json ( lines ) result ( hyperparameters ) implicit none type ( string_t ), intent ( in ) :: lines (:) type ( hyperparameters_t ) hyperparameters end function pure module function double_precision_from_json ( lines ) result ( hyperparameters ) implicit none type ( double_precision_string_t ), intent ( in ) :: lines (:) type ( hyperparameters_t ( double_precision )) hyperparameters end function pure module function default_real_from_components ( mini_batches , learning_rate , optimizer ) result ( hyperparameters ) implicit none integer , intent ( in ) :: mini_batches real , intent ( in ) :: learning_rate character ( len =* ), intent ( in ) :: optimizer type ( hyperparameters_t ) hyperparameters end function pure module function double_precision_from_components ( mini_batches , learning_rate , optimizer ) result ( hyperparameters ) implicit none integer , intent ( in ) :: mini_batches double precision , intent ( in ) :: learning_rate character ( len =* ), intent ( in ) :: optimizer type ( hyperparameters_t ( double_precision )) hyperparameters end function end interface interface pure module function default_real_to_json ( self ) result ( lines ) implicit none class ( hyperparameters_t ), intent ( in ) :: self type ( string_t ), allocatable :: lines (:) end function pure module function double_precision_to_json ( self ) result ( lines ) implicit none class ( hyperparameters_t ( double_precision )), intent ( in ) :: self type ( string_t ), allocatable :: lines (:) end function elemental module function default_real_equals ( lhs , rhs ) result ( lhs_equals_rhs ) implicit none class ( hyperparameters_t ), intent ( in ) :: lhs , rhs logical lhs_equals_rhs end function elemental module function double_precision_equals ( lhs , rhs ) result ( lhs_equals_rhs ) implicit none class ( hyperparameters_t ( double_precision )), intent ( in ) :: lhs , rhs logical lhs_equals_rhs end function elemental module function default_real_mini_batches ( self ) result ( num_mini_batches ) implicit none class ( hyperparameters_t ), intent ( in ) :: self integer num_mini_batches end function elemental module function double_precision_mini_batches ( self ) result ( num_mini_batches ) implicit none class ( hyperparameters_t ( double_precision )), intent ( in ) :: self integer num_mini_batches end function elemental module function default_real_learning_rate ( self ) result ( rate ) implicit none class ( hyperparameters_t ), intent ( in ) :: self real rate end function elemental module function double_precision_learning_rate ( self ) result ( rate ) implicit none class ( hyperparameters_t ( double_precision )), intent ( in ) :: self double precision rate end function elemental module function default_real_optimizer_name ( self ) result ( identifier ) implicit none class ( hyperparameters_t ), intent ( in ) :: self type ( string_t ) identifier end function elemental module function double_precision_optimizer_name ( self ) result ( identifier ) implicit none class ( hyperparameters_t ( double_precision )), intent ( in ) :: self type ( string_t ) identifier end function end interface end module","tags":"","loc":"sourcefile/hyperparameters_m.f90.html"},{"title":"double_precision_string_s.f90 – Fiats","text":"This file depends on sourcefile~~double_precision_string_s.f90~~EfferentGraph sourcefile~double_precision_string_s.f90 double_precision_string_s.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~double_precision_string_s.f90->sourcefile~double_precision_string_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( double_precision_string_m ) double_precision_string_s implicit none contains module procedure construct_from_string double_precision_string % string_t = string end procedure end submodule double_precision_string_s","tags":"","loc":"sourcefile/double_precision_string_s.f90.html"},{"title":"double_precision_file_s.f90 – Fiats","text":"This file depends on sourcefile~~double_precision_file_s.f90~~EfferentGraph sourcefile~double_precision_file_s.f90 double_precision_file_s.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~double_precision_file_s.f90->sourcefile~double_precision_file_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( double_precision_file_m ) double_precision_file_s implicit none contains module procedure construct_from_string double_precision_file % file_t = file_t ( file_name ) end procedure module procedure construct_from_character double_precision_file % file_t = file_t ( file_name ) end procedure module procedure double_precision_lines lines = double_precision_string_t ( self % file_t % lines ()) end procedure end submodule double_precision_file_s","tags":"","loc":"sourcefile/double_precision_file_s.f90.html"},{"title":"learn-saturated-mixing-ratio.F90 – Fiats","text":"This file depends on sourcefile~~learn-saturated-mixing-ratio.f90~~EfferentGraph sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~fiats_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~fiats_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~fiats_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~fiats_m.f90->sourcefile~metadata_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~fiats_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~network_configuration_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~fiats_m.f90->sourcefile~ubounds_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~fiats_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_network_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~activation_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program train_saturated_mixture_ratio !! This program trains a neural network to learn the saturated mixing ratio function of ICAR. use fiats_m , only : neural_network_t , trainable_network_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle use julienne_m , only : string_t , file_t , command_line_t , bin_t , csv use assert_m , only : assert , intrinsic_array_t use saturated_mixing_ratio_m , only : y , T , p use iso_fortran_env , only : int64 , output_unit implicit none type ( string_t ) network_file type ( command_line_t ) command_line integer ( int64 ) counter_start , counter_end , clock_rate network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example learn-saturated-mixing-ratio --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if call system_clock ( counter_start , clock_rate ) block integer , parameter :: max_num_epochs = 10000000 , num_mini_batches = 7 integer num_pairs ! number of input/output pairs type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_network_t ) trainable_network type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) integer io_status , network_unit , plot_unit integer , parameter :: io_success = 0 , diagnostics_print_interval = 1000 , network_save_interval = 10000 integer , parameter :: nodes_per_layer ( * ) = [ 2 , 4 , 72 , 2 , 1 ] real , parameter :: cost_tolerance = 1.E-08 call random_init ( image_distinct = . true ., repeatable = . true .) open ( newunit = network_unit , file = network_file % string (), form = 'formatted' , status = 'old' , iostat = io_status , action = 'read' ) if ( io_status == io_success ) then print * , \"Reading network from file \" // network_file % string () trainable_network = trainable_network_t ( neural_network_t ( file_t ( network_file ))) close ( network_unit ) else close ( network_unit ) print * , \"Initializing a new network\" trainable_network = perturbed_identity_network ( perturbation_magnitude = 0.05 , n = nodes_per_layer ) end if call output ( trainable_network , string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_network % num_inputs (), num_outputs => trainable_network % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) inputs = [( [( tensor_t ([ T ( i ), p ( j )]), j = 1 , size ( p ))], i = 1 , size ( T ))] num_pairs = size ( inputs ) call assert ( num_pairs == size ( T ) * size ( p ), \"train_cloud_microphysics: inputs tensor array complete\" ) desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block block integer e , b , stop_unit , previous_epoch real previous_clock_time call open_plot_file_for_appending ( \"cost.plt\" , plot_unit , previous_epoch , previous_clock_time ) print * , \"        Epoch | Cost Function| System_Clock | Nodes per Layer\" allocate ( random_numbers ( 2 : size ( input_output_pairs ))) do e = previous_epoch + 1 , previous_epoch + max_num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_network % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) call system_clock ( counter_end , clock_rate ) associate ( & cost_avg => sum ( cost ) / size ( cost ), & cumulative_clock_time => previous_clock_time + real ( counter_end - counter_start ) / real ( clock_rate ), & loop_ending => e == previous_epoch + max_num_epochs & ) write_and_exit_if_converged : & if ( cost_avg < cost_tolerance ) then call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) call output ( trainable_network , network_file ) exit end if write_and_exit_if_converged open ( newunit = stop_unit , file = \"stop\" , form = 'formatted' , status = 'old' , iostat = io_status ) write_and_exit_if_stop_file_exists : & if ( io_status == 0 ) then call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) call output ( trainable_network , network_file ) exit end if write_and_exit_if_stop_file_exists if ( mod ( e , diagnostics_print_interval ) == 0 . or . loop_ending ) & call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) if ( mod ( e , network_save_interval ) == 0 . or . loop_ending ) call output ( trainable_network , network_file ) end associate end do close ( plot_unit ) report_network_performance : & block integer p #if defined _CRAYFTN || __GFORTRAN__ type ( tensor_t ), allocatable :: network_outputs (:) network_outputs = trainable_network % infer ( inputs ) #else associate ( network_outputs => trainable_network % infer ( inputs )) #endif print * , \"Inputs (normalized)          | Outputs      | Desired outputs\" do p = 1 , num_pairs print \"(4(G13.5,2x))\" , inputs ( p )% values (), network_outputs ( p )% values (), desired_outputs ( p )% values () end do #if defined _CRAYFTN || __GFORTRAN__ #else end associate #endif end block report_network_performance end block end associate call output ( trainable_network , network_file ) end block contains subroutine print_diagnostics ( plot_file_unit , epoch , cost , clock , nodes ) integer , intent ( in ) :: plot_file_unit , epoch , nodes (:) real , intent ( in ) :: cost , clock write ( unit = output_unit , fmt = '(3(g13.5,2x))' , advance = 'no' ) epoch , cost , clock write ( unit = output_unit , fmt = csv ) nodes write ( unit = plot_file_unit , fmt = '(3(g13.5,2x))' , advance = 'no' ) epoch , cost , clock write ( unit = plot_file_unit , fmt = csv ) nodes end subroutine subroutine output ( neural_network , file_name ) class ( neural_network_t ), intent ( in ) :: neural_network type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = neural_network % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude , n ) result ( trainable_network ) type ( trainable_network_t ) trainable_network real , intent ( in ) :: perturbation_magnitude integer , intent ( in ) :: n (:) integer k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) associate ( n_max => maxval ( n ), layers => size ( n )) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_network = trainable_network_t ( neural_network_t ( nodes = n , weights = w , biases = b , & metadata = [ string_t ( \"Saturated Mixing Ratio\" ), string_t ( \"Rouson\" ), string_t ( \"20241013\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & )) end associate end associate end function subroutine open_plot_file_for_appending ( plot_file_name , plot_unit , previous_epoch , previous_clock ) character ( len =* ), intent ( in ) :: plot_file_name integer , intent ( out ) :: plot_unit , previous_epoch real , intent ( out ) :: previous_clock type ( file_t ) plot_file type ( string_t ), allocatable :: lines (:) character ( len = :), allocatable :: last_line integer io_status integer , parameter :: io_success = 0 logical preexisting_plot_file real cost inquire ( file = plot_file_name , exist = preexisting_plot_file ) open ( newunit = plot_unit , file = \"cost.plt\" , status = \"unknown\" , position = \"append\" ) associate ( header => \"        Epoch | Cost Function| System_Clock | Nodes per Layer\" ) if (. not . preexisting_plot_file ) then write ( plot_unit , * ) header previous_epoch = 0 previous_clock = 0 else plot_file = file_t ( string_t ( plot_file_name )) lines = plot_file % lines () last_line = lines ( size ( lines ))% string () read ( last_line , * , iostat = io_status ) previous_epoch , cost , previous_clock associate ( eliminate_unreferenced_variable_warning => cost ) end associate if (( io_status /= io_success . and . last_line == header ) . or . len ( trim ( last_line )) == 0 ) then previous_epoch = 0 previous_clock = 0 end if end if end associate end subroutine end program","tags":"","loc":"sourcefile/learn-saturated-mixing-ratio.f90.html"},{"title":"trainable_network_s.f90 – Fiats","text":"This file depends on sourcefile~~trainable_network_s.f90~~EfferentGraph sourcefile~trainable_network_s.f90 trainable_network_s.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~trainable_network_s.f90->sourcefile~trainable_network_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~trainable_network_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~trainable_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~trainable_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~trainable_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~activation_m.f90 sourcefile~training_configuration_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~network_configuration_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( trainable_network_m ) trainable_network_s implicit none contains module procedure default_real_network trainable_network % neural_network_t = neural_network trainable_network % workspace_ = workspace_t ( neural_network ) end procedure module procedure default_real_train call self % learn ( mini_batches_arr , cost , adam , learning_rate , self % workspace_ ) end procedure module procedure default_real_map_to_training_ranges associate ( inputs => input_output_pair % inputs (), expected_outputs => input_output_pair % expected_outputs ()) associate ( & normalized_inputs => self % input_map_ % map_to_training_range ( inputs ), & normalized_outputs => self % output_map_ % map_to_training_range ( expected_outputs ) & ) normalized_input_output_pair = input_output_pair_t ( normalized_inputs , normalized_outputs ) end associate end associate end procedure module procedure perturbed_identity_network integer k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) associate ( n => training_configuration % nodes_per_layer ()) associate ( n_max => maxval ( n ), layers => size ( n )) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( & w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , & b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 & ) trainable_network = trainable_network_t ( & neural_network_t ( nodes = n , weights = w , biases = b , metadata = metadata , input_map = input_map , output_map = output_map ) & ) end associate end associate end associate contains pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function end procedure end submodule trainable_network_s","tags":"","loc":"sourcefile/trainable_network_s.f90.html"},{"title":"read-query-infer.f90 – Fiats","text":"This file depends on sourcefile~~read-query-infer.f90~~EfferentGraph sourcefile~read-query-infer.f90 read-query-infer.f90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~read-query-infer.f90->sourcefile~fiats_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~fiats_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~fiats_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~fiats_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~fiats_m.f90->sourcefile~metadata_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~fiats_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~network_configuration_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~fiats_m.f90->sourcefile~ubounds_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_network_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~activation_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program read_query_infer !! This program demonstrates how to read a neural network from a JSON file, !! query the network object for some of its properties, print those properties, !! and use the network to perform inference. use fiats_m , only : neural_network_t , tensor_t use julienne_m , only : string_t , command_line_t , file_t implicit none type ( command_line_t ) command_line associate ( file_name => string_t ( command_line % flag_value ( \"--input-file\" ))) if ( len ( file_name % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example read-query -- --input-file \"<file-name>\"' end if print * , \"Reading an neural_network_t object from the same JSON file '\" // file_name % string () // \"'.\" associate ( neural_network => neural_network_t ( file_t ( file_name ))) print * , \"Querying the new neural_network_t object for several properties:\" associate ( activation_name => neural_network % activation_function_name ()) print * , \"Activation function: \" , activation_name % string () end associate print * , \"Number of outputs:\" , neural_network % num_outputs () print * , \"Number of inputs:\" , neural_network % num_inputs () print * , \"Nodes per layer:\" , neural_network % nodes_per_layer () print * , \"Performing inference:\" block integer , parameter :: tensor_size = 2 , num_tests = 3 , tensor_min = 1. , tensor_max = 4.0 real harvest ( tensor_size ) integer i call random_init ( repeatable = . false ., image_distinct = . true .) print * , \"Inputs                 |       Outputs  \" do i = 1 , num_tests call random_number ( harvest ) associate ( inputs => tensor_t ( tensor_min + ( tensor_max - tensor_min ) * harvest )) associate ( outputs => neural_network % infer ( inputs )) print '(2(2g12.5,a,2x))' , inputs % values (), \"|\" , outputs % values () end associate end associate end do end block end associate ! associate(neural_network => ...) end associate ! associate(file_name => ...) end program","tags":"","loc":"sourcefile/read-query-infer.f90.html"},{"title":"saturated_mixing_ratio_m.f90 – Fiats","text":"This file depends on sourcefile~~saturated_mixing_ratio_m.f90~~EfferentGraph sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~fiats_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~fiats_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~fiats_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~fiats_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~fiats_m.f90->sourcefile~metadata_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~fiats_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~network_configuration_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~fiats_m.f90->sourcefile~ubounds_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_network_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~activation_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~saturated_mixing_ratio_m.f90~~AfferentGraph sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt ! ! MIT License ! ! Copyright (c) 2017 National Center for Atmospheric Research ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. module saturated_mixing_ratio_m !! This module supports the program in the file example/learn-saturated-mixing-ratio.f90. !! The saturated_mixing_ratio function in this module resulted from refactoring the sat_mr function !! in the Intermediate Complexity Atmospheric Research (ICAR) model file src/physics/mp_simple.f90. !! ICAR is distributed under the above MIT license.  See https://github.com/ncar/icar. use fiats_m , only : tensor_t use assert_m , only : assert implicit none private public :: T , p , y real , parameter :: freezing_threshold = 27 3.15 ! [K] real , parameter :: T_min = 23 6.352524 , T_max = 30 7.610779 real , parameter :: p_min = 2967 1.1348 , p_max = 9859 6.7578 integer , parameter :: resolution = 20 integer i real , parameter :: T ( * ) = [( real ( i ) / real ( resolution ), i = 0 , resolution )] real , parameter :: p ( * ) = [( real ( i ) / real ( resolution ), i = 0 , resolution )] contains pure function saturated_mixing_ratio ( T_normalized , p_normalized ) result ( sat_mr ) !! Calculate the saturated mixing ratio for normalized tempetatures (k) and pressures (Pa) real , intent ( in ) :: T_normalized , p_normalized real sat_mr associate ( & temperature => T_min + ( T_max - T_min ) * T_normalized , & pressure => p_min + ( p_max - p_min ) * p_normalized & ) associate ( below_freezing => temperature < freezing_threshold ) associate ( & a => merge ( 2 1.8745584 , 1 7.2693882 , below_freezing ), & b => merge ( 7.66 , 3 5.86 , below_freezing ) & ) associate ( p_threshold => 61 0.78 * exp ( a * ( temperature - 27 3.16 ) / ( temperature - b ))) !(Pa)) associate ( e_s => merge ( pressure * 0.99999 , p_threshold , ( pressure - p_threshold ) <= 0 )) sat_mr = 0.6219907 * e_s / ( pressure - e_s ) !(kg/kg) end associate end associate end associate end associate end associate end function elemental function y ( x_in ) result ( a ) type ( tensor_t ), intent ( in ) :: x_in type ( tensor_t ) a associate ( x => x_in % values ()) call assert ( lbound ( x , 1 ) == 1 . and . ubound ( x , 1 ) == 2 , \"y(x) :: sufficient input\" ) a = tensor_t ([ saturated_mixing_ratio ( x ( 1 ), x ( 2 ))]) end associate end function end module","tags":"","loc":"sourcefile/saturated_mixing_ratio_m.f90.html"},{"title":"tensor_map_s.f90 – Fiats","text":"This file depends on sourcefile~~tensor_map_s.f90~~EfferentGraph sourcefile~tensor_map_s.f90 tensor_map_s.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~tensor_map_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~tensor_map_s.f90->sourcefile~tensor_map_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( tensor_map_m ) tensor_map_s use assert_m , only : assert use julienne_m , only : separated_values use kind_parameters_m , only : default_real implicit none contains module procedure construct_default_real call assert ( size ( minima ) == size ( maxima ), \"tensor_map_s(construct_default_real): size(minima)==size(maxima)\" ) tensor_map % layer_ = layer tensor_map % intercept_ = minima tensor_map % slope_ = maxima - minima end procedure module procedure construct_double_precision call assert ( size ( minima ) == size ( maxima ), \"tensor_map_s(construct_double_precision): size(minima)==size(maxima)\" ) tensor_map % layer_ = layer tensor_map % intercept_ = minima tensor_map % slope_ = maxima - minima end procedure module procedure from_json logical tensor_map_key_found integer l tensor_map_key_found = . false . do l = 1 , size ( lines ) if ( lines ( l )% get_json_key () == \"inputs_map\" . or . lines ( l )% get_json_key () == \"outputs_map\" ) then tensor_map_key_found = . true . tensor_map % layer_ = lines ( l + 1 )% get_json_value ( key = string_t ( \"layer\" ), mold = string_t ( \"\" )) tensor_map % intercept_ = lines ( l + 2 )% get_json_value ( key = string_t ( \"intercept\" ), mold = [ 0. ]) tensor_map % slope_ = lines ( l + 3 )% get_json_value ( key = string_t ( \"slope\" ), mold = [ 0. ]) return end if end do call assert ( tensor_map_key_found , \"tensor_map_s(from_json): 'tensor_map' key found\" ) end procedure module procedure double_precision_from_json logical tensor_map_key_found integer l tensor_map_key_found = . false . do l = 1 , size ( lines ) if ( lines ( l )% get_json_key () == \"inputs_map\" . or . lines ( l )% get_json_key () == \"outputs_map\" ) then tensor_map_key_found = . true . tensor_map % layer_ = lines ( l + 1 )% get_json_value ( key = string_t ( \"layer\" ), mold = string_t ( \"\" )) tensor_map % intercept_ = lines ( l + 2 )% get_json_value ( key = string_t ( \"intercept\" ), mold = [ 0 D0 ]) tensor_map % slope_ = lines ( l + 3 )% get_json_value ( key = string_t ( \"slope\" ), mold = [ 0 D0 ]) return end if end do call assert ( tensor_map_key_found , \"tensor_map_s(from_json): 'tensor_map' key found\" ) end procedure module procedure default_real_equals real , parameter :: tolerance = 1.E-08 call assert ( allocated ( lhs % layer_ ) . and . allocated ( rhs % layer_ ), & \"tensor_map_s(default_real_equals): allocated layer_ components\" ) call assert ( allocated ( lhs % intercept_ ) . and . allocated ( rhs % intercept_ ), & \"tensor_map_s(default_real_equals): allocated intercept_ components)\" ) call assert ( allocated ( lhs % slope_ ) . and . allocated ( rhs % slope_ ), & \"tensor_map_s(default_real_equals): allocated slope_ components)\" ) call assert ( size ( lhs % intercept_ ) == size ( rhs % intercept_ ), & \"tensor_map_s(default_real_equals): size(lhs%intercept_) == size(rhs%intercept_)\" ) call assert ( size ( lhs % slope_ ) == size ( rhs % slope_ ), & \"tensor_map_s(default_real_equals): size(lhs%slope_) == size(rhs%slope_)\" ) lhs_equals_rhs = & lhs % layer_ == rhs % layer_ . and . & all ( abs ( lhs % intercept_ - rhs % intercept_ ) <= tolerance ). and . & all ( abs ( lhs % slope_ - rhs % slope_ ) <= tolerance ) end procedure module procedure double_precision_equals double precision , parameter :: tolerance = 1.D-015 call assert ( allocated ( lhs % layer_ ) . and . allocated ( rhs % layer_ ), & \"tensor_map_s(double_precision_equals): allocated layer_ components\" ) call assert ( allocated ( lhs % intercept_ ) . and . allocated ( rhs % intercept_ ), & \"tensor_map_s(double_precision_equals): allocated intercept_ components)\" ) call assert ( allocated ( lhs % slope_ ) . and . allocated ( rhs % slope_ ), & \"tensor_map_s(double_precision_equals): allocated slope_ components)\" ) call assert ( size ( lhs % intercept_ ) == size ( rhs % intercept_ ), & \"tensor_map_s(double_precision_equals): size(lhs%intercept_) == size(rhs%intercept_)\" ) call assert ( size ( lhs % slope_ ) == size ( rhs % slope_ ), & \"tensor_map_s(double_precision_equals): size(lhs%slope_) == size(rhs%slope_)\" ) lhs_equals_rhs = & lhs % layer_ == rhs % layer_ . and . & all ( abs ( lhs % intercept_ - rhs % intercept_ ) <= tolerance ). and . & all ( abs ( lhs % slope_ - rhs % slope_ ) <= tolerance ) end procedure module procedure default_real_to_json integer , parameter :: characters_per_value = 17 character ( len =* ), parameter :: indent = repeat ( \" \" , ncopies = 4 ) character ( len = :), allocatable :: csv_format , intercept_string , slope_string call assert ( allocated ( self % layer_ ), & \"tensor_map_s(default_real_to_json): allocated layer_\" ) call assert ( allocated ( self % intercept_ ) . and . allocated ( self % slope_ ), & \"tensor_map_s(default_real_to_json): allocated intercept_/slope_\" ) csv_format = separated_values ( separator = \",\" , mold = [ real ( default_real ) :: ]) allocate ( character ( len = size ( self % intercept_ ) * ( characters_per_value + 1 ) - 1 ) :: intercept_string ) allocate ( character ( len = size ( self % slope_ ) * ( characters_per_value + 1 ) - 1 ) :: slope_string ) write ( intercept_string , fmt = csv_format ) self % intercept_ write ( slope_string , fmt = csv_format ) self % slope_ block character ( len = :), allocatable :: layer layer = trim ( adjustl ( self % layer_ )) lines = [ & string_t ( indent // '\"' // layer // '_map\": {' ), & string_t ( indent // '  \"layer\": \"' // layer // '\",' ), & string_t ( indent // '  \"intercept\": [' // trim ( adjustl ( intercept_string )) // '],' ), & string_t ( indent // '  \"slope\": [' // trim ( adjustl ( slope_string )) // ']' ), & string_t ( indent // '}' ) & ] end block end procedure module procedure double_precision_to_json integer , parameter :: characters_per_value = 34 character ( len =* ), parameter :: indent = repeat ( \" \" , ncopies = 4 ) character ( len = :), allocatable :: csv_format , intercept_string , slope_string call assert ( allocated ( self % layer_ ), & \"tensor_map_s(default_real_to_json): allocated layer_\" ) call assert ( allocated ( self % intercept_ ) . and . allocated ( self % slope_ ), & \"tensor_map_s(default_real_to_json): allocated intercept_/slope_\" ) csv_format = separated_values ( separator = \",\" , mold = [ double precision :: ]) allocate ( character ( len = size ( self % intercept_ ) * ( characters_per_value + 1 ) - 1 ) :: intercept_string ) allocate ( character ( len = size ( self % slope_ ) * ( characters_per_value + 1 ) - 1 ) :: slope_string ) write ( intercept_string , fmt = csv_format ) self % intercept_ write ( slope_string , fmt = csv_format ) self % slope_ block character ( len = :), allocatable :: layer layer = trim ( adjustl ( self % layer_ )) lines = [ & string_t ( indent // '\"' // layer // '_map\": {' ), & string_t ( indent // '  \"layer\": \"' // layer // '\",' ), & string_t ( indent // '  \"intercept\": [' // trim ( adjustl ( intercept_string )) // '],' ), & string_t ( indent // '  \"slope\": [' // trim ( adjustl ( slope_string )) // ']' ), & string_t ( indent // '}' ) & ] end block end procedure module procedure default_real_map_to_training_range associate ( tensor_values => tensor % values ()) associate ( normalized_values => ( tensor_values - self % intercept_ ) / self % slope_ ) normalized_tensor = tensor_t ( normalized_values ) end associate end associate end procedure module procedure double_precision_map_to_training_range associate ( tensor_values => tensor % values ()) associate ( normalized_values => ( tensor_values - self % intercept_ ) / self % slope_ ) normalized_tensor = tensor_t ( normalized_values ) end associate end associate end procedure module procedure default_real_map_from_training_range associate ( tensor_values => tensor % values ()) associate ( unnormalized_values => self % intercept_ + tensor_values * self % slope_ ) unnormalized_tensor = tensor_t ( unnormalized_values ) end associate end associate end procedure module procedure double_precision_map_from_training_range associate ( tensor_values => tensor % values ()) associate ( unnormalized_values => self % intercept_ + tensor_values * self % slope_ ) unnormalized_tensor = tensor_t ( unnormalized_values ) end associate end associate end procedure end submodule tensor_map_s","tags":"","loc":"sourcefile/tensor_map_s.f90.html"},{"title":"input_output_pair_s.f90 – Fiats","text":"This file depends on sourcefile~~input_output_pair_s.f90~~EfferentGraph sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( input_output_pair_m ) input_output_pair_s implicit none contains module procedure default_real_construct input_output_pair % inputs_ = inputs input_output_pair % expected_outputs_ = expected_outputs end procedure module procedure double_precision_construct input_output_pair % inputs_ = inputs input_output_pair % expected_outputs_ = expected_outputs end procedure module procedure default_real_inputs my_inputs = self % inputs_ end procedure module procedure double_precision_inputs my_inputs = self % inputs_ end procedure module procedure default_real_expected_outputs my_expected_outputs = self % expected_outputs_ end procedure module procedure double_precision_expected_outputs my_expected_outputs = self % expected_outputs_ end procedure module procedure default_real_shuffle type ( input_output_pair_t ) temp real harvest ( 2 : size ( pairs )) integer i , j call random_number ( harvest ) durstenfeld_shuffle : & do i = size ( pairs ), 2 , - 1 j = 1 + int ( harvest ( i ) * i ) temp = pairs ( i ) pairs ( i ) = pairs ( j ) pairs ( j ) = temp end do durstenfeld_shuffle end procedure module procedure double_precision_shuffle type ( input_output_pair_t ( double_precision )) temp double precision harvest ( 2 : size ( pairs )) integer i , j call random_number ( harvest ) durstenfeld_shuffle : & do i = size ( pairs ), 2 , - 1 j = 1 + int ( harvest ( i ) * i ) temp = pairs ( i ) pairs ( i ) = pairs ( j ) pairs ( j ) = temp end do durstenfeld_shuffle end procedure module procedure default_real_write_to_stdout integer i do i = 1 , size ( input_output_pairs ) print * , input_output_pairs ( i )% inputs_ % values (), \" | \" , input_output_pairs ( i )% expected_outputs_ % values () end do end procedure module procedure double_precision_write_to_stdout integer i do i = 1 , size ( input_output_pairs ) print * , input_output_pairs ( i )% inputs_ % values (), \" | \" , input_output_pairs ( i )% expected_outputs_ % values () end do end procedure end submodule input_output_pair_s","tags":"","loc":"sourcefile/input_output_pair_s.f90.html"},{"title":"print-training-configuration.F90 – Fiats","text":"This file depends on sourcefile~~print-training-configuration.f90~~EfferentGraph sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~print-training-configuration.f90->sourcefile~fiats_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~fiats_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~fiats_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~fiats_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~fiats_m.f90->sourcefile~metadata_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~fiats_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~network_configuration_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~fiats_m.f90->sourcefile~ubounds_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_network_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~activation_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program print_training_configuration !! Demonstrate how to construct and print a training_configuration_t object use fiats_m , only : training_configuration_t , hyperparameters_t , network_configuration_t use julienne_m , only : file_t implicit none #ifdef _CRAYFTN type ( training_configuration_t ) :: training_configuration type ( file_t ) :: json_file training_configuration = training_configuration_t ( & hyperparameters_t ( mini_batches = 10 , learning_rate = 1.5 , optimizer = \"adam\" ), & network_configuration_t ( skip_connections = . false ., nodes_per_layer = [ 2 , 72 , 2 ], activation_name = \"sigmoid\" )) json_file = file_t ( training_configuration % to_json ()) call json_file % write_lines () #else associate ( training_configuration => training_configuration_t ( & hyperparameters_t ( mini_batches = 10 , learning_rate = 1.5 , optimizer = \"adam\" ), & network_configuration_t ( skip_connections = . false ., nodes_per_layer = [ 2 , 72 , 2 ], activation_name = \"sigmoid\" ) & )) associate ( json_file => file_t ( training_configuration % to_json ())) call json_file % write_lines () end associate end associate #endif end program","tags":"","loc":"sourcefile/print-training-configuration.f90.html"},{"title":"unmapped_network_s.f90 – Fiats","text":"This file depends on sourcefile~~unmapped_network_s.f90~~EfferentGraph sourcefile~unmapped_network_s.f90 unmapped_network_s.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~unmapped_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( neural_network_m ) unmapped_network_s implicit none integer , parameter :: input_layer = 0 contains module procedure double_precision_unmapped_from_json unmapped_network % neural_network_ = double_precision_from_json ( file ) end procedure module procedure default_real_infer_unmapped real , allocatable :: a (:,:) integer l associate ( neural_network => self % neural_network_ ) call neural_network % assert_consistency () associate ( & w => neural_network % weights_ & , b => neural_network % biases_ & , n => neural_network % nodes_ & , output_layer => ubound ( neural_network % nodes_ , 1 ) & ) allocate ( a ( maxval ( n ), input_layer : output_layer )) a ( 1 : n ( input_layer ), input_layer ) = inputs % values () feed_forward : & do l = input_layer + 1 , output_layer associate ( z => matmul ( w ( 1 : n ( l ), 1 : n ( l - 1 ), l ), a ( 1 : n ( l - 1 ), l - 1 )) + b ( 1 : n ( l ), l )) if ( l . lt . output_layer ) then a ( 1 : n ( l ), l ) = neural_network % activation_ % evaluate ( z ) else a ( 1 : n ( l ), l ) = z ( 1 : n ( l )) end if end associate end do feed_forward outputs = tensor_t ( a ( 1 : n ( output_layer ), output_layer )) end associate end associate end procedure module procedure double_precision_infer_unmapped double precision , allocatable :: a (:,:) integer l associate ( neural_network => self % neural_network_ ) call neural_network % assert_consistency () associate ( & w => neural_network % weights_ & , b => neural_network % biases_ & , n => neural_network % nodes_ & , output_layer => ubound ( neural_network % nodes_ , 1 ) & ) allocate ( a ( maxval ( n ), input_layer : output_layer )) a ( 1 : n ( input_layer ), input_layer ) = inputs % values () feed_forward : & do l = input_layer + 1 , output_layer associate ( z => matmul ( w ( 1 : n ( l ), 1 : n ( l - 1 ), l ), a ( 1 : n ( l - 1 ), l - 1 )) + b ( 1 : n ( l ), l )) if ( l . lt . output_layer ) then a ( 1 : n ( l ), l ) = neural_network % activation_ % evaluate ( z ) else a ( 1 : n ( l ), l ) = z ( 1 : n ( l )) end if end associate end do feed_forward outputs = tensor_t ( a ( 1 : n ( output_layer ), output_layer )) end associate end associate end procedure end submodule unmapped_network_s","tags":"","loc":"sourcefile/unmapped_network_s.f90.html"},{"title":"tensor_m.f90 – Fiats","text":"This file depends on sourcefile~~tensor_m.f90~~EfferentGraph sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~tensor_m.f90~~AfferentGraph sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~fiats_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_map_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~fiats_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_s.f90 tensor_s.f90 sourcefile~tensor_s.f90->sourcefile~tensor_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~fiats_m.f90 sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~neural_network_m.f90 sourcefile~layer_m.f90->sourcefile~tensor_map_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~fiats_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~fiats_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~fiats_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~fiats_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~neural_network_s.f90 neural_network_s.F90 sourcefile~neural_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~neural_network_s.f90->sourcefile~layer_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~fiats_m.f90 sourcefile~read-query-infer.f90 read-query-infer.f90 sourcefile~read-query-infer.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~fiats_m.f90 sourcefile~tensor_map_s.f90 tensor_map_s.f90 sourcefile~tensor_map_s.f90->sourcefile~tensor_map_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~fiats_m.f90 sourcefile~trainable_network_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~unmapped_network_s.f90 unmapped_network_s.f90 sourcefile~unmapped_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~workspace_s.f90 workspace_s.f90 sourcefile~workspace_s.f90->sourcefile~neural_network_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~fiats_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_network_s.f90 trainable_network_s.f90 sourcefile~trainable_network_s.f90->sourcefile~trainable_network_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module tensor_m use kind_parameters_m , only : default_real , double_precision implicit none private public :: tensor_t type tensor_t ( k ) integer , kind :: k = default_real real ( k ), allocatable , private :: values_ (:) contains generic :: values => default_real_values , double_precision_values procedure , private , non_overridable :: default_real_values , double_precision_values generic :: num_components => default_real_num_components , double_precision_num_components procedure , private :: default_real_num_components , double_precision_num_components end type interface tensor_t pure module function construct_default_real ( values ) result ( tensor ) implicit none real , intent ( in ) :: values (:) type ( tensor_t ) tensor end function pure module function construct_double_precision ( values ) result ( tensor ) implicit none double precision , intent ( in ) :: values (:) type ( tensor_t ( double_precision )) tensor end function end interface interface pure module function default_real_values ( self ) result ( tensor_values ) implicit none class ( tensor_t ), intent ( in ) :: self real , allocatable :: tensor_values (:) end function pure module function double_precision_values ( self ) result ( tensor_values ) implicit none class ( tensor_t ( double_precision )), intent ( in ) :: self double precision , allocatable :: tensor_values (:) end function pure module function default_real_num_components ( self ) result ( n ) implicit none class ( tensor_t ), intent ( in ) :: self integer n end function pure module function double_precision_num_components ( self ) result ( n ) implicit none class ( tensor_t ( double_precision )), intent ( in ) :: self integer n end function end interface end module tensor_m","tags":"","loc":"sourcefile/tensor_m.f90.html"},{"title":"fiats_m.f90 – Fiats","text":"This file depends on sourcefile~~fiats_m.f90~~EfferentGraph sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~fiats_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~fiats_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~fiats_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~fiats_m.f90->sourcefile~metadata_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~fiats_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~network_configuration_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~fiats_m.f90->sourcefile~ubounds_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_network_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~activation_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~fiats_m.f90~~AfferentGraph sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~fiats_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~fiats_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~fiats_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~fiats_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~fiats_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~fiats_m.f90 sourcefile~read-query-infer.f90 read-query-infer.f90 sourcefile~read-query-infer.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~fiats_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~fiats_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~fiats_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module fiats_m !! Specify the user-facing modules, derived types, and type parameters use double_precision_file_m , only : double_precision_file_t use double_precision_string_m , only : double_precision_string_t use hyperparameters_m , only : hyperparameters_t use input_output_pair_m , only : input_output_pair_t , shuffle , write_to_stdout use kind_parameters_m , only : default_real , double_precision use metadata_m , only : metadata_t use mini_batch_m , only : mini_batch_t use neural_network_m , only : neural_network_t , unmapped_network_t use network_configuration_m , only : network_configuration_t use tensor_m , only : tensor_t use tensor_map_m , only : tensor_map_t use trainable_network_m , only : trainable_network_t use training_configuration_m , only : training_configuration_t use ubounds_m , only : ubounds_t implicit none end module fiats_m","tags":"","loc":"sourcefile/fiats_m.f90.html"},{"title":"layer_s.f90 – Fiats","text":"This file depends on sourcefile~~layer_s.f90~~EfferentGraph sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~layer_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~layer_m.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~layer_m.f90->sourcefile~neural_network_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~layer_m.f90->sourcefile~tensor_map_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~neuron_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( layer_m ) layer_s use assert_m , only : assert implicit none contains module procedure default_real_construct_layer type ( neuron_t ), pointer :: neuron integer num_inputs , neurons_in_layer character ( len = :), allocatable :: line logical hidden_layers , output_layer line = adjustl ( layer_lines ( start )% string ()) hidden_layers = line == '[' output_layer = line == '\"output_layer\": [' call assert ( hidden_layers . or . output_layer , \"layer_s(default_real_construct_layer): layer start\" , line ) layer % neuron = neuron_t ( layer_lines , start + 1 ) num_inputs = size ( layer % neuron % weights ()) neuron => layer % neuron neurons_in_layer = 1 do if (. not . neuron % next_allocated ()) exit neuron => neuron % next_pointer () call assert ( size ( neuron % weights ()) == num_inputs , \"layer_s(default_real_construct_layer): constant number of inputs\" ) neurons_in_layer = neurons_in_layer + 1 end do line = trim ( adjustl ( layer_lines ( start + 4 * neurons_in_layer + 1 )% string ())) call assert ( line ( 1 : 1 ) == ']' , \"layer_s(default_real_construct_layer): hidden layer end\" ) if ( line ( len ( line ): len ( line )) == \",\" ) layer % next = layer_t ( layer_lines , start + 4 * neurons_in_layer + 2 ) end procedure module procedure double_precision_construct_layer type ( neuron_t ( double_precision )), pointer :: neuron integer num_inputs , neurons_in_layer character ( len = :), allocatable :: line logical hidden_layers , output_layer line = adjustl ( layer_lines ( start )% string ()) hidden_layers = line == '[' output_layer = line == '\"output_layer\": [' call assert ( hidden_layers . or . output_layer , \"layer_s(double_precision_construct_layer): layer start\" , line ) layer % neuron = neuron_t ( layer_lines , start + 1 ) num_inputs = size ( layer % neuron % weights ()) neuron => layer % neuron neurons_in_layer = 1 do if (. not . neuron % next_allocated ()) exit neuron => neuron % next_pointer () call assert ( size ( neuron % weights ()) == num_inputs , \"layer_s(double_precision_construct_layer): constant number of inputs\" ) neurons_in_layer = neurons_in_layer + 1 end do line = trim ( adjustl ( layer_lines ( start + 4 * neurons_in_layer + 1 )% string ())) call assert ( line ( 1 : 1 ) == ']' , \"layer_s(double_precision_construct_layer): hidden layer end\" ) if ( line ( len ( line ): len ( line )) == \",\" ) layer % next = layer_t ( layer_lines , start + 4 * neurons_in_layer + 2 ) end procedure module procedure default_real_neural_network associate ( & num_inputs => hidden_layers % count_inputs (), & num_outputs => output_layer % count_neurons (), & neurons_per_hidden_layer => hidden_layers % count_neurons (), & num_hidden_layers => hidden_layers % count_layers (), & num_output_layers => output_layer % count_layers () & ) call assert ( num_output_layers == 1 , \"neural_network_s(default_real_neural_network): 1 output layer\" , num_output_layers ) associate ( nodes => [ num_inputs , neurons_per_hidden_layer , num_outputs ]) associate ( n_max => maxval ( nodes )) block real , allocatable :: weights (:,:,:), biases (:,:) type ( layer_t ), pointer :: layer_ptr type ( neuron_t ), pointer :: neuron_ptr integer j , l allocate ( weights ( n_max , n_max , num_hidden_layers + num_output_layers )) allocate ( biases ( n_max , num_hidden_layers + num_output_layers )) layer_ptr => hidden_layers l = 0 loop_over_hidden_Layers : & do l = l + 1 neuron_ptr => layer_ptr % neuron j = 0 loop_over_hidden_neurons : & do j = j + 1 associate ( w => neuron_ptr % weights ()) weights ( j , 1 : size ( w , 1 ), l ) = w end associate biases ( j , l ) = neuron_ptr % bias () if (. not . neuron_ptr % next_allocated ()) exit neuron_ptr => neuron_ptr % next_pointer () end do loop_over_hidden_neurons if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next_pointer () end do loop_over_hidden_Layers layer_ptr => output_layer l = l + 1 neuron_ptr => layer_ptr % neuron j = 0 loop_over_output_neurons : & do j = j + 1 associate ( w => neuron_ptr % weights ()) weights ( j , 1 : size ( w , 1 ), l ) = w end associate biases ( j , l ) = neuron_ptr % bias () if (. not . neuron_ptr % next_allocated ()) exit neuron_ptr => neuron_ptr % next_pointer () end do loop_over_output_neurons neural_network_ = neural_network_t ( metadata , weights , biases , nodes , input_map , output_map ) end block end associate end associate end associate end procedure default_real_neural_network module procedure double_precision_neural_network associate ( & num_inputs => hidden_layers % count_inputs (), & num_outputs => output_layer % count_neurons (), & neurons_per_hidden_layer => hidden_layers % count_neurons (), & num_hidden_layers => hidden_layers % count_layers (), & num_output_layers => output_layer % count_layers () & ) call assert ( num_output_layers == 1 , \"neural_network_s(double_precision_neural_network): 1 output layer\" , num_output_layers ) associate ( nodes => [ num_inputs , neurons_per_hidden_layer , num_outputs ]) associate ( n_max => maxval ( nodes )) block double precision , allocatable :: weights (:,:,:), biases (:,:) type ( layer_t ( double_precision )), pointer :: layer_ptr type ( neuron_t ( double_precision )), pointer :: neuron_ptr integer j , l allocate ( weights ( n_max , n_max , num_hidden_layers + num_output_layers )) allocate ( biases ( n_max , num_hidden_layers + num_output_layers )) layer_ptr => hidden_layers l = 0 loop_over_hidden_Layers : & do l = l + 1 neuron_ptr => layer_ptr % neuron j = 0 loop_over_hidden_neurons : & do j = j + 1 associate ( w => neuron_ptr % weights ()) weights ( j , 1 : size ( w , 1 ), l ) = w end associate biases ( j , l ) = neuron_ptr % bias () if (. not . neuron_ptr % next_allocated ()) exit neuron_ptr => neuron_ptr % next_pointer () end do loop_over_hidden_neurons if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next_pointer () end do loop_over_hidden_Layers layer_ptr => output_layer l = l + 1 neuron_ptr => layer_ptr % neuron j = 0 loop_over_output_neurons : & do j = j + 1 associate ( w => neuron_ptr % weights ()) weights ( j , 1 : size ( w , 1 ), l ) = w end associate biases ( j , l ) = neuron_ptr % bias () if (. not . neuron_ptr % next_allocated ()) exit neuron_ptr => neuron_ptr % next_pointer () end do loop_over_output_neurons neural_network_ = neural_network_t ( metadata , weights , biases , nodes , input_map , output_map ) end block end associate end associate end associate end procedure double_precision_neural_network module procedure default_real_count_layers type ( layer_t ), pointer :: layer_ptr layer_ptr => layer num_layers = 1 do if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next num_layers = num_layers + 1 end do end procedure module procedure double_precision_count_layers type ( layer_t ( double_precision )), pointer :: layer_ptr layer_ptr => layer num_layers = 1 do if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next num_layers = num_layers + 1 end do end procedure module procedure default_real_count_neurons type ( layer_t ), pointer :: layer_ptr type ( neuron_t ), pointer :: neuron_ptr integer num_neurons layer_ptr => layer allocate ( neurons_per_layer_result ( 0 )) do num_neurons = 1 neuron_ptr => layer_ptr % neuron do if (. not . neuron_ptr % next_allocated ()) exit neuron_ptr => neuron_ptr % next_pointer () num_neurons = num_neurons + 1 end do neurons_per_layer_result = [ neurons_per_layer_result , num_neurons ] if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next end do end procedure module procedure double_precision_count_neurons type ( layer_t ( double_precision )), pointer :: layer_ptr type ( neuron_t ( double_precision )), pointer :: neuron_ptr integer num_neurons layer_ptr => layer allocate ( neurons_per_layer_result ( 0 )) do num_neurons = 1 neuron_ptr => layer_ptr % neuron do if (. not . neuron_ptr % next_allocated ()) exit neuron_ptr => neuron_ptr % next_pointer () num_neurons = num_neurons + 1 end do neurons_per_layer_result = [ neurons_per_layer_result , num_neurons ] if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next end do end procedure module procedure default_real_count_inputs num_inputs = layer % neuron % num_inputs () ! assume fully connected input layer end procedure module procedure double_precision_count_inputs num_inputs = layer % neuron % num_inputs () ! assume fully connected input layer end procedure module procedure default_real_neurons_per_layer type ( neuron_t ), pointer :: neuron neuron => self % neuron num_neurons = 1 do if (. not . neuron % next_allocated ()) exit neuron => neuron % next_pointer () num_neurons = num_neurons + 1 end do end procedure module procedure double_precision_neurons_per_layer type ( neuron_t ( double_precision )), pointer :: neuron neuron => self % neuron num_neurons = 1 do if (. not . neuron % next_allocated ()) exit neuron => neuron % next_pointer () num_neurons = num_neurons + 1 end do end procedure module procedure default_real_next_allocated next_is_allocated = allocated ( self % next ) end procedure module procedure double_precision_next_allocated next_is_allocated = allocated ( self % next ) end procedure module procedure default_real_next_pointer if ( allocated ( self % next )) then next_ptr => self % next else next_ptr => null () end if end procedure module procedure double_precision_next_pointer if ( allocated ( self % next )) then next_ptr => self % next else next_ptr => null () end if end procedure end submodule layer_s","tags":"","loc":"sourcefile/layer_s.f90.html"},{"title":"mini_batch_m.f90 – Fiats","text":"This file depends on sourcefile~~mini_batch_m.f90~~EfferentGraph sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mini_batch_m.f90~~AfferentGraph sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~fiats_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~fiats_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~neural_network_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~fiats_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~fiats_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~fiats_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~fiats_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~neural_network_s.f90 neural_network_s.F90 sourcefile~neural_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~neural_network_s.f90->sourcefile~layer_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~fiats_m.f90 sourcefile~read-query-infer.f90 read-query-infer.f90 sourcefile~read-query-infer.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~fiats_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~fiats_m.f90 sourcefile~trainable_network_s.f90 trainable_network_s.f90 sourcefile~trainable_network_s.f90->sourcefile~trainable_network_m.f90 sourcefile~unmapped_network_s.f90 unmapped_network_s.f90 sourcefile~unmapped_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~workspace_s.f90 workspace_s.f90 sourcefile~workspace_s.f90->sourcefile~neural_network_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~fiats_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module mini_batch_m use input_output_pair_m , only : input_output_pair_t use kind_parameters_m , only : default_real , double_precision implicit none private public :: mini_batch_t type mini_batch_t ( k ) integer , kind :: k = default_real type ( input_output_pair_t ( k )), private , allocatable :: input_output_pairs_ (:) contains generic :: input_output_pairs => default_real_input_output_pairs , double_precision_input_output_pairs procedure , non_overridable :: default_real_input_output_pairs , double_precision_input_output_pairs end type interface mini_batch_t pure module function default_real_construct ( input_output_pairs ) result ( mini_batch ) implicit none type ( input_output_pair_t ), intent ( in ) :: input_output_pairs (:) type ( mini_batch_t ) mini_batch end function pure module function double_precision_construct ( input_output_pairs ) result ( mini_batch ) implicit none type ( input_output_pair_t ( double_precision )), intent ( in ) :: input_output_pairs (:) type ( mini_batch_t ( double_precision )) mini_batch end function end interface interface pure module function default_real_input_output_pairs ( self ) result ( my_input_output_pairs ) implicit none class ( mini_batch_t ), intent ( in ) :: self type ( input_output_pair_t ), allocatable :: my_input_output_pairs (:) end function pure module function double_precision_input_output_pairs ( self ) result ( my_input_output_pairs ) implicit none class ( mini_batch_t ( double_precision )), intent ( in ) :: self type ( input_output_pair_t ( double_precision )), allocatable :: my_input_output_pairs (:) end function end interface end module mini_batch_m","tags":"","loc":"sourcefile/mini_batch_m.f90.html"},{"title":"activation_s.f90 – Fiats","text":"This file depends on sourcefile~~activation_s.f90~~EfferentGraph sourcefile~activation_s.f90 activation_s.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~activation_s.f90->sourcefile~activation_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( activation_m ) activation_s use assert_m , only : assert implicit none real , parameter :: pi = 3.141592653589793 double precision , parameter :: pi_dp = 3.141592653589793D0 contains module procedure construct_from_component activation % selection_ = selection end procedure module procedure equals self_eq_rhs = self % selection_ == rhs % selection_ end procedure module procedure function_name call assert ( lbound ( activation_name , 1 ) <= self % selection_ . and . self % selection_ <= ubound ( activation_name , 1 ), & \"activation_s(function_name): bounds\" ) string = string_t ( trim ( activation_name ( self % selection_ ))) end procedure module procedure construct_from_name select case ( name ) case ( \"gelu\" ) activation % selection_ = gelu case ( \"relu\" ) activation % selection_ = relu case ( \"sigmoid\" ) activation % selection_ = sigmoid case ( \"step\" ) activation % selection_ = step case ( \"swish\" ) activation % selection_ = swish case default error stop \"activation_s(construct_from_name): unknown name\" end select end procedure module procedure default_real_evaluate select case ( self % selection_ ) case ( gelu ) y = . 5 * x * ( 1. + erf ( x / sqrt ( 2. ))) case ( relu ) y = max ( 0. , x ) case ( sigmoid ) y = 1. / ( 1. + exp ( - x )) case ( step ) y = merge ( 1. , 0. , x > 0. ) case ( swish ) associate ( sigmoid_activation => 1. / ( 1. + exp ( - x ))) y = x * sigmoid_activation end associate case default error stop \"activation_s(default_real_evaluate): unknown activation\" end select end procedure module procedure double_precision_evaluate select case ( self % selection_ ) case ( gelu ) y = . 5 D0 * x * ( 1 D0 + erf ( x / sqrt ( 2 D0 ))) case ( relu ) y = max ( 0 D0 , x ) case ( sigmoid ) y = 1 D0 / ( 1 D0 + exp ( - x )) case ( step ) y = merge ( 1 D0 , 0 D0 , x > 0 D0 ) case ( swish ) associate ( sigmoid_activation => 1 D0 / ( 1 D0 + exp ( - x ))) y = x * sigmoid_activation end associate case default error stop \"activation_s(double_precision_evaluate): unknown activation\" end select end procedure module procedure default_real_differentiate select case ( self % selection_ ) case ( gelu ) dy_dx = . 5 * ( 1. + erf ( x / sqrt ( 2. ))) + x * exp ( - x ** 2 / 2. ) / sqrt ( 2 * pi ) case ( relu ) dy_dx = merge ( 1. , 0. , x > 0. ) case ( sigmoid ) dy_dx = exp ( - x ) / ( 1. + exp ( - x )) ** 2 case ( step ) error stop \"activation_s(default_real_differentiate): non-differentiable activation\" case ( swish ) associate ( sigmoid_activation => 1. / ( 1. + exp ( - x )), sigmoid_differentiate => exp ( - x ) / ( 1. + exp ( - x )) ** 2 ) dy_dx = sigmoid_activation + x * sigmoid_differentiate end associate case default error stop \"activation_s(default_real_differentiate): unknown activation\" end select end procedure module procedure double_precision_differentiate select case ( self % selection_ ) case ( gelu ) dy_dx = . 5 D0 * ( 1 D0 + erf ( x / sqrt ( 2 D0 ))) + x * exp ( - x ** 2 / 2 D0 ) / sqrt ( 2 D0 * pi_dp ) case ( relu ) dy_dx = merge ( 1 D0 , 0 D0 , x > 0 D0 ) case ( sigmoid ) dy_dx = exp ( - x ) / ( 1 D0 + exp ( - x )) ** 2 case ( step ) error stop \"activation_s(double_precision_differentiate): non-differentiable activation\" case ( swish ) associate ( sigmoid_activation => 1 D0 / ( 1 D0 + exp ( - x )), sigmoid_differentiate => exp ( - x ) / ( 1 D0 + exp ( - x )) ** 2 ) dy_dx = sigmoid_activation + x * sigmoid_differentiate end associate case default error stop \"activation_s(double_precision_differentiate): unknown activation\" end select end procedure end submodule activation_s","tags":"","loc":"sourcefile/activation_s.f90.html"},{"title":"hyperparameters_s.f90 – Fiats","text":"This file depends on sourcefile~~hyperparameters_s.f90~~EfferentGraph sourcefile~hyperparameters_s.f90 hyperparameters_s.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~hyperparameters_s.f90->sourcefile~hyperparameters_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( hyperparameters_m ) hyperparameters_s use assert_m , only : assert implicit none character ( len =* ), parameter :: mini_batches_key = \"mini-batches\" character ( len =* ), parameter :: learning_rate_key = \"learning rate\" character ( len =* ), parameter :: optimizer_key = \"optimizer\" contains module procedure default_real_from_components hyperparameters % mini_batches_ = mini_batches hyperparameters % learning_rate_ = learning_rate hyperparameters % optimizer_ = optimizer end procedure module procedure double_precision_from_components hyperparameters % mini_batches_ = mini_batches hyperparameters % learning_rate_ = learning_rate hyperparameters % optimizer_ = optimizer end procedure module procedure default_real_equals real , parameter :: tolerance = 1.E-08 call assert ( allocated ( lhs % optimizer_ ) . and . allocated ( rhs % optimizer_ ), & \"hyperparameters_s(default_real_equals): allocated optimizers\" ) lhs_equals_rhs = & lhs % mini_batches_ == rhs % mini_batches_ . and . & lhs % optimizer_ == rhs % optimizer_ . and . & abs ( lhs % learning_rate_ - rhs % learning_rate_ ) <= tolerance end procedure module procedure double_precision_equals double precision , parameter :: tolerance = 1.D-15 call assert ( allocated ( lhs % optimizer_ ) . and . allocated ( rhs % optimizer_ ), & \"hyperparameters_s(double_precisionequals): allocated optimizers\" ) lhs_equals_rhs = & lhs % mini_batches_ == rhs % mini_batches_ . and . & lhs % optimizer_ == rhs % optimizer_ . and . & abs ( lhs % learning_rate_ - rhs % learning_rate_ ) <= tolerance end procedure module procedure default_real_from_json integer l logical hyperparameters_key_found hyperparameters_key_found = . false . do l = 1 , size ( lines ) if ( lines ( l )% get_json_key () == \"hyperparameters\" ) then hyperparameters_key_found = . true . hyperparameters % mini_batches_ = lines ( l + 1 )% get_json_value ( string_t ( mini_batches_key ), mold = 0 ) hyperparameters % learning_rate_ = lines ( l + 2 )% get_json_value ( string_t ( learning_rate_key ), mold = 0. ) hyperparameters % optimizer_ = lines ( l + 3 )% get_json_value ( string_t ( optimizer_key ), mold = string_t ( \"\" )) return end if end do call assert ( hyperparameters_key_found , \"hyperparameters_s(default_real_from_json): hyperparameters_found\" ) end procedure module procedure double_precision_from_json integer l logical hyperparameters_key_found hyperparameters_key_found = . false . do l = 1 , size ( lines ) if ( lines ( l )% get_json_key () == \"hyperparameters\" ) then hyperparameters_key_found = . true . hyperparameters % mini_batches_ = lines ( l + 1 )% get_json_value ( string_t ( mini_batches_key ), mold = 0 ) hyperparameters % learning_rate_ = lines ( l + 2 )% get_json_value ( string_t ( learning_rate_key ), mold = 0.D0 ) hyperparameters % optimizer_ = lines ( l + 3 )% get_json_value ( string_t ( optimizer_key ), mold = string_t ( \"\" )) return end if end do call assert ( hyperparameters_key_found , \"hyperparameters_s(double_precision_from_json): hyperparameters_found\" ) end procedure module procedure default_real_to_json character ( len =* ), parameter :: indent = repeat ( \" \" , ncopies = 4 ) integer , parameter :: max_width = 18 character ( len = max_width ) mini_batches_string , learning_rate_string write ( mini_batches_string , * ) self % mini_batches_ write ( learning_rate_string , * ) self % learning_rate_ lines = [ & string_t ( indent // '\"hyperparameters\": {' ), & string_t ( indent // indent // '\"' // mini_batches_key // '\" : ' // trim ( adjustl ( mini_batches_string )) // \",\" ), & string_t ( indent // indent // '\"' // learning_rate_key // '\" : ' // trim ( adjustl ( learning_rate_string )) // \",\" ), & string_t ( indent // indent // '\"' // optimizer_key // '\" : \"' // trim ( adjustl ( self % optimizer_ )) // '\"' ), & string_t ( indent // '}' ) & ] end procedure module procedure double_precision_to_json character ( len =* ), parameter :: indent = repeat ( \" \" , ncopies = 4 ) integer , parameter :: max_width = 36 character ( len = max_width ) mini_batches_string , learning_rate_string write ( mini_batches_string , * ) self % mini_batches_ write ( learning_rate_string , * ) self % learning_rate_ lines = [ & string_t ( indent // '\"hyperparameters\": {' ), & string_t ( indent // indent // '\"' // mini_batches_key // '\" : ' // trim ( adjustl ( mini_batches_string )) // \",\" ), & string_t ( indent // indent // '\"' // learning_rate_key // '\" : ' // trim ( adjustl ( learning_rate_string )) // \",\" ), & string_t ( indent // indent // '\"' // optimizer_key // '\" : \"' // trim ( adjustl ( self % optimizer_ )) // '\"' ), & string_t ( indent // '}' ) & ] end procedure module procedure default_real_mini_batches num_mini_batches = self % mini_batches_ end procedure module procedure double_precision_mini_batches num_mini_batches = self % mini_batches_ end procedure module procedure default_real_optimizer_name identifier = string_t ( self % optimizer_ ) end procedure module procedure double_precision_optimizer_name identifier = string_t ( self % optimizer_ ) end procedure module procedure default_real_learning_rate rate = self % learning_rate_ end procedure module procedure double_precision_learning_rate rate = self % learning_rate_ end procedure end submodule hyperparameters_s","tags":"","loc":"sourcefile/hyperparameters_s.f90.html"},{"title":"learn-exponentiation.F90 – Fiats","text":"This file depends on sourcefile~~learn-exponentiation.f90~~EfferentGraph sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~learn-exponentiation.f90->sourcefile~fiats_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~fiats_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~fiats_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~fiats_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~fiats_m.f90->sourcefile~metadata_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~fiats_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~network_configuration_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~fiats_m.f90->sourcefile~ubounds_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_network_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~activation_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module exponentiation_m !! Define a function that produces the desired network output for a given network input use fiats_m , only : tensor_t use assert_m , only : assert implicit none contains elemental function y ( x_tensor ) result ( a_tensor ) type ( tensor_t ), intent ( in ) :: x_tensor type ( tensor_t ) a_tensor associate ( x => x_tensor % values ()) call assert ( ubound ( x , 1 ) >= 7 . and . lbound ( x , 1 ) <= 2 , \"y(x) :: sufficient input\" ) a_tensor = tensor_t ([ x ( 1 ) ** 2 , x ( 2 ) ** 3 , x ( 3 ) ** 4 , x ( 4 ) ** 4 , x ( 5 ) ** 3 , x ( 6 ) ** 2 ]) end associate end function end module program learn_exponentiation !! This trains a neural network to learn the following six polynomial functions of its eight inputs. use fiats_m , only : neural_network_t , trainable_network_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle use julienne_m , only : string_t , file_t , command_line_t , bin_t use assert_m , only : assert , intrinsic_array_t use exponentiation_m , only : y implicit none type ( string_t ) final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example train-polynomials --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 10 , num_epochs = 200000 , num_mini_batches = 2 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_network_t ) trainable_network type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) call random_init ( image_distinct = . true ., repeatable = . true .) trainable_network = perturbed_identity_network ( perturbation_magnitude = 0.05 ) call output ( trainable_network , string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_network % num_inputs (), num_outputs => trainable_network % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) inputs = [( tensor_t ( real ([( j * i , j = 1 , num_inputs )]) / ( num_inputs * num_pairs )), i = 1 , num_pairs )] desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_network % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block integer p #if defined _CRAYFTN || __GFORTRAN__ type ( tensor_t ), allocatable :: network_outputs (:) network_outputs = trainable_network % infer ( inputs ) #else associate ( network_outputs => trainable_network % infer ( inputs )) #endif print \"(a,69x,a)\" , \"  Outputs\" , \"| Desired outputs\" do p = 1 , num_pairs print \"(6G13.5, a1, 6G13.5)\" , network_outputs ( p )% values (), \"|\" , desired_outputs ( p )% values () end do #if defined _CRAYFTN || __GFORTRAN__ #else end associate #endif end block end associate call output ( trainable_network , final_network_file ) end block contains subroutine output ( neural_network , file_name ) class ( neural_network_t ), intent ( in ) :: neural_network type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = neural_network % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_network ) type ( trainable_network_t ) trainable_network real , intent ( in ) :: perturbation_magnitude integer , parameter :: n ( * ) = [ 8 , 64 , 64 , 64 , 6 ] ! nodes per layer (first layer = input, last layer = output) integer , parameter :: n_max = maxval ( n ), layers = size ( n ) integer k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_network = trainable_network_t ( neural_network_t ( & nodes = n , weights = w , biases = b , metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & )) end associate end function end program","tags":"","loc":"sourcefile/learn-exponentiation.f90.html"},{"title":"layer_m.f90 – Fiats","text":"This file depends on sourcefile~~layer_m.f90~~EfferentGraph sourcefile~layer_m.f90 layer_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~layer_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~layer_m.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~layer_m.f90->sourcefile~neural_network_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~layer_m.f90->sourcefile~tensor_map_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~neuron_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~layer_m.f90~~AfferentGraph sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~neural_network_s.f90 neural_network_s.F90 sourcefile~neural_network_s.f90->sourcefile~layer_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module layer_m use double_precision_string_m , only : double_precision_string_t use kind_parameters_m , only : default_real , double_precision use julienne_string_m , only : string_t use neural_network_m , only : neural_network_t use metadata_m , only : metadata_t use neuron_m , only : neuron_t use tensor_map_m , only : tensor_map_t implicit none private public :: layer_t type layer_t ( k ) !! linked list of layers, each comprised of a linked list of neurons integer , kind :: k = default_real type ( neuron_t ( k )), private :: neuron !! linked list of this layer's neurons type ( layer_t ( k )), allocatable , private :: next !! next layer contains generic :: neural_network => default_real_neural_network , double_precision_neural_network procedure , private :: default_real_neural_network , double_precision_neural_network generic :: count_layers => default_real_count_layers , double_precision_count_layers procedure , private :: default_real_count_layers , double_precision_count_layers generic :: count_neurons => default_real_count_neurons , double_precision_count_neurons procedure , private :: default_real_count_neurons , double_precision_count_neurons generic :: count_inputs => default_real_count_inputs , double_precision_count_inputs procedure , private :: default_real_count_inputs , double_precision_count_inputs generic :: neurons_per_layer => default_real_neurons_per_layer , double_precision_neurons_per_layer procedure , private :: default_real_neurons_per_layer , double_precision_neurons_per_layer generic :: next_allocated => default_real_next_allocated , double_precision_next_allocated procedure , private :: default_real_next_allocated , double_precision_next_allocated generic :: next_pointer => default_real_next_pointer , double_precision_next_pointer procedure , private :: default_real_next_pointer , double_precision_next_pointer end type interface layer_t recursive module function default_real_construct_layer ( layer_lines , start ) result ( layer ) !! construct a linked list of layer_t objects from an array of JSON-formatted text lines implicit none type ( string_t ), intent ( in ) :: layer_lines (:) integer , intent ( in ) :: start type ( layer_t ), target :: layer end function recursive module function double_precision_construct_layer ( layer_lines , start ) result ( layer ) !! construct a linked list of layer_t objects from an array of JSON-formatted text lines implicit none type ( double_precision_string_t ), intent ( in ) :: layer_lines (:) integer , intent ( in ) :: start type ( layer_t ( double_precision )), target :: layer end function end interface interface module function default_real_neural_network ( hidden_layers , metadata , output_layer , input_map , output_map ) result ( neural_network_ ) implicit none class ( layer_t ), intent ( in ), target :: hidden_layers type ( layer_t ), intent ( in ), target :: output_layer type ( string_t ), intent ( in ) :: metadata (:) type ( tensor_map_t ), intent ( in ) :: input_map , output_map type ( neural_network_t ) neural_network_ end function module function double_precision_neural_network ( hidden_layers , metadata , output_layer , input_map , output_map ) result ( neural_network_ ) implicit none class ( layer_t ( double_precision )), intent ( in ), target :: hidden_layers type ( layer_t ( double_precision )), intent ( in ), target :: output_layer type ( metadata_t ), intent ( in ) :: metadata type ( tensor_map_t ( double_precision )), intent ( in ) :: input_map , output_map type ( neural_network_t ( double_precision )) neural_network_ end function module function default_real_count_layers ( layer ) result ( num_layers ) implicit none class ( layer_t ), intent ( in ), target :: layer integer num_layers end function module function double_precision_count_layers ( layer ) result ( num_layers ) implicit none class ( layer_t ( double_precision )), intent ( in ), target :: layer integer num_layers end function module function default_real_count_neurons ( layer ) result ( neurons_per_layer_result ) implicit none class ( layer_t ), intent ( in ), target :: layer integer , allocatable :: neurons_per_layer_result (:) end function module function double_precision_count_neurons ( layer ) result ( neurons_per_layer_result ) implicit none class ( layer_t ( double_precision )), intent ( in ), target :: layer integer , allocatable :: neurons_per_layer_result (:) end function module function default_real_count_inputs ( layer ) result ( num_inputs ) implicit none class ( layer_t ), intent ( in ) :: layer integer num_inputs end function module function double_precision_count_inputs ( layer ) result ( num_inputs ) implicit none class ( layer_t ( double_precision )), intent ( in ) :: layer integer num_inputs end function module function default_real_neurons_per_layer ( self ) result ( num_neurons ) implicit none class ( layer_t ), intent ( in ), target :: self integer num_neurons end function module function double_precision_neurons_per_layer ( self ) result ( num_neurons ) implicit none class ( layer_t ( double_precision )), intent ( in ), target :: self integer num_neurons end function module function default_real_next_allocated ( self ) result ( next_is_allocated ) implicit none class ( layer_t ), intent ( in ) :: self logical next_is_allocated end function module function double_precision_next_allocated ( self ) result ( next_is_allocated ) implicit none class ( layer_t ( double_precision )), intent ( in ) :: self logical next_is_allocated end function module function default_real_next_pointer ( self ) result ( next_ptr ) implicit none class ( layer_t ), intent ( in ), target :: self type ( layer_t ), pointer :: next_ptr end function module function double_precision_next_pointer ( self ) result ( next_ptr ) implicit none class ( layer_t ( double_precision )), intent ( in ), target :: self type ( layer_t ( double_precision )), pointer :: next_ptr end function end interface end module","tags":"","loc":"sourcefile/layer_m.f90.html"},{"title":"neuron_m.f90 – Fiats","text":"This file depends on sourcefile~~neuron_m.f90~~EfferentGraph sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~neuron_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~neuron_m.f90~~AfferentGraph sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~neural_network_s.f90 neural_network_s.F90 sourcefile~neural_network_s.f90->sourcefile~neuron_m.f90 sourcefile~neural_network_s.f90->sourcefile~layer_m.f90 sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module neuron_m use julienne_string_m , only : string_t use kind_parameters_m , only : default_real , double_precision use double_precision_string_m , only : double_precision_string_t implicit none private public :: neuron_t type neuron_t ( k ) !! linked list of neurons integer , kind :: k = default_real real ( k ), allocatable , private :: weights_ (:) real ( k ), private :: bias_ type ( neuron_t ( k )), allocatable , private :: next contains generic :: to_json => default_real_to_json , double_precision_to_json procedure , private :: default_real_to_json , double_precision_to_json generic :: weights => default_real_weights , double_precision_weights procedure , private :: default_real_weights , double_precision_weights generic :: bias => default_real_bias , double_precision_bias procedure , private :: default_real_bias , double_precision_bias generic :: next_allocated => default_real_next_allocated , double_precision_next_allocated procedure , private :: default_real_next_allocated , double_precision_next_allocated generic :: next_pointer => default_real_next_pointer , double_precision_next_pointer procedure , private :: default_real_next_pointer , double_precision_next_pointer generic :: num_inputs => default_real_num_inputs , double_precision_num_inputs procedure , private :: default_real_num_inputs , double_precision_num_inputs end type interface neuron_t pure recursive module function from_json ( neuron_lines , start ) result ( neuron ) !! construct linked list of neuron_t objects from an array of JSON-formatted text lines implicit none type ( string_t ), intent ( in ) :: neuron_lines (:) integer , intent ( in ) :: start type ( neuron_t ) neuron end function pure recursive module function double_precision_from_json ( neuron_lines , start ) result ( neuron ) !! construct linked list of neuron_t objects from an array of JSON-formatted text lines implicit none type ( double_precision_string_t ), intent ( in ) :: neuron_lines (:) integer , intent ( in ) :: start type ( neuron_t ( double_precision )) neuron end function pure module function default_real_from_components ( weights , bias ) result ( neuron ) !! construct single neuron_t object from an array of weights and a bias real , intent ( in ) :: weights (:) real , intent ( in ) :: bias type ( neuron_t ) neuron end function pure module function double_precision_from_components ( weights , bias ) result ( neuron ) !! construct single neuron_t object from an array of weights and a bias double precision , intent ( in ) :: weights (:) double precision , intent ( in ) :: bias type ( neuron_t ( double_precision )) neuron end function end interface interface pure module function default_real_to_json ( self ) result ( lines ) implicit none class ( neuron_t ), intent ( in ) :: self type ( string_t ), allocatable :: lines (:) end function pure module function double_precision_to_json ( self ) result ( lines ) implicit none class ( neuron_t ( double_precision )), intent ( in ) :: self type ( string_t ), allocatable :: lines (:) end function module function default_real_weights ( self ) result ( my_weights ) implicit none class ( neuron_t ), intent ( in ) :: self real , allocatable :: my_weights (:) end function module function double_precision_weights ( self ) result ( my_weights ) implicit none class ( neuron_t ( double_precision )), intent ( in ) :: self double precision , allocatable :: my_weights (:) end function module function default_real_bias ( self ) result ( my_bias ) implicit none class ( neuron_t ), intent ( in ) :: self real my_bias end function module function double_precision_bias ( self ) result ( my_bias ) implicit none class ( neuron_t ( double_precision )), intent ( in ) :: self double precision my_bias end function module function default_real_next_allocated ( self ) result ( next_is_allocated ) implicit none class ( neuron_t ), intent ( in ) :: self logical next_is_allocated end function module function double_precision_next_allocated ( self ) result ( next_is_allocated ) implicit none class ( neuron_t ( double_precision )), intent ( in ) :: self logical next_is_allocated end function module function default_real_next_pointer ( self ) result ( next_ptr ) implicit none class ( neuron_t ), intent ( in ), target :: self type ( neuron_t ), pointer :: next_ptr end function module function double_precision_next_pointer ( self ) result ( next_ptr ) implicit none class ( neuron_t ( double_precision )), intent ( in ), target :: self type ( neuron_t ( double_precision )), pointer :: next_ptr end function pure module function default_real_num_inputs ( self ) result ( size_weights ) implicit none class ( neuron_t ), intent ( in ) :: self integer size_weights end function pure module function double_precision_num_inputs ( self ) result ( size_weights ) implicit none class ( neuron_t ( double_precision )), intent ( in ) :: self integer size_weights end function end interface end module","tags":"","loc":"sourcefile/neuron_m.f90.html"},{"title":"neural_network_m.f90 – Fiats","text":"This file depends on sourcefile~~neural_network_m.f90~~EfferentGraph sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~neural_network_m.f90~~AfferentGraph sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~neural_network_m.f90 sourcefile~neural_network_s.f90 neural_network_s.F90 sourcefile~neural_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~neural_network_s.f90->sourcefile~layer_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~unmapped_network_s.f90 unmapped_network_s.f90 sourcefile~unmapped_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~workspace_s.f90 workspace_s.f90 sourcefile~workspace_s.f90->sourcefile~neural_network_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~fiats_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~fiats_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~fiats_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~fiats_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~fiats_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~fiats_m.f90 sourcefile~read-query-infer.f90 read-query-infer.f90 sourcefile~read-query-infer.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~fiats_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~fiats_m.f90 sourcefile~trainable_network_s.f90 trainable_network_s.f90 sourcefile~trainable_network_s.f90->sourcefile~trainable_network_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~fiats_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module neural_network_m !! Define an abstraction that supports inference operations on a neural network use activation_m , only : activation_t use double_precision_file_m , only : double_precision_file_t use kind_parameters_m , only : default_real , double_precision use julienne_m , only : file_t , string_t use metadata_m , only : metadata_t use mini_batch_m , only : mini_batch_t use tensor_m , only : tensor_t use tensor_map_m , only : tensor_map_t implicit none private public :: neural_network_t public :: unmapped_network_t public :: workspace_t type neural_network_t ( k ) !! Encapsulate the information needed to perform inference integer , kind :: k = default_real type ( tensor_map_t ( k )), private :: input_map_ , output_map_ type ( metadata_t ), private :: metadata_ real ( k ), allocatable , private :: weights_ (:,:,:), biases_ (:,:) integer , allocatable , private :: nodes_ (:) type ( activation_t ), private :: activation_ contains generic :: operator ( == ) => default_real_approximately_equal , double_precision_approximately_equal generic :: infer => default_real_infer , double_precision_infer generic :: to_json => default_real_to_json , double_precision_to_json generic :: map_to_input_range => default_real_map_to_input_range , double_precision_map_to_input_range generic :: map_from_output_range => default_real_map_from_output_range , double_precision_map_from_output_range generic :: num_hidden_layers => default_real_num_hidden_layers , double_precision_num_hidden_layers generic :: num_inputs => default_real_num_inputs , double_precision_num_inputs generic :: num_outputs => default_real_num_outputs , double_precision_num_outputs generic :: nodes_per_layer => default_real_nodes_per_layer , double_precision_nodes_per_layer generic :: assert_conformable_with => default_real_assert_conformable_with , double_precision_assert_conformable_with generic :: skip => default_real_skip , double_precision_skip generic :: activation_function_name => default_real_activation_name , double_precision_activation_name generic :: learn => default_real_learn generic :: assert_consistency => default_real_consistency , double_precision_consistency procedure , private , non_overridable :: default_real_consistency , double_precision_consistency procedure , private , non_overridable :: default_real_approximately_equal , double_precision_approximately_equal procedure , private , non_overridable :: default_real_infer , double_precision_infer procedure , private , non_overridable :: default_real_learn procedure , private , non_overridable :: default_real_to_json , double_precision_to_json procedure , private , non_overridable :: default_real_map_to_input_range , double_precision_map_to_input_range procedure , private , non_overridable :: default_real_map_from_output_range , double_precision_map_from_output_range procedure , private , non_overridable :: default_real_num_hidden_layers , double_precision_num_hidden_layers procedure , private , non_overridable :: default_real_num_inputs , double_precision_num_inputs procedure , private , non_overridable :: default_real_num_outputs , double_precision_num_outputs procedure , private , non_overridable :: default_real_nodes_per_layer , double_precision_nodes_per_layer procedure , private , non_overridable :: default_real_assert_conformable_with , double_precision_assert_conformable_with procedure , private , non_overridable :: default_real_skip , double_precision_skip procedure , private , non_overridable :: default_real_activation_name , double_precision_activation_name end type type workspace_t ( k ) integer , kind :: k = default_real real ( k ), allocatable , dimension (:,:) :: a real ( k ), allocatable , dimension (:,:,:) :: dcdw , vdw , sdw , vdwc , sdwc real ( k ), allocatable , dimension (:,:) :: z , delta , dcdb , vdb , sdb , vdbc , sdbc contains generic :: fully_allocated => default_real_allocated generic :: allocate_if_necessary => default_real_allocate procedure , non_overridable , private :: default_real_allocated procedure , non_overridable , private :: default_real_allocate end type interface workspace_t pure module function default_real_workspace ( neural_network ) result ( workspace ) implicit none type ( neural_network_t ), intent ( in ) :: neural_network type ( workspace_t ) workspace end function end interface interface module subroutine default_real_allocate ( self , neural_network ) implicit none class ( workspace_t ), intent ( inout ) :: self type ( neural_network_t ), intent ( in ) :: neural_network end subroutine pure module function default_real_allocated ( self ) result ( all_allocated ) implicit none class ( workspace_t ), intent ( in ) :: self logical all_allocated end function end interface interface neural_network_t module function default_real_construct_from_components ( metadata , weights , biases , nodes , input_map , output_map ) & result ( neural_network ) implicit none type ( string_t ), intent ( in ) :: metadata (:) real , intent ( in ) :: weights (:,:,:), biases (:,:) integer , intent ( in ) :: nodes ( 0 :) type ( tensor_map_t ), intent ( in ), optional :: input_map , output_map type ( neural_network_t ) neural_network end function module function double_precision_construct_from_components ( metadata , weights , biases , nodes , input_map , output_map ) & result ( neural_network ) implicit none type ( metadata_t ), intent ( in ) :: metadata double precision , intent ( in ) :: weights (:,:,:), biases (:,:) integer , intent ( in ) :: nodes ( 0 :) type ( tensor_map_t ( double_precision )), intent ( in ), optional :: input_map , output_map type ( neural_network_t ( double_precision )) neural_network end function impure elemental module function default_real_from_json ( file_ ) result ( neural_network ) implicit none type ( file_t ), intent ( in ) :: file_ type ( neural_network_t ) neural_network end function impure elemental module function double_precision_from_json ( file ) result ( neural_network ) implicit none type ( double_precision_file_t ), intent ( in ) :: file type ( neural_network_t ( double_precision )) neural_network end function end interface interface ! neural_network_t type-bound procedures elemental module function default_real_approximately_equal ( lhs , rhs ) result ( lhs_eq_rhs ) !! The result is true if lhs and rhs are the same to within a tolerance implicit none class ( neural_network_t ), intent ( in ) :: lhs , rhs logical lhs_eq_rhs end function elemental module function double_precision_approximately_equal ( lhs , rhs ) result ( lhs_eq_rhs ) !! The result is true if lhs and rhs are the same to within a tolerance implicit none class ( neural_network_t ( double_precision )), intent ( in ) :: lhs , rhs logical lhs_eq_rhs end function elemental module function default_real_map_to_input_range ( self , tensor ) result ( normalized_tensor ) !! The result contains the input tensor values normalized to fall on the range used during training implicit none class ( neural_network_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: tensor type ( tensor_t ) normalized_tensor end function elemental module function double_precision_map_to_input_range ( self , tensor ) result ( normalized_tensor ) !! The result contains the input tensor values normalized to fall on the range used during training implicit none class ( neural_network_t ( double_precision )), intent ( in ) :: self type ( tensor_t ( double_precision )), intent ( in ) :: tensor type ( tensor_t ( double_precision )) normalized_tensor end function elemental module function default_real_map_from_output_range ( self , normalized_tensor ) result ( tensor ) !! The result contains the output tensor values unmapped via the inverse of the mapping used in training implicit none class ( neural_network_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: normalized_tensor type ( tensor_t ) tensor end function elemental module function double_precision_map_from_output_range ( self , normalized_tensor ) result ( tensor ) !! The result contains the output tensor values unmapped via the inverse of the mapping used in training implicit none class ( neural_network_t ( double_precision )), intent ( in ) :: self type ( tensor_t ( double_precision )), intent ( in ) :: normalized_tensor type ( tensor_t ( double_precision )) tensor end function impure elemental module function default_real_to_json ( self ) result ( json_file ) implicit none class ( neural_network_t ), intent ( in ) :: self type ( file_t ) json_file end function impure elemental module function double_precision_to_json ( self ) result ( json_file ) implicit none class ( neural_network_t ( double_precision )), intent ( in ) :: self type ( file_t ) json_file end function elemental module subroutine default_real_assert_conformable_with ( self , neural_network ) implicit none class ( neural_network_t ), intent ( in ) :: self type ( neural_network_t ), intent ( in ) :: neural_network end subroutine elemental module subroutine double_precision_assert_conformable_with ( self , neural_network ) implicit none class ( neural_network_t ( double_precision )), intent ( in ) :: self type ( neural_network_t ( double_precision )), intent ( in ) :: neural_network end subroutine elemental module function default_real_infer ( self , inputs ) result ( outputs ) implicit none class ( neural_network_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: inputs type ( tensor_t ) outputs end function elemental module function double_precision_infer ( self , inputs ) result ( outputs ) implicit none class ( neural_network_t ( double_precision )), intent ( in ) :: self type ( tensor_t ( double_precision )), intent ( in ) :: inputs type ( tensor_t ( double_precision )) outputs end function elemental module function default_real_num_outputs ( self ) result ( output_count ) implicit none class ( neural_network_t ), intent ( in ) :: self integer output_count end function elemental module function double_precision_num_outputs ( self ) result ( output_count ) implicit none class ( neural_network_t ( double_precision )), intent ( in ) :: self integer output_count end function elemental module function default_real_num_hidden_layers ( self ) result ( hidden_layer_count ) implicit none class ( neural_network_t ), intent ( in ) :: self integer hidden_layer_count end function elemental module function double_precision_num_hidden_layers ( self ) result ( hidden_layer_count ) implicit none class ( neural_network_t ( double_precision )), intent ( in ) :: self integer hidden_layer_count end function elemental module function default_real_num_inputs ( self ) result ( input_count ) implicit none class ( neural_network_t ), intent ( in ) :: self integer input_count end function elemental module function double_precision_num_inputs ( self ) result ( input_count ) implicit none class ( neural_network_t ( double_precision )), intent ( in ) :: self integer input_count end function pure module function default_real_nodes_per_layer ( self ) result ( node_count ) implicit none class ( neural_network_t ), intent ( in ) :: self integer , allocatable :: node_count (:) end function pure module function double_precision_nodes_per_layer ( self ) result ( node_count ) implicit none class ( neural_network_t ( double_precision )), intent ( in ) :: self integer , allocatable :: node_count (:) end function elemental module function default_real_activation_name ( self ) result ( activation_name ) implicit none class ( neural_network_t ), intent ( in ) :: self type ( string_t ) activation_name end function elemental module function double_precision_activation_name ( self ) result ( activation_name ) implicit none class ( neural_network_t ( double_precision )), intent ( in ) :: self type ( string_t ) activation_name end function pure module function default_real_skip ( self ) result ( use_skip_connections ) implicit none class ( neural_network_t ), intent ( in ) :: self logical use_skip_connections end function pure module function double_precision_skip ( self ) result ( use_skip_connections ) implicit none class ( neural_network_t ( double_precision )), intent ( in ) :: self logical use_skip_connections end function pure module subroutine default_real_learn ( self , mini_batches_arr , cost , adam , learning_rate , workspace ) implicit none class ( neural_network_t ), intent ( inout ) :: self type ( mini_batch_t ), intent ( in ) :: mini_batches_arr (:) real , intent ( out ), allocatable , optional :: cost (:) logical , intent ( in ) :: adam real , intent ( in ) :: learning_rate type ( workspace_t ), intent ( inout ) :: workspace end subroutine pure module subroutine default_real_consistency ( self ) implicit none class ( neural_network_t ), intent ( in ) :: self end subroutine pure module subroutine double_precision_consistency ( self ) implicit none class ( neural_network_t ( double_precision )), intent ( in ) :: self end subroutine end interface type unmapped_network_t ( k ) integer , kind :: k = default_real private type ( neural_network_t ( k )) neural_network_ contains generic :: infer => default_real_infer_unmapped , double_precision_infer_unmapped procedure , private , non_overridable :: default_real_infer_unmapped , double_precision_infer_unmapped end type interface unmapped_network_t impure elemental module function double_precision_unmapped_from_json ( file ) result ( unmapped_network ) implicit none type ( double_precision_file_t ), intent ( in ) :: file type ( unmapped_network_t ( double_precision )) unmapped_network end function end interface interface elemental module function default_real_infer_unmapped ( self , inputs ) result ( outputs ) implicit none class ( unmapped_network_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: inputs type ( tensor_t ) outputs end function elemental module function double_precision_infer_unmapped ( self , inputs ) result ( outputs ) implicit none class ( unmapped_network_t ( double_precision )), intent ( in ) :: self type ( tensor_t ( double_precision )), intent ( in ) :: inputs type ( tensor_t ( double_precision )) outputs end function end interface end module neural_network_m","tags":"","loc":"sourcefile/neural_network_m.f90.html"},{"title":"train-and-write.F90 – Fiats","text":"This file depends on sourcefile~~train-and-write.f90~~EfferentGraph sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~train-and-write.f90->sourcefile~fiats_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~fiats_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~fiats_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~fiats_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~fiats_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~fiats_m.f90->sourcefile~metadata_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~fiats_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~network_configuration_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~fiats_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~fiats_m.f90->sourcefile~ubounds_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_network_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~trainable_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~activation_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program train_and_write !! This program demonstrates how to train a simple neural network starting from a randomized initial condition and !! how to write the initial network and the trained network to separate JSON files.  The network has two hiden layers. !! The input, hidden, and output layers are all two nodes wide.  The training data has outputs that identically match !! the corresponding inputs.  Hence, the desired network represents an identity mapping.  With RELU activation functions, !! the desired network therefore contains weights corresponding to identity matrices and biases that vanish everywhere. !! The initial condition corresponds to the desired network with all weights and biases perturbed by a random variable !! that is uniformly distributed on the range [0,0.1]. use fiats_m , only : & neural_network_t , trainable_network_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle use julienne_m , only : string_t , file_t , command_line_t , bin_t use assert_m , only : assert , intrinsic_array_t implicit none type ( string_t ) final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example train-and-write --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 5 , num_epochs = 500 , num_mini_batches = 3 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:) type ( trainable_network_t ) trainable_network type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) call random_init ( image_distinct = . true ., repeatable = . true .) trainable_network = perturbed_identity_network ( perturbation_magnitude = 0.2 ) call output ( trainable_network , string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_network % num_inputs (), num_outputs => trainable_network % num_outputs ()) call assert ( num_inputs == num_outputs , \"trainable_network_test_m(identity_mapping): # inputs == # outputs\" , & intrinsic_array_t ([ num_inputs , num_outputs ]) & ) block integer i , j inputs = [( tensor_t ( real ([( j * i , j = 1 , num_inputs )]) / ( num_inputs * num_pairs )), i = 1 , num_pairs )] end block associate ( outputs => inputs ) input_output_pairs = input_output_pair_t ( inputs , outputs ) end associate block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_network % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block real , parameter :: tolerance = 1.E-06 integer p #if defined _CRAYFTN || __GFORTRAN__ type ( tensor_t ), allocatable :: network_outputs (:) network_outputs = trainable_network % infer ( inputs ) #else associate ( network_outputs => trainable_network % infer ( inputs )) #endif print \"(a,43x,a,35x,a)\" , \" Output\" , \"| Desired outputs\" , \"| Errors\" do p = 1 , num_pairs print \"(2(3(G11.5,', '), G11.5, a), 3(G11.5,', '), G11.5)\" , & network_outputs ( p )% values (), \"| \" , inputs ( p )% values (), \"| \" , network_outputs ( p )% values () - inputs ( p )% values () end do #if defined _CRAYFTN || __GFORTRAN__ #else end associate #endif end block end associate call output ( trainable_network , final_network_file ) end block contains subroutine output ( neural_network , file_name ) class ( neural_network_t ), intent ( in ) :: neural_network type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = neural_network % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( m , n ) result ( e_mn ) integer , intent ( in ) :: m , n real e_mn e_mn = real ( merge ( 1 , 0 , m == n )) end function function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_network ) type ( trainable_network_t ) trainable_network real , intent ( in ) :: perturbation_magnitude integer , parameter :: nodes_per_layer ( * ) = [ 4 , 4 , 4 , 4 ] integer , parameter :: max_n = maxval ( nodes_per_layer ), layers = size ( nodes_per_layer ) integer i , j , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) identity = reshape ([( [( [( e ( i , j ), j = 1 , max_n )], i = 1 , max_n )], l = 1 , layers - 1 )], [ max_n , max_n , layers - 1 ]) allocate ( w_harvest ( max_n , max_n , layers - 1 )) allocate ( b_harvest ( max_n , layers - 1 )) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_network = trainable_network_t ( neural_network_t ( & nodes = nodes_per_layer , weights = w , biases = b , metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2024-10-13\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & )) end associate end function end program","tags":"","loc":"sourcefile/train-and-write.f90.html"},{"title":"metadata_s.f90 – Fiats","text":"This file depends on sourcefile~~metadata_s.f90~~EfferentGraph sourcefile~metadata_s.f90 metadata_s.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~metadata_s.f90->sourcefile~metadata_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( metadata_m ) metadata_s use assert_m , only : assert implicit none contains module procedure strings components = [ self % modelName_ , self % modelAuthor_ , self % compilationDate_ , self % activationFunction_ , self % usingSkipConnections_ ] end procedure module procedure activation_name function_name = self % activationFunction_ end procedure module procedure from_components metadata % modelName_ = modelName metadata % modelAuthor_ = modelAuthor metadata % compilationDate_ = compilationDate metadata % activationFunction_ = activationFunction metadata % usingSkipConnections_ = usingSkipConnections end procedure module procedure from_json integer l call assert ( lines ( 1 )% get_json_key () == \"metadata\" , \"metadata_s(from_json): metadata found\" ) do l = 2 , size ( lines ) - 1 associate ( key => lines ( l )% get_json_key ()) select case ( key % string ()) case ( \"modelName\" ) metadata % modelName_ = lines ( l )% get_json_value ( key , mold = string_t ( \"\" )) case ( \"modelAuthor\" ) metadata % modelAuthor_ = lines ( l )% get_json_value ( key , mold = string_t ( \"\" )) case ( \"compilationDate\" ) metadata % compilationDate_ = lines ( l )% get_json_value ( key , mold = string_t ( \"\" )) case ( \"activationFunction\" ) metadata % activationFunction_ = lines ( l )% get_json_value ( key , mold = string_t ( \"\" )) case ( \"usingSkipConnections\" ) metadata % usingSkipConnections_ = lines ( l )% get_json_value ( key , mold = string_t ( \"\" )) case default error stop \"metadata_s(from_json): missing key \" // key % string () end select end associate end do call assert ( any ( trim ( adjustl ( lines ( size ( lines ))% string ())) == [ \"},\" , \"} \" ]), \"metadata_s(from_json): metadata object end found\" ) end procedure module procedure double_precision_from_json integer l call assert ( lines ( 1 )% get_json_key () == \"metadata\" , \"metadata_s(double_precision_from_json): metadata found\" ) do l = 2 , size ( lines ) - 1 associate ( key => lines ( l )% get_json_key ()) select case ( key % string ()) case ( \"modelName\" ) metadata % modelName_ = lines ( l )% get_json_value ( key , mold = string_t ( \"\" )) case ( \"modelAuthor\" ) metadata % modelAuthor_ = lines ( l )% get_json_value ( key , mold = string_t ( \"\" )) case ( \"compilationDate\" ) metadata % compilationDate_ = lines ( l )% get_json_value ( key , mold = string_t ( \"\" )) case ( \"activationFunction\" ) metadata % activationFunction_ = lines ( l )% get_json_value ( key , mold = string_t ( \"\" )) case ( \"usingSkipConnections\" ) metadata % usingSkipConnections_ = lines ( l )% get_json_value ( key , mold = string_t ( \"\" )) case default error stop \"metadata_s(double_precision_from_json): missing key \" // key % string () end select end associate end do call assert ( any ( trim ( adjustl ( lines ( size ( lines ))% string ())) == [ \"},\" , \"} \" ]), & \"metadata_s(double_precision_from_json): metadata object end found\" ) end procedure module procedure to_json character ( len =* ), parameter :: indent = repeat ( \" \" , ncopies = 4 ) lines = [ & string_t ( indent // '\"metadata\": {' ), & string_t ( indent // indent // '\"modelName\" : \"' // trim ( adjustl ( self % modelName_ % string ())) // '\",' ), & string_t ( indent // indent // '\"modelAuthor\" : \"' // trim ( adjustl ( self % modelAuthor_ % string ())) // '\",' ), & string_t ( indent // indent // '\"compilationDate\" : \"' // trim ( adjustl ( self % compilationDate_ % string ())) // '\",' ), & string_t ( indent // indent // '\"activationFunction\" : \"' // trim ( adjustl ( self % activationFunction_ % string ())) // '\",' ), & string_t ( indent // indent // '\"usingSkipConnections\" : \"' // trim ( adjustl ( self % usingSkipConnections_ % string ())) // '\"' ), & string_t ( indent // '}' ) & ] end procedure module procedure equals lhs_equals_rhs = & lhs % modelName_ == rhs % modelName_ . and . & lhs % modelAuthor_ == rhs % modelAuthor_ . and . & lhs % compilationDate_ == rhs % compilationDate_ . and . & lhs % activationFunction_ == rhs % activationFunction_ . and . & lhs % usingSkipConnections_ == rhs % usingSkipConnections_ end procedure end submodule metadata_s","tags":"","loc":"sourcefile/metadata_s.f90.html"},{"title":"training_configuration_s.F90 – Fiats","text":"This file depends on sourcefile~~training_configuration_s.f90~~EfferentGraph sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~training_configuration_s.f90->sourcefile~activation_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~training_configuration_s.f90->sourcefile~double_precision_string_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~activation_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~training_configuration_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90->sourcefile~double_precision_string_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( training_configuration_m ) training_configuration_s use assert_m , only : assert use double_precision_string_m , only : double_precision_string_t use activation_m , only : activation_t , gelu , relu , sigmoid , swish implicit none character ( len =* ), parameter :: header = \"{\" , footer = \"}\" , separator = \",\" contains module procedure default_real_from_components training_configuration % hyperparameters_ = hyperparameters training_configuration % network_configuration_ = network_configuration training_configuration % file_t = file_t ([ & string_t ( header ), & training_configuration % hyperparameters_ % to_json (), & string_t ( separator ), & training_configuration % network_configuration_ % to_json (), & string_t ( footer ) & ]) end procedure module procedure double_precision_from_components training_configuration % hyperparameters_ = hyperparameters training_configuration % network_configuration_ = network_configuration training_configuration % file_t = file_t ([ & string_t ( header ), & training_configuration % hyperparameters_ % to_json (), & string_t ( separator ), & training_configuration % network_configuration_ % to_json (), & string_t ( footer ) & ]) end procedure module procedure default_real_from_file integer , parameter :: hyperparameters_start = 2 , hyperparameters_end = 6 , separator_line = 7 ! line numbers integer , parameter :: net_config_start = 8 , net_config_end = 12 ! line numbers integer , parameter :: file_start = hyperparameters_start - 1 , file_end = net_config_end + 1 ! line numbers #if defined __INTEL_COMPILER || _CRAYFTN type ( string_t ), allocatable :: lines (:) #endif training_configuration % file_t = file_object #if defined __INTEL_COMPILER || _CRAYFTN lines = training_configuration % file_t % lines () call assert ( trim ( adjustl ( lines ( file_start )% string ())) == header , & \"training_configuration_s(default_precision_from_file): header\" , lines ( file_start )) training_configuration % hyperparameters_ = hyperparameters_t ( lines ( hyperparameters_start : hyperparameters_end )) call assert ( trim ( adjustl ( lines ( separator_line )% string ())) == separator , & \"training_configuration_s(default_precision_from_file): separator\" , & lines ( file_start )) training_configuration % network_configuration_ = network_configuration_t ( lines ( net_config_start : net_config_end )) call assert ( trim ( adjustl ( lines ( file_end )% string ())) == footer , & \"training_configuration_s(default_precision_from_file): footer\" , lines ( file_end )) #else associate ( lines => training_configuration % file_t % lines ()) call assert ( trim ( adjustl ( lines ( file_start )% string ())) == header , & \"training_configuration_s(default_precision_from_file): header\" , lines ( file_start )) training_configuration % hyperparameters_ = hyperparameters_t ( lines ( hyperparameters_start : hyperparameters_end )) call assert ( trim ( adjustl ( lines ( separator_line )% string ())) == separator , & \"training_configuration_s(default_precision_from_file): separator\" , & lines ( file_start )) training_configuration % network_configuration_ = network_configuration_t ( lines ( net_config_start : net_config_end )) call assert ( trim ( adjustl ( lines ( file_end )% string ())) == footer , & \"training_configuration_s(default_precision_from_file): footer\" , lines ( file_end )) end associate #endif end procedure module procedure double_precision_from_file integer , parameter :: hyperparameters_start = 2 , hyperparameters_end = 6 , separator_line = 7 ! line numbers integer , parameter :: net_config_start = 8 , net_config_end = 12 ! line numbers integer , parameter :: file_start = hyperparameters_start - 1 , file_end = net_config_end + 1 ! line numbers #if defined __INTEL_COMPILER || _CRAYFTN type ( double_precision_string_t ), allocatable :: lines (:) #endif training_configuration % double_precision_file_t = file_object #if defined __INTEL_COMPILER || _CRAYFTN lines = training_configuration % double_precision_file_t % double_precision_lines () call assert ( adjustl ( lines ( file_start )% string ()) == header , & \"training_configuration_s(double_precision_from_file): header\" , lines ( file_start )) training_configuration % hyperparameters_ = hyperparameters_t ( lines ( hyperparameters_start : hyperparameters_end )) call assert ( adjustl ( lines ( separator_line )% string ()) == separator , & \"training_configuration_s(double_precision_from_file): separator\" , lines ( file_start )) training_configuration % network_configuration_ = network_configuration_t ( lines ( net_config_start : net_config_end )) call assert ( adjustl ( lines ( file_end )% string ()) == footer , & \"training_configuration_s(double_precision_from_file): footer\" , lines ( file_end )) #else associate ( lines => training_configuration % double_precision_file_t % double_precision_lines ()) call assert ( adjustl ( lines ( file_start )% string ()) == header , & \"training_configuration_s(double_precision_from_file): header\" , lines ( file_start )) training_configuration % hyperparameters_ = hyperparameters_t ( lines ( hyperparameters_start : hyperparameters_end )) call assert ( adjustl ( lines ( separator_line )% string ()) == separator , & \"training_configuration_s(double_precision_from_file): separator\" , lines ( file_start )) training_configuration % network_configuration_ = network_configuration_t ( lines ( net_config_start : net_config_end )) call assert ( adjustl ( lines ( file_end )% string ()) == footer , & \"training_configuration_s(double_precision_from_file): footer\" , lines ( file_end )) end associate #endif end procedure module procedure default_real_to_json json_lines = self % lines () end procedure module procedure double_precision_to_json json_lines = self % lines () end procedure module procedure default_real_equals lhs_eq_rhs = & lhs % hyperparameters_ == rhs % hyperparameters_ . and . & lhs % network_configuration_ == rhs % network_configuration_ end procedure module procedure double_precision_equals lhs_eq_rhs = & lhs % hyperparameters_ == rhs % hyperparameters_ . and . & lhs % network_configuration_ == rhs % network_configuration_ end procedure module procedure default_real_mini_batches num_mini_batches = self % hyperparameters_ % mini_batches () end procedure module procedure double_precision_mini_batches num_mini_batches = self % hyperparameters_ % mini_batches () end procedure module procedure default_real_optimizer_name identifier = self % hyperparameters_ % optimizer_name () end procedure module procedure double_precision_optimizer_name identifier = self % hyperparameters_ % optimizer_name () end procedure module procedure default_real_learning_rate rate = self % hyperparameters_ % learning_rate () end procedure module procedure double_precision_learning_rate rate = self % hyperparameters_ % learning_rate () end procedure module procedure default_real_nodes_per_layer nodes = self % network_configuration_ % nodes_per_layer () end procedure module procedure double_precision_nodes_per_layer nodes = self % network_configuration_ % nodes_per_layer () end procedure module procedure default_real_skip_connections using_skip = self % network_configuration_ % skip_connections () end procedure module procedure double_precision_skip_connections using_skip = self % network_configuration_ % skip_connections () end procedure module procedure default_real_differentiable_activation #if defined __INTEL_COMPILER || _CRAYFTN type ( string_t ) :: activation_name activation_name = self % network_configuration_ % activation_name () #else associate ( activation_name => self % network_configuration_ % activation_name ()) #endif select case ( activation_name % string ()) case ( \"gelu\" ) activation = activation_t ( gelu ) case ( \"relu\" ) activation = activation_t ( relu ) case ( \"sigmoid\" ) activation = activation_t ( sigmoid ) case ( \"swish\" ) activation = activation_t ( swish ) case default error stop 'activation_factory_s(factory): unrecognized activation name \"' // activation_name % string () // '\"' end select #if defined __INTEL_COMPILER || _CRAYFTN #else end associate #endif end procedure module procedure double_precision_differentiable_activation #if defined __INTEL_COMPILER || _CRAYFTN type ( string_t ) :: activation_name activation_name = self % network_configuration_ % activation_name () #else associate ( activation_name => self % network_configuration_ % activation_name ()) #endif select case ( activation_name % string ()) case ( \"gelu\" ) activation = activation_t ( gelu ) case ( \"relu\" ) activation = activation_t ( relu ) case ( \"sigmoid\" ) activation = activation_t ( sigmoid ) case ( \"swish\" ) activation = activation_t ( swish ) case default error stop 'activation_factory_s(factory): unrecognized activation name \"' // activation_name % string () // '\"' end select #if defined __INTEL_COMPILER || _CRAYFTN #else end associate #endif end procedure end submodule training_configuration_s","tags":"","loc":"sourcefile/training_configuration_s.f90.html"},{"title":"tensor_map_m.f90 – Fiats","text":"This file depends on sourcefile~~tensor_map_m.f90~~EfferentGraph sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~tensor_map_m.f90~~AfferentGraph sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~fiats_m.f90->sourcefile~tensor_map_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~tensor_map_m.f90 sourcefile~layer_m.f90->sourcefile~neural_network_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~tensor_map_s.f90 tensor_map_s.f90 sourcefile~tensor_map_s.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~fiats_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~fiats_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~fiats_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~fiats_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~fiats_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~neural_network_s.f90 neural_network_s.F90 sourcefile~neural_network_s.f90->sourcefile~layer_m.f90 sourcefile~neural_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~fiats_m.f90 sourcefile~read-query-infer.f90 read-query-infer.f90 sourcefile~read-query-infer.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~fiats_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~fiats_m.f90 sourcefile~trainable_network_s.f90 trainable_network_s.f90 sourcefile~trainable_network_s.f90->sourcefile~trainable_network_m.f90 sourcefile~unmapped_network_s.f90 unmapped_network_s.f90 sourcefile~unmapped_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~workspace_s.f90 workspace_s.f90 sourcefile~workspace_s.f90->sourcefile~neural_network_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~fiats_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module tensor_map_m use tensor_m , only : tensor_t use julienne_m , only : string_t use kind_parameters_m , only : default_real , double_precision use double_precision_string_m , only : double_precision_string_t implicit none private public :: tensor_map_t type tensor_map_t ( k ) integer , kind :: k = default_real character ( len = :), allocatable , private :: layer_ real ( k ), dimension (:), allocatable , private :: intercept_ , slope_ contains generic :: map_to_training_range => default_real_map_to_training_range , double_precision_map_to_training_range procedure , private , non_overridable :: default_real_map_to_training_range , double_precision_map_to_training_range generic :: map_from_training_range => default_real_map_from_training_range , double_precision_map_from_training_range procedure , private , non_overridable :: default_real_map_from_training_range , double_precision_map_from_training_range generic :: to_json => default_real_to_json , double_precision_to_json procedure , private :: default_real_to_json , double_precision_to_json generic :: operator ( == ) => default_real_equals , double_precision_equals procedure , private :: default_real_equals , double_precision_equals end type interface tensor_map_t pure module function construct_default_real ( layer , minima , maxima ) result ( tensor_map ) implicit none character ( len =* ), intent ( in ) :: layer real , dimension (:), intent ( in ) :: minima , maxima type ( tensor_map_t ) tensor_map end function pure module function construct_double_precision ( layer , minima , maxima ) result ( tensor_map ) implicit none character ( len =* ), intent ( in ) :: layer double precision , dimension (:), intent ( in ) :: minima , maxima type ( tensor_map_t ( double_precision )) tensor_map end function module function from_json ( lines ) result ( tensor_map ) implicit none type ( string_t ), intent ( in ) :: lines (:) type ( tensor_map_t ) tensor_map end function module function double_precision_from_json ( lines ) result ( tensor_map ) implicit none type ( double_precision_string_t ), intent ( in ) :: lines (:) type ( tensor_map_t ( double_precision )) tensor_map end function end interface interface elemental module function default_real_map_to_training_range ( self , tensor ) result ( normalized_tensor ) implicit none class ( tensor_map_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: tensor type ( tensor_t ) normalized_tensor end function elemental module function double_precision_map_to_training_range ( self , tensor ) result ( normalized_tensor ) implicit none class ( tensor_map_t ( double_precision )), intent ( in ) :: self type ( tensor_t ( double_precision )), intent ( in ) :: tensor type ( tensor_t ( double_precision )) normalized_tensor end function elemental module function default_real_map_from_training_range ( self , tensor ) result ( unnormalized_tensor ) implicit none class ( tensor_map_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: tensor type ( tensor_t ) unnormalized_tensor end function elemental module function double_precision_map_from_training_range ( self , tensor ) result ( unnormalized_tensor ) implicit none class ( tensor_map_t ( double_precision )), intent ( in ) :: self type ( tensor_t ( double_precision )), intent ( in ) :: tensor type ( tensor_t ( double_precision )) unnormalized_tensor end function pure module function default_real_to_json ( self ) result ( lines ) implicit none class ( tensor_map_t ), intent ( in ) :: self type ( string_t ), allocatable :: lines (:) end function pure module function double_precision_to_json ( self ) result ( lines ) implicit none class ( tensor_map_t ( double_precision )), intent ( in ) :: self type ( string_t ), allocatable :: lines (:) end function elemental module function default_real_equals ( lhs , rhs ) result ( lhs_equals_rhs ) implicit none class ( tensor_map_t ), intent ( in ) :: lhs , rhs logical lhs_equals_rhs end function elemental module function double_precision_equals ( lhs , rhs ) result ( lhs_equals_rhs ) implicit none class ( tensor_map_t ( double_precision )), intent ( in ) :: lhs , rhs logical lhs_equals_rhs end function end interface end module tensor_map_m","tags":"","loc":"sourcefile/tensor_map_m.f90.html"},{"title":"metadata_m.f90 – Fiats","text":"This file depends on sourcefile~~metadata_m.f90~~EfferentGraph sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~metadata_m.f90~~AfferentGraph sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~fiats_m.f90 fiats_m.f90 sourcefile~fiats_m.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~fiats_m.f90->sourcefile~neural_network_m.f90 sourcefile~trainable_network_m.f90 trainable_network_m.f90 sourcefile~fiats_m.f90->sourcefile~trainable_network_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~metadata_m.f90 sourcefile~layer_m.f90->sourcefile~neural_network_m.f90 sourcefile~metadata_s.f90 metadata_s.f90 sourcefile~metadata_s.f90->sourcefile~metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~fiats_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~fiats_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~fiats_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~fiats_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~fiats_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~neural_network_s.f90 neural_network_s.F90 sourcefile~neural_network_s.f90->sourcefile~layer_m.f90 sourcefile~neural_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~fiats_m.f90 sourcefile~read-query-infer.f90 read-query-infer.f90 sourcefile~read-query-infer.f90->sourcefile~fiats_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~fiats_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~fiats_m.f90 sourcefile~trainable_network_m.f90->sourcefile~neural_network_m.f90 sourcefile~unmapped_network_s.f90 unmapped_network_s.f90 sourcefile~unmapped_network_s.f90->sourcefile~neural_network_m.f90 sourcefile~workspace_s.f90 workspace_s.f90 sourcefile~workspace_s.f90->sourcefile~neural_network_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~fiats_m.f90 sourcefile~trainable_network_s.f90 trainable_network_s.f90 sourcefile~trainable_network_s.f90->sourcefile~trainable_network_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module metadata_m use julienne_string_m , only : string_t use double_precision_string_m , only : double_precision_string_t implicit none private public :: metadata_t type metadata_t private type ( string_t ) modelName_ , modelAuthor_ , compilationDate_ , activationFunction_ , usingSkipConnections_ contains generic :: operator ( == ) => equals procedure :: strings procedure :: to_json procedure :: activation_name procedure , private :: equals end type interface metadata_t pure module function from_json ( lines ) result ( metadata ) implicit none type ( string_t ), intent ( in ) :: lines (:) type ( metadata_t ) metadata end function pure module function double_precision_from_json ( lines ) result ( metadata ) implicit none type ( double_precision_string_t ), intent ( in ) :: lines (:) type ( metadata_t ) metadata end function pure module function from_components ( modelName , modelAuthor , compilationDate , activationFunction , usingSkipConnections ) & result ( metadata ) implicit none type ( string_t ), intent ( in ) :: modelName , modelAuthor , compilationDate , activationFunction , usingSkipConnections type ( metadata_t ) metadata end function end interface interface pure module function strings ( self ) result ( components ) implicit none class ( metadata_t ), intent ( in ) :: self type ( string_t ), allocatable :: components (:) end function pure module function activation_name ( self ) result ( function_name ) implicit none class ( metadata_t ), intent ( in ) :: self type ( string_t ) function_name end function pure module function to_json ( self ) result ( lines ) implicit none class ( metadata_t ), intent ( in ) :: self type ( string_t ), allocatable :: lines (:) end function elemental module function equals ( lhs , rhs ) result ( lhs_equals_rhs ) implicit none class ( metadata_t ), intent ( in ) :: lhs , rhs logical lhs_equals_rhs end function end interface end module","tags":"","loc":"sourcefile/metadata_m.f90.html"},{"title":"workspace_s.f90 – Fiats","text":"This file depends on sourcefile~~workspace_s.f90~~EfferentGraph sourcefile~workspace_s.f90 workspace_s.f90 sourcefile~neural_network_m.f90 neural_network_m.f90 sourcefile~workspace_s.f90->sourcefile~neural_network_m.f90 sourcefile~activation_m.f90 activation_m.f90 sourcefile~neural_network_m.f90->sourcefile~activation_m.f90 sourcefile~double_precision_file_m.f90 double_precision_file_m.f90 sourcefile~neural_network_m.f90->sourcefile~double_precision_file_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neural_network_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~metadata_m.f90 metadata_m.f90 sourcefile~neural_network_m.f90->sourcefile~metadata_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~neural_network_m.f90->sourcefile~mini_batch_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90 tensor_map_m.f90 sourcefile~neural_network_m.f90->sourcefile~tensor_map_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~double_precision_file_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~metadata_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_map_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_map_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( neural_network_m ) workspace_s use assert_m , only : assert implicit none integer , parameter :: input_layer = 0 contains module procedure default_real_workspace allocate ( workspace % dcdw , mold = neural_network % weights_ ) ! Gradient of cost function with respect to weights allocate ( workspace % vdw , mold = neural_network % weights_ ) allocate ( workspace % sdw , mold = neural_network % weights_ ) allocate ( workspace % vdwc , mold = neural_network % weights_ ) allocate ( workspace % sdwc , mold = neural_network % weights_ ) allocate ( workspace % dcdb , mold = neural_network % biases_ ) ! Gradient of cost function with respect with biases allocate ( workspace % vdb , mold = neural_network % biases_ ) allocate ( workspace % sdb , mold = neural_network % biases_ ) allocate ( workspace % vdbc , mold = neural_network % biases_ ) allocate ( workspace % sdbc , mold = neural_network % biases_ ) ! TODO: #if ! (F2023_LOCALITY || F2018_LOCALITY) !          then don't allocate a, z, and delta allocate ( workspace % z , mold = neural_network % biases_ ) allocate ( workspace % delta , mold = neural_network % biases_ ) associate ( output_layer => ubound ( neural_network % nodes_ , 1 )) allocate ( workspace % a ( maxval ( neural_network % nodes_ ), input_layer : output_layer )) ! Activations end associate call assert ( workspace % fully_allocated (), \"workspace_s(defalt_real_workspace): workspace allocated\" ) end procedure module procedure default_real_allocated ! TODO: #if ! (F2023_LOCALITY || F2018_LOCALITY) !          then don't check a, z, and delta allocations all_allocated = all ( [ & allocated ( self % a ), allocated ( self % dcdw ), allocated ( self % vdw ), allocated ( self % sdw ), allocated ( self % vdwc ), allocated ( self % sdwc )& , allocated ( self % z ), allocated ( self % dcdb ), allocated ( self % vdb ), allocated ( self % sdb ), allocated ( self % vdbc ), allocated ( self % sdbc )& , allocated ( self % delta ) & ]) end procedure module procedure default_real_allocate call allocate_if_necessary ( self % dcdw , mold = neural_network % weights_ ) ! Gradient of cost function with respect to weights call allocate_if_necessary ( self % vdw , mold = neural_network % weights_ ) call allocate_if_necessary ( self % sdw , mold = neural_network % weights_ ) call allocate_if_necessary ( self % vdwc , mold = neural_network % weights_ ) call allocate_if_necessary ( self % sdwc , mold = neural_network % weights_ ) call allocate_if_necessary ( self % dcdb , mold = neural_network % biases_ ) ! Gradient of cost function with respect with biases call allocate_if_necessary ( self % vdb , mold = neural_network % biases_ ) call allocate_if_necessary ( self % sdb , mold = neural_network % biases_ ) call allocate_if_necessary ( self % vdbc , mold = neural_network % biases_ ) call allocate_if_necessary ( self % sdbc , mold = neural_network % biases_ ) ! TODO: #if ! (F2023_LOCALITY || F2018_LOCALITY) !          then don't allocate a, z, and delta call allocate_if_necessary ( self % z , mold = neural_network % biases_ ) call allocate_if_necessary ( self % delta , mold = neural_network % biases_ ) associate ( output_layer => ubound ( neural_network % nodes_ , 1 )) allocate ( self % a ( maxval ( neural_network % nodes_ ), input_layer : output_layer )) ! Activations end associate contains subroutine allocate_if_necessary ( array , mold ) real , allocatable , intent ( inout ) :: array (..) real , intent ( in ) :: mold (..) select rank ( array ) rank ( 2 ) select rank ( mold ) rank ( 2 ) if (. not . allocated ( array )) then allocate ( array , mold = mold ) else if ( any ( shape ( array ) /= shape ( mold ))) then deallocate ( array ) allocate ( array , mold = mold ) end if end if rank default error stop \"workspace_s(allocate_if_necessary): mold-rank mismatch with rank-2 'array'\" end select rank ( 3 ) select rank ( mold ) rank ( 3 ) if (. not . allocated ( array )) then allocate ( array , mold = mold ) else if ( any ( shape ( array ) /= shape ( mold ))) then deallocate ( array ) allocate ( array , mold = mold ) end if end if rank default error stop \"workspace_s(allocate_if_necessary): mold-rank mismatch with rank-3 'array'\" end select rank default error stop \"workspace_s(allocate_if_necessary): unsupported 'array' rank\" end select end subroutine allocate_if_necessary end procedure default_real_allocate end submodule workspace_s","tags":"","loc":"sourcefile/workspace_s.f90.html"},{"title":"network_configuration_s.F90 – Fiats","text":"This file depends on sourcefile~~network_configuration_s.f90~~EfferentGraph sourcefile~network_configuration_s.f90 network_configuration_s.F90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~network_configuration_s.f90->sourcefile~network_configuration_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~network_configuration_m.f90->sourcefile~double_precision_string_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( network_configuration_m ) network_configuration_s use assert_m , only : assert use julienne_formats_m , only : csv implicit none character ( len =* ), parameter :: skip_connections_key = \"skip connections\" character ( len =* ), parameter :: nodes_per_layer_key = \"nodes per layer\" character ( len =* ), parameter :: activation_name_key = \"activation function\" contains module procedure from_components network_configuration % skip_connections_ = skip_connections network_configuration % nodes_per_layer_ = nodes_per_layer network_configuration % activation_name_ = activation_name end procedure module procedure equals call assert ( allocated ( lhs % activation_name_ ) . and . allocated ( rhs % activation_name_ ), & \"network_configuration_s(equals): allocated({lhs,rhs}%activation_name_)\" ) lhs_equals_rhs = & lhs % skip_connections_ . eqv . rhs % skip_connections_ . and . & lhs % activation_name_ == rhs % activation_name_ . and . & all ( lhs % nodes_per_layer_ == rhs % nodes_per_layer_ ) end procedure module procedure from_json integer l logical network_configuration_key_found network_configuration_key_found = . false . do l = 1 , size ( lines ) if ( lines ( l )% get_json_key () == \"network configuration\" ) then network_configuration_key_found = . true . network_configuration % skip_connections_ = lines ( l + 1 )% get_json_value ( string_t ( skip_connections_key ), mold = . true .) network_configuration % nodes_per_layer_ = lines ( l + 2 )% get_json_value ( string_t ( nodes_per_layer_key ), mold = [ integer :: ]) network_configuration % activation_name_ = lines ( l + 3 )% get_json_value ( string_t ( activation_name_key ), mold = string_t ( \"\" )) return end if end do call assert ( network_configuration_key_found , \"network_configuration_s(from_json): network_configuration_found\" ) end procedure module procedure from_double_precision_string_json integer l logical network_configuration_key_found network_configuration_key_found = . false . do l = 1 , size ( lines ) if ( lines ( l )% get_json_key () == \"network configuration\" ) then network_configuration_key_found = . true . network_configuration % skip_connections_ = lines ( l + 1 )% get_json_value ( string_t ( skip_connections_key ), mold = . true .) network_configuration % nodes_per_layer_ = lines ( l + 2 )% get_json_value ( string_t ( nodes_per_layer_key ), mold = [ integer :: ]) network_configuration % activation_name_ = lines ( l + 3 )% get_json_value ( string_t ( activation_name_key ), mold = string_t ( \"\" )) return end if end do call assert ( network_configuration_key_found , & \"network_configuration_s(from_double_precision_string_json): network_configuration_found\" ) end procedure module procedure to_json character ( len =* ), parameter :: indent = repeat ( \" \" , ncopies = 4 ) integer , parameter :: max_logical_width = 6 , char_per_elem = 10 , brackets = 2 character ( len = max_logical_width ) skip_connections_string character ( len = :), allocatable :: nodes_per_layer_string allocate ( character ( len = size ( self % nodes_per_layer_ ) * char_per_elem + brackets ) :: nodes_per_layer_string ) #ifdef _CRAYFTN if ( self % skip_connections_ ) then write ( skip_connections_string , * ) \"true\" else write ( skip_connections_string , * ) \"false\" end if #else write ( skip_connections_string , * ) trim ( merge ( \"true \" , \"false\" , self % skip_connections_ )) #endif write ( nodes_per_layer_string , csv ) self % nodes_per_layer_ lines = [ & string_t ( indent // '\"network configuration\": {' ), & string_t ( indent // indent // '\"' // skip_connections_key // '\" : ' // trim ( adjustl ( skip_connections_string )) // ',' ), & string_t ( indent // indent // '\"' // nodes_per_layer_key // '\" : [' // trim ( adjustl ( nodes_per_layer_string )) // '],' ), & string_t ( indent // indent // '\"' // activation_name_key // '\" : \"' // trim ( adjustl ( self % activation_name_ )) // '\"' ), & string_t ( indent // '}' ) & ] end procedure module procedure activation_name string = self % activation_name_ end procedure module procedure nodes_per_layer nodes = self % nodes_per_layer_ end procedure module procedure skip_connections using_skip = self % skip_connections_ end procedure end submodule network_configuration_s","tags":"","loc":"sourcefile/network_configuration_s.f90.html"},{"title":"mini_batch_s.f90 – Fiats","text":"This file depends on sourcefile~~mini_batch_s.f90~~EfferentGraph sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( mini_batch_m ) mini_batch_s implicit none contains module procedure default_real_construct mini_batch % input_output_pairs_ = input_output_pairs end procedure module procedure double_precision_construct mini_batch % input_output_pairs_ = input_output_pairs end procedure module procedure default_real_input_output_pairs my_input_output_pairs = self % input_output_pairs_ end procedure module procedure double_precision_input_output_pairs my_input_output_pairs = self % input_output_pairs_ end procedure end submodule mini_batch_s","tags":"","loc":"sourcefile/mini_batch_s.f90.html"},{"title":"neuron_s.f90 – Fiats","text":"This file depends on sourcefile~~neuron_s.f90~~EfferentGraph sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~double_precision_string_m.f90 double_precision_string_m.f90 sourcefile~neuron_m.f90->sourcefile~double_precision_string_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( neuron_m ) neuron_s use assert_m , only : assert use julienne_formats_m , only : separated_values implicit none contains module procedure default_real_to_json integer , parameter :: characters_per_value = 17 character ( len =* ), parameter :: indent = repeat ( \" \" , ncopies = 12 ) character ( len = :), allocatable :: csv_format , weights_string , bias_string call assert ( allocated ( self % weights_ ), \"neuron_s(to_json): allocated weights_\" ) csv_format = separated_values ( separator = \",\" , mold = [ real :: ]) allocate ( character ( len = size ( self % weights_ ) * ( characters_per_value + 1 ) - 1 ) :: weights_string ) allocate ( character ( len = characters_per_value ) :: bias_string ) write ( weights_string , fmt = csv_format ) self % weights_ write ( bias_string , * ) self % bias_ lines = [ & string_t ( indent // '{' ), & string_t ( indent // '  \"weights\": [' // trim ( adjustl ( weights_string )) // '],' ), & string_t ( indent // '  \"bias\": ' // trim ( adjustl ( bias_string ))), & string_t ( indent // '}' ) & ] end procedure module procedure double_precision_to_json integer , parameter :: characters_per_value = 34 character ( len =* ), parameter :: indent = repeat ( \" \" , ncopies = 12 ) character ( len = :), allocatable :: csv_format , weights_string , bias_string call assert ( allocated ( self % weights_ ), \"neuron_s(to_json): allocated weights_\" ) csv_format = separated_values ( separator = \",\" , mold = [ double precision :: ]) allocate ( character ( len = size ( self % weights_ ) * ( characters_per_value + 1 ) - 1 ) :: weights_string ) allocate ( character ( len = characters_per_value ) :: bias_string ) write ( weights_string , fmt = csv_format ) self % weights_ write ( bias_string , * ) self % bias_ lines = [ & string_t ( indent // '{' ), & string_t ( indent // '  \"weights\": [' // trim ( adjustl ( weights_string )) // '],' ), & string_t ( indent // '  \"bias\": ' // trim ( adjustl ( bias_string ))), & string_t ( indent // '}' ) & ] end procedure module procedure from_json character ( len = :), allocatable :: line integer i call assert ( adjustl ( neuron_lines ( start )% string ()) == '{' , \"neuron_s(construct): neuron object start\" , neuron_lines ( start )% string ()) line = neuron_lines ( start + 1 )% string () associate ( colon => index ( line , \":\" )) call assert ( adjustl ( line (: colon - 1 )) == '\"weights\"' , \"neuron_s(construct): neuron weights\" , line ) associate ( opening_bracket => colon + index ( line ( colon + 1 :), \"[\" )) associate ( closing_bracket => opening_bracket + index ( line ( opening_bracket + 1 :), \"]\" )) associate ( commas => count ( \",\" == [( line ( i : i ), i = opening_bracket + 1 , closing_bracket - 1 )])) associate ( num_inputs => commas + 1 ) allocate ( neuron % weights_ ( num_inputs )) read ( line ( opening_bracket + 1 : closing_bracket - 1 ), fmt =* ) neuron % weights_ end associate end associate end associate end associate end associate line = neuron_lines ( start + 2 )% string () associate ( colon => index ( line , \":\" )) call assert ( adjustl ( line (: colon - 1 )) == '\"bias\"' , \"neuron_s(construct): neuron bias\" , line ) read ( line ( colon + 1 :), fmt =* ) neuron % bias_ end associate line = adjustl ( neuron_lines ( start + 3 )% string ()) call assert ( line ( 1 : 1 ) == '}' , \"neuron_s(construct): neuron object end\" , line ) line = adjustr ( neuron_lines ( start + 3 )% string ()) if ( line ( len ( line ): len ( line )) == \",\" ) neuron % next = from_json ( neuron_lines , start + 4 ) end procedure module procedure double_precision_from_json character ( len = :), allocatable :: line integer i call assert ( adjustl ( neuron_lines ( start )% string ()) == '{' , & \"neuron_s(double_precison_from_json): neuron object start\" , neuron_lines ( start )% string ()) line = neuron_lines ( start + 1 )% string () associate ( colon => index ( line , \":\" )) call assert ( adjustl ( line (: colon - 1 )) == '\"weights\"' , \"neuron_s(double_precision_from_json): neuron weights\" , line ) associate ( opening_bracket => colon + index ( line ( colon + 1 :), \"[\" )) associate ( closing_bracket => opening_bracket + index ( line ( opening_bracket + 1 :), \"]\" )) associate ( commas => count ( \",\" == [( line ( i : i ), i = opening_bracket + 1 , closing_bracket - 1 )])) associate ( num_inputs => commas + 1 ) allocate ( neuron % weights_ ( num_inputs )) read ( line ( opening_bracket + 1 : closing_bracket - 1 ), fmt =* ) neuron % weights_ end associate end associate end associate end associate end associate line = neuron_lines ( start + 2 )% string () associate ( colon => index ( line , \":\" )) call assert ( adjustl ( line (: colon - 1 )) == '\"bias\"' , \"neuron_s(double_precision_from_json): neuron bias\" , line ) read ( line ( colon + 1 :), fmt =* ) neuron % bias_ end associate line = adjustl ( neuron_lines ( start + 3 )% string ()) call assert ( line ( 1 : 1 ) == '}' , \"neuron_s(double_precision_from_json): neuron object end\" , line ) line = adjustr ( neuron_lines ( start + 3 )% string ()) if ( line ( len ( line ): len ( line )) == \",\" ) neuron % next = double_precision_from_json ( neuron_lines , start + 4 ) end procedure module procedure default_real_from_components neuron % weights_ = weights neuron % bias_ = bias end procedure module procedure double_precision_from_components neuron % weights_ = weights neuron % bias_ = bias end procedure module procedure default_real_weights my_weights = self % weights_ end procedure module procedure double_precision_weights my_weights = self % weights_ end procedure module procedure default_real_bias my_bias = self % bias_ end procedure module procedure double_precision_bias my_bias = self % bias_ end procedure module procedure default_real_next_allocated next_is_allocated = allocated ( self % next ) end procedure module procedure double_precision_next_allocated next_is_allocated = allocated ( self % next ) end procedure module procedure default_real_next_pointer if ( allocated ( self % next )) then next_ptr => self % next else next_ptr => null () end if end procedure module procedure double_precision_next_pointer if ( allocated ( self % next )) then next_ptr => self % next else next_ptr => null () end if end procedure module procedure default_real_num_inputs size_weights = size ( self % weights_ ) end procedure module procedure double_precision_num_inputs size_weights = size ( self % weights_ ) end procedure end submodule neuron_s","tags":"","loc":"sourcefile/neuron_s.f90.html"}]}